
integration_Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006f02  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000019c  00800060  00006f02  00006f96  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000005f8  008001fc  008001fc  00007132  2**0
                  ALLOC
  3 .stab         00008a18  00000000  00000000  00007134  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000040f8  00000000  00000000  0000fb4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  00013c44  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f2  00000000  00000000  00013de4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240b  00000000  00000000  00013fd6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001386  00000000  00000000  000163e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d6  00000000  00000000  00017767  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  00018940  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f6  00000000  00000000  00018b00  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000096e  00000000  00000000  00018df6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00019764  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 53 24 	jmp	0x48a6	; 0x48a6 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 ee 07 	jmp	0xfdc	; 0xfdc <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 d0 0c 	jmp	0x19a0	; 0x19a0 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e0       	ldi	r30, 0x02	; 2
      68:	ff e6       	ldi	r31, 0x6F	; 111
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 3f       	cpi	r26, 0xFC	; 252
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	ac ef       	ldi	r26, 0xFC	; 252
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 3f       	cpi	r26, 0xF4	; 244
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 4f 31 	call	0x629e	; 0x629e <main>
      8a:	0c 94 7f 37 	jmp	0x6efe	; 0x6efe <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 29 37 	jmp	0x6e52	; 0x6e52 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a3 eb       	ldi	r26, 0xB3	; 179
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 45 37 	jmp	0x6e8a	; 0x6e8a <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 35 37 	jmp	0x6e6a	; 0x6e6a <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 51 37 	jmp	0x6ea2	; 0x6ea2 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 35 37 	jmp	0x6e6a	; 0x6e6a <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 51 37 	jmp	0x6ea2	; 0x6ea2 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 29 37 	jmp	0x6e52	; 0x6e52 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	83 eb       	ldi	r24, 0xB3	; 179
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 45 37 	jmp	0x6e8a	; 0x6e8a <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 31 37 	jmp	0x6e62	; 0x6e62 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	63 eb       	ldi	r22, 0xB3	; 179
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 4d 37 	jmp	0x6e9a	; 0x6e9a <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 35 37 	jmp	0x6e6a	; 0x6e6a <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 51 37 	jmp	0x6ea2	; 0x6ea2 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 35 37 	jmp	0x6e6a	; 0x6e6a <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 51 37 	jmp	0x6ea2	; 0x6ea2 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 35 37 	jmp	0x6e6a	; 0x6e6a <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 51 37 	jmp	0x6ea2	; 0x6ea2 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 39 37 	jmp	0x6e72	; 0x6e72 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 55 37 	jmp	0x6eaa	; 0x6eaa <__epilogue_restores__+0x20>

00000952 <__floatunsisf>:
     952:	a8 e0       	ldi	r26, 0x08	; 8
     954:	b0 e0       	ldi	r27, 0x00	; 0
     956:	ef ea       	ldi	r30, 0xAF	; 175
     958:	f4 e0       	ldi	r31, 0x04	; 4
     95a:	0c 94 31 37 	jmp	0x6e62	; 0x6e62 <__prologue_saves__+0x10>
     95e:	7b 01       	movw	r14, r22
     960:	8c 01       	movw	r16, r24
     962:	61 15       	cp	r22, r1
     964:	71 05       	cpc	r23, r1
     966:	81 05       	cpc	r24, r1
     968:	91 05       	cpc	r25, r1
     96a:	19 f4       	brne	.+6      	; 0x972 <__floatunsisf+0x20>
     96c:	82 e0       	ldi	r24, 0x02	; 2
     96e:	89 83       	std	Y+1, r24	; 0x01
     970:	60 c0       	rjmp	.+192    	; 0xa32 <__floatunsisf+0xe0>
     972:	83 e0       	ldi	r24, 0x03	; 3
     974:	89 83       	std	Y+1, r24	; 0x01
     976:	8e e1       	ldi	r24, 0x1E	; 30
     978:	c8 2e       	mov	r12, r24
     97a:	d1 2c       	mov	r13, r1
     97c:	dc 82       	std	Y+4, r13	; 0x04
     97e:	cb 82       	std	Y+3, r12	; 0x03
     980:	ed 82       	std	Y+5, r14	; 0x05
     982:	fe 82       	std	Y+6, r15	; 0x06
     984:	0f 83       	std	Y+7, r16	; 0x07
     986:	18 87       	std	Y+8, r17	; 0x08
     988:	c8 01       	movw	r24, r16
     98a:	b7 01       	movw	r22, r14
     98c:	0e 94 22 05 	call	0xa44	; 0xa44 <__clzsi2>
     990:	fc 01       	movw	r30, r24
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	f7 ff       	sbrs	r31, 7
     996:	3b c0       	rjmp	.+118    	; 0xa0e <__floatunsisf+0xbc>
     998:	22 27       	eor	r18, r18
     99a:	33 27       	eor	r19, r19
     99c:	2e 1b       	sub	r18, r30
     99e:	3f 0b       	sbc	r19, r31
     9a0:	57 01       	movw	r10, r14
     9a2:	68 01       	movw	r12, r16
     9a4:	02 2e       	mov	r0, r18
     9a6:	04 c0       	rjmp	.+8      	; 0x9b0 <__floatunsisf+0x5e>
     9a8:	d6 94       	lsr	r13
     9aa:	c7 94       	ror	r12
     9ac:	b7 94       	ror	r11
     9ae:	a7 94       	ror	r10
     9b0:	0a 94       	dec	r0
     9b2:	d2 f7       	brpl	.-12     	; 0x9a8 <__floatunsisf+0x56>
     9b4:	40 e0       	ldi	r20, 0x00	; 0
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	a0 e0       	ldi	r26, 0x00	; 0
     9c2:	b0 e0       	ldi	r27, 0x00	; 0
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__floatunsisf+0x7c>
     9c6:	88 0f       	add	r24, r24
     9c8:	99 1f       	adc	r25, r25
     9ca:	aa 1f       	adc	r26, r26
     9cc:	bb 1f       	adc	r27, r27
     9ce:	2a 95       	dec	r18
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__floatunsisf+0x74>
     9d2:	01 97       	sbiw	r24, 0x01	; 1
     9d4:	a1 09       	sbc	r26, r1
     9d6:	b1 09       	sbc	r27, r1
     9d8:	8e 21       	and	r24, r14
     9da:	9f 21       	and	r25, r15
     9dc:	a0 23       	and	r26, r16
     9de:	b1 23       	and	r27, r17
     9e0:	00 97       	sbiw	r24, 0x00	; 0
     9e2:	a1 05       	cpc	r26, r1
     9e4:	b1 05       	cpc	r27, r1
     9e6:	21 f0       	breq	.+8      	; 0x9f0 <__floatunsisf+0x9e>
     9e8:	41 e0       	ldi	r20, 0x01	; 1
     9ea:	50 e0       	ldi	r21, 0x00	; 0
     9ec:	60 e0       	ldi	r22, 0x00	; 0
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	4a 29       	or	r20, r10
     9f2:	5b 29       	or	r21, r11
     9f4:	6c 29       	or	r22, r12
     9f6:	7d 29       	or	r23, r13
     9f8:	4d 83       	std	Y+5, r20	; 0x05
     9fa:	5e 83       	std	Y+6, r21	; 0x06
     9fc:	6f 83       	std	Y+7, r22	; 0x07
     9fe:	78 87       	std	Y+8, r23	; 0x08
     a00:	8e e1       	ldi	r24, 0x1E	; 30
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	8e 1b       	sub	r24, r30
     a06:	9f 0b       	sbc	r25, r31
     a08:	9c 83       	std	Y+4, r25	; 0x04
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	12 c0       	rjmp	.+36     	; 0xa32 <__floatunsisf+0xe0>
     a0e:	30 97       	sbiw	r30, 0x00	; 0
     a10:	81 f0       	breq	.+32     	; 0xa32 <__floatunsisf+0xe0>
     a12:	0e 2e       	mov	r0, r30
     a14:	04 c0       	rjmp	.+8      	; 0xa1e <__floatunsisf+0xcc>
     a16:	ee 0c       	add	r14, r14
     a18:	ff 1c       	adc	r15, r15
     a1a:	00 1f       	adc	r16, r16
     a1c:	11 1f       	adc	r17, r17
     a1e:	0a 94       	dec	r0
     a20:	d2 f7       	brpl	.-12     	; 0xa16 <__floatunsisf+0xc4>
     a22:	ed 82       	std	Y+5, r14	; 0x05
     a24:	fe 82       	std	Y+6, r15	; 0x06
     a26:	0f 83       	std	Y+7, r16	; 0x07
     a28:	18 87       	std	Y+8, r17	; 0x08
     a2a:	ce 1a       	sub	r12, r30
     a2c:	df 0a       	sbc	r13, r31
     a2e:	dc 82       	std	Y+4, r13	; 0x04
     a30:	cb 82       	std	Y+3, r12	; 0x03
     a32:	1a 82       	std	Y+2, r1	; 0x02
     a34:	ce 01       	movw	r24, r28
     a36:	01 96       	adiw	r24, 0x01	; 1
     a38:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     a3c:	28 96       	adiw	r28, 0x08	; 8
     a3e:	ea e0       	ldi	r30, 0x0A	; 10
     a40:	0c 94 4d 37 	jmp	0x6e9a	; 0x6e9a <__epilogue_restores__+0x10>

00000a44 <__clzsi2>:
     a44:	ef 92       	push	r14
     a46:	ff 92       	push	r15
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	7b 01       	movw	r14, r22
     a4e:	8c 01       	movw	r16, r24
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	e8 16       	cp	r14, r24
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	f8 06       	cpc	r15, r24
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	08 07       	cpc	r16, r24
     a5c:	80 e0       	ldi	r24, 0x00	; 0
     a5e:	18 07       	cpc	r17, r24
     a60:	88 f4       	brcc	.+34     	; 0xa84 <__clzsi2+0x40>
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	e8 16       	cp	r14, r24
     a66:	f1 04       	cpc	r15, r1
     a68:	01 05       	cpc	r16, r1
     a6a:	11 05       	cpc	r17, r1
     a6c:	31 f0       	breq	.+12     	; 0xa7a <__clzsi2+0x36>
     a6e:	28 f0       	brcs	.+10     	; 0xa7a <__clzsi2+0x36>
     a70:	88 e0       	ldi	r24, 0x08	; 8
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	a0 e0       	ldi	r26, 0x00	; 0
     a76:	b0 e0       	ldi	r27, 0x00	; 0
     a78:	17 c0       	rjmp	.+46     	; 0xaa8 <__clzsi2+0x64>
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	a0 e0       	ldi	r26, 0x00	; 0
     a80:	b0 e0       	ldi	r27, 0x00	; 0
     a82:	12 c0       	rjmp	.+36     	; 0xaa8 <__clzsi2+0x64>
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	e8 16       	cp	r14, r24
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	f8 06       	cpc	r15, r24
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	08 07       	cpc	r16, r24
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	18 07       	cpc	r17, r24
     a94:	28 f0       	brcs	.+10     	; 0xaa0 <__clzsi2+0x5c>
     a96:	88 e1       	ldi	r24, 0x18	; 24
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	04 c0       	rjmp	.+8      	; 0xaa8 <__clzsi2+0x64>
     aa0:	80 e1       	ldi	r24, 0x10	; 16
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	a0 e0       	ldi	r26, 0x00	; 0
     aa6:	b0 e0       	ldi	r27, 0x00	; 0
     aa8:	20 e2       	ldi	r18, 0x20	; 32
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	28 1b       	sub	r18, r24
     ab2:	39 0b       	sbc	r19, r25
     ab4:	4a 0b       	sbc	r20, r26
     ab6:	5b 0b       	sbc	r21, r27
     ab8:	04 c0       	rjmp	.+8      	; 0xac2 <__clzsi2+0x7e>
     aba:	16 95       	lsr	r17
     abc:	07 95       	ror	r16
     abe:	f7 94       	ror	r15
     ac0:	e7 94       	ror	r14
     ac2:	8a 95       	dec	r24
     ac4:	d2 f7       	brpl	.-12     	; 0xaba <__clzsi2+0x76>
     ac6:	f7 01       	movw	r30, r14
     ac8:	e5 54       	subi	r30, 0x45	; 69
     aca:	ff 4f       	sbci	r31, 0xFF	; 255
     acc:	80 81       	ld	r24, Z
     ace:	28 1b       	sub	r18, r24
     ad0:	31 09       	sbc	r19, r1
     ad2:	41 09       	sbc	r20, r1
     ad4:	51 09       	sbc	r21, r1
     ad6:	c9 01       	movw	r24, r18
     ad8:	1f 91       	pop	r17
     ada:	0f 91       	pop	r16
     adc:	ff 90       	pop	r15
     ade:	ef 90       	pop	r14
     ae0:	08 95       	ret

00000ae2 <__pack_f>:
     ae2:	df 92       	push	r13
     ae4:	ef 92       	push	r14
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	fc 01       	movw	r30, r24
     aee:	e4 80       	ldd	r14, Z+4	; 0x04
     af0:	f5 80       	ldd	r15, Z+5	; 0x05
     af2:	06 81       	ldd	r16, Z+6	; 0x06
     af4:	17 81       	ldd	r17, Z+7	; 0x07
     af6:	d1 80       	ldd	r13, Z+1	; 0x01
     af8:	80 81       	ld	r24, Z
     afa:	82 30       	cpi	r24, 0x02	; 2
     afc:	48 f4       	brcc	.+18     	; 0xb10 <__pack_f+0x2e>
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	a0 e1       	ldi	r26, 0x10	; 16
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	e8 2a       	or	r14, r24
     b08:	f9 2a       	or	r15, r25
     b0a:	0a 2b       	or	r16, r26
     b0c:	1b 2b       	or	r17, r27
     b0e:	a5 c0       	rjmp	.+330    	; 0xc5a <__pack_f+0x178>
     b10:	84 30       	cpi	r24, 0x04	; 4
     b12:	09 f4       	brne	.+2      	; 0xb16 <__pack_f+0x34>
     b14:	9f c0       	rjmp	.+318    	; 0xc54 <__pack_f+0x172>
     b16:	82 30       	cpi	r24, 0x02	; 2
     b18:	21 f4       	brne	.+8      	; 0xb22 <__pack_f+0x40>
     b1a:	ee 24       	eor	r14, r14
     b1c:	ff 24       	eor	r15, r15
     b1e:	87 01       	movw	r16, r14
     b20:	05 c0       	rjmp	.+10     	; 0xb2c <__pack_f+0x4a>
     b22:	e1 14       	cp	r14, r1
     b24:	f1 04       	cpc	r15, r1
     b26:	01 05       	cpc	r16, r1
     b28:	11 05       	cpc	r17, r1
     b2a:	19 f4       	brne	.+6      	; 0xb32 <__pack_f+0x50>
     b2c:	e0 e0       	ldi	r30, 0x00	; 0
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	96 c0       	rjmp	.+300    	; 0xc5e <__pack_f+0x17c>
     b32:	62 81       	ldd	r22, Z+2	; 0x02
     b34:	73 81       	ldd	r23, Z+3	; 0x03
     b36:	9f ef       	ldi	r25, 0xFF	; 255
     b38:	62 38       	cpi	r22, 0x82	; 130
     b3a:	79 07       	cpc	r23, r25
     b3c:	0c f0       	brlt	.+2      	; 0xb40 <__pack_f+0x5e>
     b3e:	5b c0       	rjmp	.+182    	; 0xbf6 <__pack_f+0x114>
     b40:	22 e8       	ldi	r18, 0x82	; 130
     b42:	3f ef       	ldi	r19, 0xFF	; 255
     b44:	26 1b       	sub	r18, r22
     b46:	37 0b       	sbc	r19, r23
     b48:	2a 31       	cpi	r18, 0x1A	; 26
     b4a:	31 05       	cpc	r19, r1
     b4c:	2c f0       	brlt	.+10     	; 0xb58 <__pack_f+0x76>
     b4e:	20 e0       	ldi	r18, 0x00	; 0
     b50:	30 e0       	ldi	r19, 0x00	; 0
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	2a c0       	rjmp	.+84     	; 0xbac <__pack_f+0xca>
     b58:	b8 01       	movw	r22, r16
     b5a:	a7 01       	movw	r20, r14
     b5c:	02 2e       	mov	r0, r18
     b5e:	04 c0       	rjmp	.+8      	; 0xb68 <__pack_f+0x86>
     b60:	76 95       	lsr	r23
     b62:	67 95       	ror	r22
     b64:	57 95       	ror	r21
     b66:	47 95       	ror	r20
     b68:	0a 94       	dec	r0
     b6a:	d2 f7       	brpl	.-12     	; 0xb60 <__pack_f+0x7e>
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	a0 e0       	ldi	r26, 0x00	; 0
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__pack_f+0x9c>
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	aa 1f       	adc	r26, r26
     b7c:	bb 1f       	adc	r27, r27
     b7e:	2a 95       	dec	r18
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__pack_f+0x94>
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	a1 09       	sbc	r26, r1
     b86:	b1 09       	sbc	r27, r1
     b88:	8e 21       	and	r24, r14
     b8a:	9f 21       	and	r25, r15
     b8c:	a0 23       	and	r26, r16
     b8e:	b1 23       	and	r27, r17
     b90:	00 97       	sbiw	r24, 0x00	; 0
     b92:	a1 05       	cpc	r26, r1
     b94:	b1 05       	cpc	r27, r1
     b96:	21 f0       	breq	.+8      	; 0xba0 <__pack_f+0xbe>
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a0 e0       	ldi	r26, 0x00	; 0
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	9a 01       	movw	r18, r20
     ba2:	ab 01       	movw	r20, r22
     ba4:	28 2b       	or	r18, r24
     ba6:	39 2b       	or	r19, r25
     ba8:	4a 2b       	or	r20, r26
     baa:	5b 2b       	or	r21, r27
     bac:	da 01       	movw	r26, r20
     bae:	c9 01       	movw	r24, r18
     bb0:	8f 77       	andi	r24, 0x7F	; 127
     bb2:	90 70       	andi	r25, 0x00	; 0
     bb4:	a0 70       	andi	r26, 0x00	; 0
     bb6:	b0 70       	andi	r27, 0x00	; 0
     bb8:	80 34       	cpi	r24, 0x40	; 64
     bba:	91 05       	cpc	r25, r1
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	39 f4       	brne	.+14     	; 0xbd0 <__pack_f+0xee>
     bc2:	27 ff       	sbrs	r18, 7
     bc4:	09 c0       	rjmp	.+18     	; 0xbd8 <__pack_f+0xf6>
     bc6:	20 5c       	subi	r18, 0xC0	; 192
     bc8:	3f 4f       	sbci	r19, 0xFF	; 255
     bca:	4f 4f       	sbci	r20, 0xFF	; 255
     bcc:	5f 4f       	sbci	r21, 0xFF	; 255
     bce:	04 c0       	rjmp	.+8      	; 0xbd8 <__pack_f+0xf6>
     bd0:	21 5c       	subi	r18, 0xC1	; 193
     bd2:	3f 4f       	sbci	r19, 0xFF	; 255
     bd4:	4f 4f       	sbci	r20, 0xFF	; 255
     bd6:	5f 4f       	sbci	r21, 0xFF	; 255
     bd8:	e0 e0       	ldi	r30, 0x00	; 0
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	20 30       	cpi	r18, 0x00	; 0
     bde:	a0 e0       	ldi	r26, 0x00	; 0
     be0:	3a 07       	cpc	r19, r26
     be2:	a0 e0       	ldi	r26, 0x00	; 0
     be4:	4a 07       	cpc	r20, r26
     be6:	a0 e4       	ldi	r26, 0x40	; 64
     be8:	5a 07       	cpc	r21, r26
     bea:	10 f0       	brcs	.+4      	; 0xbf0 <__pack_f+0x10e>
     bec:	e1 e0       	ldi	r30, 0x01	; 1
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	79 01       	movw	r14, r18
     bf2:	8a 01       	movw	r16, r20
     bf4:	27 c0       	rjmp	.+78     	; 0xc44 <__pack_f+0x162>
     bf6:	60 38       	cpi	r22, 0x80	; 128
     bf8:	71 05       	cpc	r23, r1
     bfa:	64 f5       	brge	.+88     	; 0xc54 <__pack_f+0x172>
     bfc:	fb 01       	movw	r30, r22
     bfe:	e1 58       	subi	r30, 0x81	; 129
     c00:	ff 4f       	sbci	r31, 0xFF	; 255
     c02:	d8 01       	movw	r26, r16
     c04:	c7 01       	movw	r24, r14
     c06:	8f 77       	andi	r24, 0x7F	; 127
     c08:	90 70       	andi	r25, 0x00	; 0
     c0a:	a0 70       	andi	r26, 0x00	; 0
     c0c:	b0 70       	andi	r27, 0x00	; 0
     c0e:	80 34       	cpi	r24, 0x40	; 64
     c10:	91 05       	cpc	r25, r1
     c12:	a1 05       	cpc	r26, r1
     c14:	b1 05       	cpc	r27, r1
     c16:	39 f4       	brne	.+14     	; 0xc26 <__pack_f+0x144>
     c18:	e7 fe       	sbrs	r14, 7
     c1a:	0d c0       	rjmp	.+26     	; 0xc36 <__pack_f+0x154>
     c1c:	80 e4       	ldi	r24, 0x40	; 64
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	a0 e0       	ldi	r26, 0x00	; 0
     c22:	b0 e0       	ldi	r27, 0x00	; 0
     c24:	04 c0       	rjmp	.+8      	; 0xc2e <__pack_f+0x14c>
     c26:	8f e3       	ldi	r24, 0x3F	; 63
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	a0 e0       	ldi	r26, 0x00	; 0
     c2c:	b0 e0       	ldi	r27, 0x00	; 0
     c2e:	e8 0e       	add	r14, r24
     c30:	f9 1e       	adc	r15, r25
     c32:	0a 1f       	adc	r16, r26
     c34:	1b 1f       	adc	r17, r27
     c36:	17 ff       	sbrs	r17, 7
     c38:	05 c0       	rjmp	.+10     	; 0xc44 <__pack_f+0x162>
     c3a:	16 95       	lsr	r17
     c3c:	07 95       	ror	r16
     c3e:	f7 94       	ror	r15
     c40:	e7 94       	ror	r14
     c42:	31 96       	adiw	r30, 0x01	; 1
     c44:	87 e0       	ldi	r24, 0x07	; 7
     c46:	16 95       	lsr	r17
     c48:	07 95       	ror	r16
     c4a:	f7 94       	ror	r15
     c4c:	e7 94       	ror	r14
     c4e:	8a 95       	dec	r24
     c50:	d1 f7       	brne	.-12     	; 0xc46 <__pack_f+0x164>
     c52:	05 c0       	rjmp	.+10     	; 0xc5e <__pack_f+0x17c>
     c54:	ee 24       	eor	r14, r14
     c56:	ff 24       	eor	r15, r15
     c58:	87 01       	movw	r16, r14
     c5a:	ef ef       	ldi	r30, 0xFF	; 255
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	6e 2f       	mov	r22, r30
     c60:	67 95       	ror	r22
     c62:	66 27       	eor	r22, r22
     c64:	67 95       	ror	r22
     c66:	90 2f       	mov	r25, r16
     c68:	9f 77       	andi	r25, 0x7F	; 127
     c6a:	d7 94       	ror	r13
     c6c:	dd 24       	eor	r13, r13
     c6e:	d7 94       	ror	r13
     c70:	8e 2f       	mov	r24, r30
     c72:	86 95       	lsr	r24
     c74:	49 2f       	mov	r20, r25
     c76:	46 2b       	or	r20, r22
     c78:	58 2f       	mov	r21, r24
     c7a:	5d 29       	or	r21, r13
     c7c:	b7 01       	movw	r22, r14
     c7e:	ca 01       	movw	r24, r20
     c80:	1f 91       	pop	r17
     c82:	0f 91       	pop	r16
     c84:	ff 90       	pop	r15
     c86:	ef 90       	pop	r14
     c88:	df 90       	pop	r13
     c8a:	08 95       	ret

00000c8c <__unpack_f>:
     c8c:	fc 01       	movw	r30, r24
     c8e:	db 01       	movw	r26, r22
     c90:	40 81       	ld	r20, Z
     c92:	51 81       	ldd	r21, Z+1	; 0x01
     c94:	22 81       	ldd	r18, Z+2	; 0x02
     c96:	62 2f       	mov	r22, r18
     c98:	6f 77       	andi	r22, 0x7F	; 127
     c9a:	70 e0       	ldi	r23, 0x00	; 0
     c9c:	22 1f       	adc	r18, r18
     c9e:	22 27       	eor	r18, r18
     ca0:	22 1f       	adc	r18, r18
     ca2:	93 81       	ldd	r25, Z+3	; 0x03
     ca4:	89 2f       	mov	r24, r25
     ca6:	88 0f       	add	r24, r24
     ca8:	82 2b       	or	r24, r18
     caa:	28 2f       	mov	r18, r24
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	99 1f       	adc	r25, r25
     cb0:	99 27       	eor	r25, r25
     cb2:	99 1f       	adc	r25, r25
     cb4:	11 96       	adiw	r26, 0x01	; 1
     cb6:	9c 93       	st	X, r25
     cb8:	11 97       	sbiw	r26, 0x01	; 1
     cba:	21 15       	cp	r18, r1
     cbc:	31 05       	cpc	r19, r1
     cbe:	a9 f5       	brne	.+106    	; 0xd2a <__unpack_f+0x9e>
     cc0:	41 15       	cp	r20, r1
     cc2:	51 05       	cpc	r21, r1
     cc4:	61 05       	cpc	r22, r1
     cc6:	71 05       	cpc	r23, r1
     cc8:	11 f4       	brne	.+4      	; 0xcce <__unpack_f+0x42>
     cca:	82 e0       	ldi	r24, 0x02	; 2
     ccc:	37 c0       	rjmp	.+110    	; 0xd3c <__unpack_f+0xb0>
     cce:	82 e8       	ldi	r24, 0x82	; 130
     cd0:	9f ef       	ldi	r25, 0xFF	; 255
     cd2:	13 96       	adiw	r26, 0x03	; 3
     cd4:	9c 93       	st	X, r25
     cd6:	8e 93       	st	-X, r24
     cd8:	12 97       	sbiw	r26, 0x02	; 2
     cda:	9a 01       	movw	r18, r20
     cdc:	ab 01       	movw	r20, r22
     cde:	67 e0       	ldi	r22, 0x07	; 7
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	55 1f       	adc	r21, r21
     ce8:	6a 95       	dec	r22
     cea:	d1 f7       	brne	.-12     	; 0xce0 <__unpack_f+0x54>
     cec:	83 e0       	ldi	r24, 0x03	; 3
     cee:	8c 93       	st	X, r24
     cf0:	0d c0       	rjmp	.+26     	; 0xd0c <__unpack_f+0x80>
     cf2:	22 0f       	add	r18, r18
     cf4:	33 1f       	adc	r19, r19
     cf6:	44 1f       	adc	r20, r20
     cf8:	55 1f       	adc	r21, r21
     cfa:	12 96       	adiw	r26, 0x02	; 2
     cfc:	8d 91       	ld	r24, X+
     cfe:	9c 91       	ld	r25, X
     d00:	13 97       	sbiw	r26, 0x03	; 3
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	13 96       	adiw	r26, 0x03	; 3
     d06:	9c 93       	st	X, r25
     d08:	8e 93       	st	-X, r24
     d0a:	12 97       	sbiw	r26, 0x02	; 2
     d0c:	20 30       	cpi	r18, 0x00	; 0
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	38 07       	cpc	r19, r24
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	48 07       	cpc	r20, r24
     d16:	80 e4       	ldi	r24, 0x40	; 64
     d18:	58 07       	cpc	r21, r24
     d1a:	58 f3       	brcs	.-42     	; 0xcf2 <__unpack_f+0x66>
     d1c:	14 96       	adiw	r26, 0x04	; 4
     d1e:	2d 93       	st	X+, r18
     d20:	3d 93       	st	X+, r19
     d22:	4d 93       	st	X+, r20
     d24:	5c 93       	st	X, r21
     d26:	17 97       	sbiw	r26, 0x07	; 7
     d28:	08 95       	ret
     d2a:	2f 3f       	cpi	r18, 0xFF	; 255
     d2c:	31 05       	cpc	r19, r1
     d2e:	79 f4       	brne	.+30     	; 0xd4e <__unpack_f+0xc2>
     d30:	41 15       	cp	r20, r1
     d32:	51 05       	cpc	r21, r1
     d34:	61 05       	cpc	r22, r1
     d36:	71 05       	cpc	r23, r1
     d38:	19 f4       	brne	.+6      	; 0xd40 <__unpack_f+0xb4>
     d3a:	84 e0       	ldi	r24, 0x04	; 4
     d3c:	8c 93       	st	X, r24
     d3e:	08 95       	ret
     d40:	64 ff       	sbrs	r22, 4
     d42:	03 c0       	rjmp	.+6      	; 0xd4a <__unpack_f+0xbe>
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	8c 93       	st	X, r24
     d48:	12 c0       	rjmp	.+36     	; 0xd6e <__unpack_f+0xe2>
     d4a:	1c 92       	st	X, r1
     d4c:	10 c0       	rjmp	.+32     	; 0xd6e <__unpack_f+0xe2>
     d4e:	2f 57       	subi	r18, 0x7F	; 127
     d50:	30 40       	sbci	r19, 0x00	; 0
     d52:	13 96       	adiw	r26, 0x03	; 3
     d54:	3c 93       	st	X, r19
     d56:	2e 93       	st	-X, r18
     d58:	12 97       	sbiw	r26, 0x02	; 2
     d5a:	83 e0       	ldi	r24, 0x03	; 3
     d5c:	8c 93       	st	X, r24
     d5e:	87 e0       	ldi	r24, 0x07	; 7
     d60:	44 0f       	add	r20, r20
     d62:	55 1f       	adc	r21, r21
     d64:	66 1f       	adc	r22, r22
     d66:	77 1f       	adc	r23, r23
     d68:	8a 95       	dec	r24
     d6a:	d1 f7       	brne	.-12     	; 0xd60 <__unpack_f+0xd4>
     d6c:	70 64       	ori	r23, 0x40	; 64
     d6e:	14 96       	adiw	r26, 0x04	; 4
     d70:	4d 93       	st	X+, r20
     d72:	5d 93       	st	X+, r21
     d74:	6d 93       	st	X+, r22
     d76:	7c 93       	st	X, r23
     d78:	17 97       	sbiw	r26, 0x07	; 7
     d7a:	08 95       	ret

00000d7c <__fpcmp_parts_f>:
     d7c:	1f 93       	push	r17
     d7e:	dc 01       	movw	r26, r24
     d80:	fb 01       	movw	r30, r22
     d82:	9c 91       	ld	r25, X
     d84:	92 30       	cpi	r25, 0x02	; 2
     d86:	08 f4       	brcc	.+2      	; 0xd8a <__fpcmp_parts_f+0xe>
     d88:	47 c0       	rjmp	.+142    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d8a:	80 81       	ld	r24, Z
     d8c:	82 30       	cpi	r24, 0x02	; 2
     d8e:	08 f4       	brcc	.+2      	; 0xd92 <__fpcmp_parts_f+0x16>
     d90:	43 c0       	rjmp	.+134    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d92:	94 30       	cpi	r25, 0x04	; 4
     d94:	51 f4       	brne	.+20     	; 0xdaa <__fpcmp_parts_f+0x2e>
     d96:	11 96       	adiw	r26, 0x01	; 1
     d98:	1c 91       	ld	r17, X
     d9a:	84 30       	cpi	r24, 0x04	; 4
     d9c:	99 f5       	brne	.+102    	; 0xe04 <__fpcmp_parts_f+0x88>
     d9e:	81 81       	ldd	r24, Z+1	; 0x01
     da0:	68 2f       	mov	r22, r24
     da2:	70 e0       	ldi	r23, 0x00	; 0
     da4:	61 1b       	sub	r22, r17
     da6:	71 09       	sbc	r23, r1
     da8:	3f c0       	rjmp	.+126    	; 0xe28 <__fpcmp_parts_f+0xac>
     daa:	84 30       	cpi	r24, 0x04	; 4
     dac:	21 f0       	breq	.+8      	; 0xdb6 <__fpcmp_parts_f+0x3a>
     dae:	92 30       	cpi	r25, 0x02	; 2
     db0:	31 f4       	brne	.+12     	; 0xdbe <__fpcmp_parts_f+0x42>
     db2:	82 30       	cpi	r24, 0x02	; 2
     db4:	b9 f1       	breq	.+110    	; 0xe24 <__fpcmp_parts_f+0xa8>
     db6:	81 81       	ldd	r24, Z+1	; 0x01
     db8:	88 23       	and	r24, r24
     dba:	89 f1       	breq	.+98     	; 0xe1e <__fpcmp_parts_f+0xa2>
     dbc:	2d c0       	rjmp	.+90     	; 0xe18 <__fpcmp_parts_f+0x9c>
     dbe:	11 96       	adiw	r26, 0x01	; 1
     dc0:	1c 91       	ld	r17, X
     dc2:	11 97       	sbiw	r26, 0x01	; 1
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	f1 f0       	breq	.+60     	; 0xe04 <__fpcmp_parts_f+0x88>
     dc8:	81 81       	ldd	r24, Z+1	; 0x01
     dca:	18 17       	cp	r17, r24
     dcc:	d9 f4       	brne	.+54     	; 0xe04 <__fpcmp_parts_f+0x88>
     dce:	12 96       	adiw	r26, 0x02	; 2
     dd0:	2d 91       	ld	r18, X+
     dd2:	3c 91       	ld	r19, X
     dd4:	13 97       	sbiw	r26, 0x03	; 3
     dd6:	82 81       	ldd	r24, Z+2	; 0x02
     dd8:	93 81       	ldd	r25, Z+3	; 0x03
     dda:	82 17       	cp	r24, r18
     ddc:	93 07       	cpc	r25, r19
     dde:	94 f0       	brlt	.+36     	; 0xe04 <__fpcmp_parts_f+0x88>
     de0:	28 17       	cp	r18, r24
     de2:	39 07       	cpc	r19, r25
     de4:	bc f0       	brlt	.+46     	; 0xe14 <__fpcmp_parts_f+0x98>
     de6:	14 96       	adiw	r26, 0x04	; 4
     de8:	8d 91       	ld	r24, X+
     dea:	9d 91       	ld	r25, X+
     dec:	0d 90       	ld	r0, X+
     dee:	bc 91       	ld	r27, X
     df0:	a0 2d       	mov	r26, r0
     df2:	24 81       	ldd	r18, Z+4	; 0x04
     df4:	35 81       	ldd	r19, Z+5	; 0x05
     df6:	46 81       	ldd	r20, Z+6	; 0x06
     df8:	57 81       	ldd	r21, Z+7	; 0x07
     dfa:	28 17       	cp	r18, r24
     dfc:	39 07       	cpc	r19, r25
     dfe:	4a 07       	cpc	r20, r26
     e00:	5b 07       	cpc	r21, r27
     e02:	18 f4       	brcc	.+6      	; 0xe0a <__fpcmp_parts_f+0x8e>
     e04:	11 23       	and	r17, r17
     e06:	41 f0       	breq	.+16     	; 0xe18 <__fpcmp_parts_f+0x9c>
     e08:	0a c0       	rjmp	.+20     	; 0xe1e <__fpcmp_parts_f+0xa2>
     e0a:	82 17       	cp	r24, r18
     e0c:	93 07       	cpc	r25, r19
     e0e:	a4 07       	cpc	r26, r20
     e10:	b5 07       	cpc	r27, r21
     e12:	40 f4       	brcc	.+16     	; 0xe24 <__fpcmp_parts_f+0xa8>
     e14:	11 23       	and	r17, r17
     e16:	19 f0       	breq	.+6      	; 0xe1e <__fpcmp_parts_f+0xa2>
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <__fpcmp_parts_f+0xac>
     e1e:	6f ef       	ldi	r22, 0xFF	; 255
     e20:	7f ef       	ldi	r23, 0xFF	; 255
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <__fpcmp_parts_f+0xac>
     e24:	60 e0       	ldi	r22, 0x00	; 0
     e26:	70 e0       	ldi	r23, 0x00	; 0
     e28:	cb 01       	movw	r24, r22
     e2a:	1f 91       	pop	r17
     e2c:	08 95       	ret

00000e2e <MUSART_VidInit>:

void (*MUSART_CallBack)(void);

/*USART Initialization*/
void MUSART_VidInit(void)
{
     e2e:	df 93       	push	r29
     e30:	cf 93       	push	r28
     e32:	0f 92       	push	r0
     e34:	cd b7       	in	r28, 0x3d	; 61
     e36:	de b7       	in	r29, 0x3e	; 62
	u8 LOC_u8Copy_UCSRC=0;
     e38:	19 82       	std	Y+1, r1	; 0x01
	/*Select USART Mode*/
#if USART_SET_MODE==USART_ASYNCHRONOUS_MODE
	CLR_BIT(LOC_u8Copy_UCSRC,6);
     e3a:	89 81       	ldd	r24, Y+1	; 0x01
     e3c:	8f 7b       	andi	r24, 0xBF	; 191
     e3e:	89 83       	std	Y+1, r24	; 0x01
#else
#error"USART Mode Is not valid..."
#endif
	/*Parity Mode*/
#if USART_SET_PARITY_MODE==USART_DISABLED_PARITY
	CLR_BIT(LOC_u8Copy_UCSRC,5);
     e40:	89 81       	ldd	r24, Y+1	; 0x01
     e42:	8f 7d       	andi	r24, 0xDF	; 223
     e44:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(LOC_u8Copy_UCSRC,4);
     e46:	89 81       	ldd	r24, Y+1	; 0x01
     e48:	8f 7e       	andi	r24, 0xEF	; 239
     e4a:	89 83       	std	Y+1, r24	; 0x01
#else
#error"USART Parity Mode Is not valid..."
#endif
	/*Select Stop Bit*/
#if USART_SET_STOP_BIT==USART_STOP_ONE_BIT
	CLR_BIT(LOC_u8Copy_UCSRC,3);
     e4c:	89 81       	ldd	r24, Y+1	; 0x01
     e4e:	87 7f       	andi	r24, 0xF7	; 247
     e50:	89 83       	std	Y+1, r24	; 0x01
#elif USART_SET_CHR_SIZE==USART_CHR_SIZE_7
	SET_BIT(LOC_u8Copy_UCSRC,2);
	CLR_BIT(LOC_u8Copy_UCSRC,1);
	CLR_BIT(UCSRB,2);
#elif USART_SET_CHR_SIZE==USART_CHR_SIZE_8
	SET_BIT(LOC_u8Copy_UCSRC,2);
     e52:	89 81       	ldd	r24, Y+1	; 0x01
     e54:	84 60       	ori	r24, 0x04	; 4
     e56:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(LOC_u8Copy_UCSRC,1);
     e58:	89 81       	ldd	r24, Y+1	; 0x01
     e5a:	82 60       	ori	r24, 0x02	; 2
     e5c:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(UCSRB,2);
     e5e:	aa e2       	ldi	r26, 0x2A	; 42
     e60:	b0 e0       	ldi	r27, 0x00	; 0
     e62:	ea e2       	ldi	r30, 0x2A	; 42
     e64:	f0 e0       	ldi	r31, 0x00	; 0
     e66:	80 81       	ld	r24, Z
     e68:	8b 7f       	andi	r24, 0xFB	; 251
     e6a:	8c 93       	st	X, r24
	SET_BIT(UCSRB,2);
#else
#error"USART CHR SIZE Is not valid..."
#endif
	/*Set LOC_u8Copy_UCSRC Value in UCSRC Register and select UCSRC Register*/
	SET_BIT(LOC_u8Copy_UCSRC,7);
     e6c:	89 81       	ldd	r24, Y+1	; 0x01
     e6e:	80 68       	ori	r24, 0x80	; 128
     e70:	89 83       	std	Y+1, r24	; 0x01
	UCSRC=LOC_u8Copy_UCSRC;
     e72:	e0 e4       	ldi	r30, 0x40	; 64
     e74:	f0 e0       	ldi	r31, 0x00	; 0
     e76:	89 81       	ldd	r24, Y+1	; 0x01
     e78:	80 83       	st	Z, r24
	/*Set BuadRate -->9600*/
	UBRRL=51;
     e7a:	e9 e2       	ldi	r30, 0x29	; 41
     e7c:	f0 e0       	ldi	r31, 0x00	; 0
     e7e:	83 e3       	ldi	r24, 0x33	; 51
     e80:	80 83       	st	Z, r24
	/*Enable To TX and RX*/
	SET_BIT(UCSRB,4);
     e82:	aa e2       	ldi	r26, 0x2A	; 42
     e84:	b0 e0       	ldi	r27, 0x00	; 0
     e86:	ea e2       	ldi	r30, 0x2A	; 42
     e88:	f0 e0       	ldi	r31, 0x00	; 0
     e8a:	80 81       	ld	r24, Z
     e8c:	80 61       	ori	r24, 0x10	; 16
     e8e:	8c 93       	st	X, r24
	SET_BIT(UCSRB,3);
     e90:	aa e2       	ldi	r26, 0x2A	; 42
     e92:	b0 e0       	ldi	r27, 0x00	; 0
     e94:	ea e2       	ldi	r30, 0x2A	; 42
     e96:	f0 e0       	ldi	r31, 0x00	; 0
     e98:	80 81       	ld	r24, Z
     e9a:	88 60       	ori	r24, 0x08	; 8
     e9c:	8c 93       	st	X, r24
}
     e9e:	0f 90       	pop	r0
     ea0:	cf 91       	pop	r28
     ea2:	df 91       	pop	r29
     ea4:	08 95       	ret

00000ea6 <MUSART_VidSendChar>:
/*USART Send Data*/
void MUSART_VidSendChar(u8 Copy_u8Data)
{
     ea6:	df 93       	push	r29
     ea8:	cf 93       	push	r28
     eaa:	0f 92       	push	r0
     eac:	cd b7       	in	r28, 0x3d	; 61
     eae:	de b7       	in	r29, 0x3e	; 62
     eb0:	89 83       	std	Y+1, r24	; 0x01
	/*Wait until Register Empty Flag is set*/
	while(GET_BIT(UCSRA,5)==0);
     eb2:	eb e2       	ldi	r30, 0x2B	; 43
     eb4:	f0 e0       	ldi	r31, 0x00	; 0
     eb6:	80 81       	ld	r24, Z
     eb8:	82 95       	swap	r24
     eba:	86 95       	lsr	r24
     ebc:	87 70       	andi	r24, 0x07	; 7
     ebe:	88 2f       	mov	r24, r24
     ec0:	90 e0       	ldi	r25, 0x00	; 0
     ec2:	81 70       	andi	r24, 0x01	; 1
     ec4:	90 70       	andi	r25, 0x00	; 0
     ec6:	00 97       	sbiw	r24, 0x00	; 0
     ec8:	a1 f3       	breq	.-24     	; 0xeb2 <MUSART_VidSendChar+0xc>
	UDR=Copy_u8Data;
     eca:	ec e2       	ldi	r30, 0x2C	; 44
     ecc:	f0 e0       	ldi	r31, 0x00	; 0
     ece:	89 81       	ldd	r24, Y+1	; 0x01
     ed0:	80 83       	st	Z, r24
}
     ed2:	0f 90       	pop	r0
     ed4:	cf 91       	pop	r28
     ed6:	df 91       	pop	r29
     ed8:	08 95       	ret

00000eda <MUSART_u8ReceiveData>:
/*USART Receive Data*/
u8 MUSART_u8ReceiveData(void)
{
     eda:	df 93       	push	r29
     edc:	cf 93       	push	r28
     ede:	cd b7       	in	r28, 0x3d	; 61
     ee0:	de b7       	in	r29, 0x3e	; 62
	/*Wait until Receive Complete Flag is set*/
	//while(GET_BIT(UCSRA,7)==0);
	return UDR;
     ee2:	ec e2       	ldi	r30, 0x2C	; 44
     ee4:	f0 e0       	ldi	r31, 0x00	; 0
     ee6:	80 81       	ld	r24, Z
}
     ee8:	cf 91       	pop	r28
     eea:	df 91       	pop	r29
     eec:	08 95       	ret

00000eee <MUSART_VidSendString>:
void MUSART_VidSendString(u8 *Copy_u8Data)
{
     eee:	df 93       	push	r29
     ef0:	cf 93       	push	r28
     ef2:	00 d0       	rcall	.+0      	; 0xef4 <MUSART_VidSendString+0x6>
     ef4:	0f 92       	push	r0
     ef6:	cd b7       	in	r28, 0x3d	; 61
     ef8:	de b7       	in	r29, 0x3e	; 62
     efa:	9b 83       	std	Y+3, r25	; 0x03
     efc:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_CharCount=0;
     efe:	19 82       	std	Y+1, r1	; 0x01
     f00:	0e c0       	rjmp	.+28     	; 0xf1e <MUSART_VidSendString+0x30>
	while(Copy_u8Data[LOC_CharCount]!=NULL)
	{
		MUSART_VidSendChar(Copy_u8Data[LOC_CharCount]);
     f02:	89 81       	ldd	r24, Y+1	; 0x01
     f04:	28 2f       	mov	r18, r24
     f06:	30 e0       	ldi	r19, 0x00	; 0
     f08:	8a 81       	ldd	r24, Y+2	; 0x02
     f0a:	9b 81       	ldd	r25, Y+3	; 0x03
     f0c:	fc 01       	movw	r30, r24
     f0e:	e2 0f       	add	r30, r18
     f10:	f3 1f       	adc	r31, r19
     f12:	80 81       	ld	r24, Z
     f14:	0e 94 53 07 	call	0xea6	; 0xea6 <MUSART_VidSendChar>
		LOC_CharCount++;
     f18:	89 81       	ldd	r24, Y+1	; 0x01
     f1a:	8f 5f       	subi	r24, 0xFF	; 255
     f1c:	89 83       	std	Y+1, r24	; 0x01
	return UDR;
}
void MUSART_VidSendString(u8 *Copy_u8Data)
{
	u8 LOC_CharCount=0;
	while(Copy_u8Data[LOC_CharCount]!=NULL)
     f1e:	89 81       	ldd	r24, Y+1	; 0x01
     f20:	28 2f       	mov	r18, r24
     f22:	30 e0       	ldi	r19, 0x00	; 0
     f24:	8a 81       	ldd	r24, Y+2	; 0x02
     f26:	9b 81       	ldd	r25, Y+3	; 0x03
     f28:	fc 01       	movw	r30, r24
     f2a:	e2 0f       	add	r30, r18
     f2c:	f3 1f       	adc	r31, r19
     f2e:	80 81       	ld	r24, Z
     f30:	88 23       	and	r24, r24
     f32:	39 f7       	brne	.-50     	; 0xf02 <MUSART_VidSendString+0x14>
	{
		MUSART_VidSendChar(Copy_u8Data[LOC_CharCount]);
		LOC_CharCount++;
	}
}
     f34:	0f 90       	pop	r0
     f36:	0f 90       	pop	r0
     f38:	0f 90       	pop	r0
     f3a:	cf 91       	pop	r28
     f3c:	df 91       	pop	r29
     f3e:	08 95       	ret

00000f40 <MUSART_VidReceiveString>:
void MUSART_VidReceiveString(u8 *Copy_u8Data)
{
     f40:	0f 93       	push	r16
     f42:	1f 93       	push	r17
     f44:	df 93       	push	r29
     f46:	cf 93       	push	r28
     f48:	00 d0       	rcall	.+0      	; 0xf4a <MUSART_VidReceiveString+0xa>
     f4a:	0f 92       	push	r0
     f4c:	cd b7       	in	r28, 0x3d	; 61
     f4e:	de b7       	in	r29, 0x3e	; 62
     f50:	9b 83       	std	Y+3, r25	; 0x03
     f52:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_CharCount=0;
     f54:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		Copy_u8Data[LOC_CharCount]=MUSART_u8ReceiveData();
     f56:	89 81       	ldd	r24, Y+1	; 0x01
     f58:	28 2f       	mov	r18, r24
     f5a:	30 e0       	ldi	r19, 0x00	; 0
     f5c:	8a 81       	ldd	r24, Y+2	; 0x02
     f5e:	9b 81       	ldd	r25, Y+3	; 0x03
     f60:	8c 01       	movw	r16, r24
     f62:	02 0f       	add	r16, r18
     f64:	13 1f       	adc	r17, r19
     f66:	0e 94 6d 07 	call	0xeda	; 0xeda <MUSART_u8ReceiveData>
     f6a:	f8 01       	movw	r30, r16
     f6c:	80 83       	st	Z, r24
		if(Copy_u8Data[LOC_CharCount]=='\t')
     f6e:	89 81       	ldd	r24, Y+1	; 0x01
     f70:	28 2f       	mov	r18, r24
     f72:	30 e0       	ldi	r19, 0x00	; 0
     f74:	8a 81       	ldd	r24, Y+2	; 0x02
     f76:	9b 81       	ldd	r25, Y+3	; 0x03
     f78:	fc 01       	movw	r30, r24
     f7a:	e2 0f       	add	r30, r18
     f7c:	f3 1f       	adc	r31, r19
     f7e:	80 81       	ld	r24, Z
     f80:	89 30       	cpi	r24, 0x09	; 9
     f82:	21 f0       	breq	.+8      	; 0xf8c <MUSART_VidReceiveString+0x4c>
		{
			break;
		}
		LOC_CharCount++;
     f84:	89 81       	ldd	r24, Y+1	; 0x01
     f86:	8f 5f       	subi	r24, 0xFF	; 255
     f88:	89 83       	std	Y+1, r24	; 0x01
     f8a:	e5 cf       	rjmp	.-54     	; 0xf56 <MUSART_VidReceiveString+0x16>
	}

}
     f8c:	0f 90       	pop	r0
     f8e:	0f 90       	pop	r0
     f90:	0f 90       	pop	r0
     f92:	cf 91       	pop	r28
     f94:	df 91       	pop	r29
     f96:	1f 91       	pop	r17
     f98:	0f 91       	pop	r16
     f9a:	08 95       	ret

00000f9c <MUSART_VidUSART_Receive_Interrupt_Enable>:
void MUSART_VidUSART_Receive_Interrupt_Enable(void)
{
     f9c:	df 93       	push	r29
     f9e:	cf 93       	push	r28
     fa0:	cd b7       	in	r28, 0x3d	; 61
     fa2:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(UCSRB,7);
     fa4:	aa e2       	ldi	r26, 0x2A	; 42
     fa6:	b0 e0       	ldi	r27, 0x00	; 0
     fa8:	ea e2       	ldi	r30, 0x2A	; 42
     faa:	f0 e0       	ldi	r31, 0x00	; 0
     fac:	80 81       	ld	r24, Z
     fae:	80 68       	ori	r24, 0x80	; 128
     fb0:	8c 93       	st	X, r24
}
     fb2:	cf 91       	pop	r28
     fb4:	df 91       	pop	r29
     fb6:	08 95       	ret

00000fb8 <MUSART_VidSetCallBack>:
void MUSART_VidSetCallBack(void (*Copy_pFun)(void))
{
     fb8:	df 93       	push	r29
     fba:	cf 93       	push	r28
     fbc:	00 d0       	rcall	.+0      	; 0xfbe <MUSART_VidSetCallBack+0x6>
     fbe:	cd b7       	in	r28, 0x3d	; 61
     fc0:	de b7       	in	r29, 0x3e	; 62
     fc2:	9a 83       	std	Y+2, r25	; 0x02
     fc4:	89 83       	std	Y+1, r24	; 0x01
	MUSART_CallBack=Copy_pFun;
     fc6:	89 81       	ldd	r24, Y+1	; 0x01
     fc8:	9a 81       	ldd	r25, Y+2	; 0x02
     fca:	90 93 e2 07 	sts	0x07E2, r25
     fce:	80 93 e1 07 	sts	0x07E1, r24
}
     fd2:	0f 90       	pop	r0
     fd4:	0f 90       	pop	r0
     fd6:	cf 91       	pop	r28
     fd8:	df 91       	pop	r29
     fda:	08 95       	ret

00000fdc <__vector_13>:
void __vector_13(void)
{
     fdc:	1f 92       	push	r1
     fde:	0f 92       	push	r0
     fe0:	0f b6       	in	r0, 0x3f	; 63
     fe2:	0f 92       	push	r0
     fe4:	11 24       	eor	r1, r1
     fe6:	2f 93       	push	r18
     fe8:	3f 93       	push	r19
     fea:	4f 93       	push	r20
     fec:	5f 93       	push	r21
     fee:	6f 93       	push	r22
     ff0:	7f 93       	push	r23
     ff2:	8f 93       	push	r24
     ff4:	9f 93       	push	r25
     ff6:	af 93       	push	r26
     ff8:	bf 93       	push	r27
     ffa:	ef 93       	push	r30
     ffc:	ff 93       	push	r31
     ffe:	df 93       	push	r29
    1000:	cf 93       	push	r28
    1002:	cd b7       	in	r28, 0x3d	; 61
    1004:	de b7       	in	r29, 0x3e	; 62
	MUSART_CallBack();
    1006:	e0 91 e1 07 	lds	r30, 0x07E1
    100a:	f0 91 e2 07 	lds	r31, 0x07E2
    100e:	09 95       	icall
}
    1010:	cf 91       	pop	r28
    1012:	df 91       	pop	r29
    1014:	ff 91       	pop	r31
    1016:	ef 91       	pop	r30
    1018:	bf 91       	pop	r27
    101a:	af 91       	pop	r26
    101c:	9f 91       	pop	r25
    101e:	8f 91       	pop	r24
    1020:	7f 91       	pop	r23
    1022:	6f 91       	pop	r22
    1024:	5f 91       	pop	r21
    1026:	4f 91       	pop	r20
    1028:	3f 91       	pop	r19
    102a:	2f 91       	pop	r18
    102c:	0f 90       	pop	r0
    102e:	0f be       	out	0x3f, r0	; 63
    1030:	0f 90       	pop	r0
    1032:	1f 90       	pop	r1
    1034:	18 95       	reti

00001036 <MGIE_VidEnable>:

#include"MGIE_Private.h"

/*GIE Enable Function*/
void MGIE_VidEnable(void)
{
    1036:	df 93       	push	r29
    1038:	cf 93       	push	r28
    103a:	cd b7       	in	r28, 0x3d	; 61
    103c:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,7);
    103e:	af e5       	ldi	r26, 0x5F	; 95
    1040:	b0 e0       	ldi	r27, 0x00	; 0
    1042:	ef e5       	ldi	r30, 0x5F	; 95
    1044:	f0 e0       	ldi	r31, 0x00	; 0
    1046:	80 81       	ld	r24, Z
    1048:	80 68       	ori	r24, 0x80	; 128
    104a:	8c 93       	st	X, r24
}
    104c:	cf 91       	pop	r28
    104e:	df 91       	pop	r29
    1050:	08 95       	ret

00001052 <MGIE_VidDisable>:
/*GIE Disable Function*/
void MGIE_VidDisable(void)
{
    1052:	df 93       	push	r29
    1054:	cf 93       	push	r28
    1056:	cd b7       	in	r28, 0x3d	; 61
    1058:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,7);
    105a:	af e5       	ldi	r26, 0x5F	; 95
    105c:	b0 e0       	ldi	r27, 0x00	; 0
    105e:	ef e5       	ldi	r30, 0x5F	; 95
    1060:	f0 e0       	ldi	r31, 0x00	; 0
    1062:	80 81       	ld	r24, Z
    1064:	8f 77       	andi	r24, 0x7F	; 127
    1066:	8c 93       	st	X, r24
}
    1068:	cf 91       	pop	r28
    106a:	df 91       	pop	r29
    106c:	08 95       	ret

0000106e <MDIO_Error_State_SetPinDirection>:
#include"MDIO_Private.h"
#include"MDIO_Interface.h"

/*Set Pin Direction Function */
Error_State MDIO_Error_State_SetPinDirection(u8 Copy_u8PinNumber,u8  Copy_u8PortNumber,u8 Copy_u8PinDirection)
{
    106e:	df 93       	push	r29
    1070:	cf 93       	push	r28
    1072:	00 d0       	rcall	.+0      	; 0x1074 <MDIO_Error_State_SetPinDirection+0x6>
    1074:	00 d0       	rcall	.+0      	; 0x1076 <MDIO_Error_State_SetPinDirection+0x8>
    1076:	00 d0       	rcall	.+0      	; 0x1078 <MDIO_Error_State_SetPinDirection+0xa>
    1078:	cd b7       	in	r28, 0x3d	; 61
    107a:	de b7       	in	r29, 0x3e	; 62
    107c:	8a 83       	std	Y+2, r24	; 0x02
    107e:	6b 83       	std	Y+3, r22	; 0x03
    1080:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    1082:	81 e0       	ldi	r24, 0x01	; 1
    1084:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
    1086:	8a 81       	ldd	r24, Y+2	; 0x02
    1088:	88 30       	cpi	r24, 0x08	; 8
    108a:	08 f0       	brcs	.+2      	; 0x108e <MDIO_Error_State_SetPinDirection+0x20>
    108c:	e8 c0       	rjmp	.+464    	; 0x125e <MDIO_Error_State_SetPinDirection+0x1f0>
	{
		switch(Copy_u8PortNumber)
    108e:	8b 81       	ldd	r24, Y+3	; 0x03
    1090:	28 2f       	mov	r18, r24
    1092:	30 e0       	ldi	r19, 0x00	; 0
    1094:	3e 83       	std	Y+6, r19	; 0x06
    1096:	2d 83       	std	Y+5, r18	; 0x05
    1098:	8d 81       	ldd	r24, Y+5	; 0x05
    109a:	9e 81       	ldd	r25, Y+6	; 0x06
    109c:	81 30       	cpi	r24, 0x01	; 1
    109e:	91 05       	cpc	r25, r1
    10a0:	09 f4       	brne	.+2      	; 0x10a4 <MDIO_Error_State_SetPinDirection+0x36>
    10a2:	48 c0       	rjmp	.+144    	; 0x1134 <MDIO_Error_State_SetPinDirection+0xc6>
    10a4:	2d 81       	ldd	r18, Y+5	; 0x05
    10a6:	3e 81       	ldd	r19, Y+6	; 0x06
    10a8:	22 30       	cpi	r18, 0x02	; 2
    10aa:	31 05       	cpc	r19, r1
    10ac:	2c f4       	brge	.+10     	; 0x10b8 <MDIO_Error_State_SetPinDirection+0x4a>
    10ae:	8d 81       	ldd	r24, Y+5	; 0x05
    10b0:	9e 81       	ldd	r25, Y+6	; 0x06
    10b2:	00 97       	sbiw	r24, 0x00	; 0
    10b4:	71 f0       	breq	.+28     	; 0x10d2 <MDIO_Error_State_SetPinDirection+0x64>
    10b6:	d1 c0       	rjmp	.+418    	; 0x125a <MDIO_Error_State_SetPinDirection+0x1ec>
    10b8:	2d 81       	ldd	r18, Y+5	; 0x05
    10ba:	3e 81       	ldd	r19, Y+6	; 0x06
    10bc:	22 30       	cpi	r18, 0x02	; 2
    10be:	31 05       	cpc	r19, r1
    10c0:	09 f4       	brne	.+2      	; 0x10c4 <MDIO_Error_State_SetPinDirection+0x56>
    10c2:	69 c0       	rjmp	.+210    	; 0x1196 <MDIO_Error_State_SetPinDirection+0x128>
    10c4:	8d 81       	ldd	r24, Y+5	; 0x05
    10c6:	9e 81       	ldd	r25, Y+6	; 0x06
    10c8:	83 30       	cpi	r24, 0x03	; 3
    10ca:	91 05       	cpc	r25, r1
    10cc:	09 f4       	brne	.+2      	; 0x10d0 <MDIO_Error_State_SetPinDirection+0x62>
    10ce:	94 c0       	rjmp	.+296    	; 0x11f8 <MDIO_Error_State_SetPinDirection+0x18a>
    10d0:	c4 c0       	rjmp	.+392    	; 0x125a <MDIO_Error_State_SetPinDirection+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    10d2:	8c 81       	ldd	r24, Y+4	; 0x04
    10d4:	81 30       	cpi	r24, 0x01	; 1
    10d6:	a1 f4       	brne	.+40     	; 0x1100 <MDIO_Error_State_SetPinDirection+0x92>
			{
				SET_BIT(DDRA,Copy_u8PinNumber);
    10d8:	aa e3       	ldi	r26, 0x3A	; 58
    10da:	b0 e0       	ldi	r27, 0x00	; 0
    10dc:	ea e3       	ldi	r30, 0x3A	; 58
    10de:	f0 e0       	ldi	r31, 0x00	; 0
    10e0:	80 81       	ld	r24, Z
    10e2:	48 2f       	mov	r20, r24
    10e4:	8a 81       	ldd	r24, Y+2	; 0x02
    10e6:	28 2f       	mov	r18, r24
    10e8:	30 e0       	ldi	r19, 0x00	; 0
    10ea:	81 e0       	ldi	r24, 0x01	; 1
    10ec:	90 e0       	ldi	r25, 0x00	; 0
    10ee:	02 2e       	mov	r0, r18
    10f0:	02 c0       	rjmp	.+4      	; 0x10f6 <MDIO_Error_State_SetPinDirection+0x88>
    10f2:	88 0f       	add	r24, r24
    10f4:	99 1f       	adc	r25, r25
    10f6:	0a 94       	dec	r0
    10f8:	e2 f7       	brpl	.-8      	; 0x10f2 <MDIO_Error_State_SetPinDirection+0x84>
    10fa:	84 2b       	or	r24, r20
    10fc:	8c 93       	st	X, r24
    10fe:	b0 c0       	rjmp	.+352    	; 0x1260 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    1100:	8c 81       	ldd	r24, Y+4	; 0x04
    1102:	88 23       	and	r24, r24
    1104:	a9 f4       	brne	.+42     	; 0x1130 <MDIO_Error_State_SetPinDirection+0xc2>
			{
				CLR_BIT(DDRA,Copy_u8PinNumber);
    1106:	aa e3       	ldi	r26, 0x3A	; 58
    1108:	b0 e0       	ldi	r27, 0x00	; 0
    110a:	ea e3       	ldi	r30, 0x3A	; 58
    110c:	f0 e0       	ldi	r31, 0x00	; 0
    110e:	80 81       	ld	r24, Z
    1110:	48 2f       	mov	r20, r24
    1112:	8a 81       	ldd	r24, Y+2	; 0x02
    1114:	28 2f       	mov	r18, r24
    1116:	30 e0       	ldi	r19, 0x00	; 0
    1118:	81 e0       	ldi	r24, 0x01	; 1
    111a:	90 e0       	ldi	r25, 0x00	; 0
    111c:	02 2e       	mov	r0, r18
    111e:	02 c0       	rjmp	.+4      	; 0x1124 <MDIO_Error_State_SetPinDirection+0xb6>
    1120:	88 0f       	add	r24, r24
    1122:	99 1f       	adc	r25, r25
    1124:	0a 94       	dec	r0
    1126:	e2 f7       	brpl	.-8      	; 0x1120 <MDIO_Error_State_SetPinDirection+0xb2>
    1128:	80 95       	com	r24
    112a:	84 23       	and	r24, r20
    112c:	8c 93       	st	X, r24
    112e:	98 c0       	rjmp	.+304    	; 0x1260 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1130:	19 82       	std	Y+1, r1	; 0x01
    1132:	96 c0       	rjmp	.+300    	; 0x1260 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    1134:	8c 81       	ldd	r24, Y+4	; 0x04
    1136:	81 30       	cpi	r24, 0x01	; 1
    1138:	a1 f4       	brne	.+40     	; 0x1162 <MDIO_Error_State_SetPinDirection+0xf4>
			{
				SET_BIT(DDRB,Copy_u8PinNumber);
    113a:	a7 e3       	ldi	r26, 0x37	; 55
    113c:	b0 e0       	ldi	r27, 0x00	; 0
    113e:	e7 e3       	ldi	r30, 0x37	; 55
    1140:	f0 e0       	ldi	r31, 0x00	; 0
    1142:	80 81       	ld	r24, Z
    1144:	48 2f       	mov	r20, r24
    1146:	8a 81       	ldd	r24, Y+2	; 0x02
    1148:	28 2f       	mov	r18, r24
    114a:	30 e0       	ldi	r19, 0x00	; 0
    114c:	81 e0       	ldi	r24, 0x01	; 1
    114e:	90 e0       	ldi	r25, 0x00	; 0
    1150:	02 2e       	mov	r0, r18
    1152:	02 c0       	rjmp	.+4      	; 0x1158 <MDIO_Error_State_SetPinDirection+0xea>
    1154:	88 0f       	add	r24, r24
    1156:	99 1f       	adc	r25, r25
    1158:	0a 94       	dec	r0
    115a:	e2 f7       	brpl	.-8      	; 0x1154 <MDIO_Error_State_SetPinDirection+0xe6>
    115c:	84 2b       	or	r24, r20
    115e:	8c 93       	st	X, r24
    1160:	7f c0       	rjmp	.+254    	; 0x1260 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    1162:	8c 81       	ldd	r24, Y+4	; 0x04
    1164:	88 23       	and	r24, r24
    1166:	a9 f4       	brne	.+42     	; 0x1192 <MDIO_Error_State_SetPinDirection+0x124>
			{
				CLR_BIT(DDRB,Copy_u8PinNumber);
    1168:	a7 e3       	ldi	r26, 0x37	; 55
    116a:	b0 e0       	ldi	r27, 0x00	; 0
    116c:	e7 e3       	ldi	r30, 0x37	; 55
    116e:	f0 e0       	ldi	r31, 0x00	; 0
    1170:	80 81       	ld	r24, Z
    1172:	48 2f       	mov	r20, r24
    1174:	8a 81       	ldd	r24, Y+2	; 0x02
    1176:	28 2f       	mov	r18, r24
    1178:	30 e0       	ldi	r19, 0x00	; 0
    117a:	81 e0       	ldi	r24, 0x01	; 1
    117c:	90 e0       	ldi	r25, 0x00	; 0
    117e:	02 2e       	mov	r0, r18
    1180:	02 c0       	rjmp	.+4      	; 0x1186 <MDIO_Error_State_SetPinDirection+0x118>
    1182:	88 0f       	add	r24, r24
    1184:	99 1f       	adc	r25, r25
    1186:	0a 94       	dec	r0
    1188:	e2 f7       	brpl	.-8      	; 0x1182 <MDIO_Error_State_SetPinDirection+0x114>
    118a:	80 95       	com	r24
    118c:	84 23       	and	r24, r20
    118e:	8c 93       	st	X, r24
    1190:	67 c0       	rjmp	.+206    	; 0x1260 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1192:	19 82       	std	Y+1, r1	; 0x01
    1194:	65 c0       	rjmp	.+202    	; 0x1260 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    1196:	8c 81       	ldd	r24, Y+4	; 0x04
    1198:	81 30       	cpi	r24, 0x01	; 1
    119a:	a1 f4       	brne	.+40     	; 0x11c4 <MDIO_Error_State_SetPinDirection+0x156>
			{
				SET_BIT(DDRC,Copy_u8PinNumber);
    119c:	a4 e3       	ldi	r26, 0x34	; 52
    119e:	b0 e0       	ldi	r27, 0x00	; 0
    11a0:	e4 e3       	ldi	r30, 0x34	; 52
    11a2:	f0 e0       	ldi	r31, 0x00	; 0
    11a4:	80 81       	ld	r24, Z
    11a6:	48 2f       	mov	r20, r24
    11a8:	8a 81       	ldd	r24, Y+2	; 0x02
    11aa:	28 2f       	mov	r18, r24
    11ac:	30 e0       	ldi	r19, 0x00	; 0
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	02 2e       	mov	r0, r18
    11b4:	02 c0       	rjmp	.+4      	; 0x11ba <MDIO_Error_State_SetPinDirection+0x14c>
    11b6:	88 0f       	add	r24, r24
    11b8:	99 1f       	adc	r25, r25
    11ba:	0a 94       	dec	r0
    11bc:	e2 f7       	brpl	.-8      	; 0x11b6 <MDIO_Error_State_SetPinDirection+0x148>
    11be:	84 2b       	or	r24, r20
    11c0:	8c 93       	st	X, r24
    11c2:	4e c0       	rjmp	.+156    	; 0x1260 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    11c4:	8c 81       	ldd	r24, Y+4	; 0x04
    11c6:	88 23       	and	r24, r24
    11c8:	a9 f4       	brne	.+42     	; 0x11f4 <MDIO_Error_State_SetPinDirection+0x186>
			{
				CLR_BIT(DDRC,Copy_u8PinNumber);
    11ca:	a4 e3       	ldi	r26, 0x34	; 52
    11cc:	b0 e0       	ldi	r27, 0x00	; 0
    11ce:	e4 e3       	ldi	r30, 0x34	; 52
    11d0:	f0 e0       	ldi	r31, 0x00	; 0
    11d2:	80 81       	ld	r24, Z
    11d4:	48 2f       	mov	r20, r24
    11d6:	8a 81       	ldd	r24, Y+2	; 0x02
    11d8:	28 2f       	mov	r18, r24
    11da:	30 e0       	ldi	r19, 0x00	; 0
    11dc:	81 e0       	ldi	r24, 0x01	; 1
    11de:	90 e0       	ldi	r25, 0x00	; 0
    11e0:	02 2e       	mov	r0, r18
    11e2:	02 c0       	rjmp	.+4      	; 0x11e8 <MDIO_Error_State_SetPinDirection+0x17a>
    11e4:	88 0f       	add	r24, r24
    11e6:	99 1f       	adc	r25, r25
    11e8:	0a 94       	dec	r0
    11ea:	e2 f7       	brpl	.-8      	; 0x11e4 <MDIO_Error_State_SetPinDirection+0x176>
    11ec:	80 95       	com	r24
    11ee:	84 23       	and	r24, r20
    11f0:	8c 93       	st	X, r24
    11f2:	36 c0       	rjmp	.+108    	; 0x1260 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    11f4:	19 82       	std	Y+1, r1	; 0x01
    11f6:	34 c0       	rjmp	.+104    	; 0x1260 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    11f8:	8c 81       	ldd	r24, Y+4	; 0x04
    11fa:	81 30       	cpi	r24, 0x01	; 1
    11fc:	a1 f4       	brne	.+40     	; 0x1226 <MDIO_Error_State_SetPinDirection+0x1b8>
			{
				SET_BIT(DDRD,Copy_u8PinNumber);
    11fe:	a1 e3       	ldi	r26, 0x31	; 49
    1200:	b0 e0       	ldi	r27, 0x00	; 0
    1202:	e1 e3       	ldi	r30, 0x31	; 49
    1204:	f0 e0       	ldi	r31, 0x00	; 0
    1206:	80 81       	ld	r24, Z
    1208:	48 2f       	mov	r20, r24
    120a:	8a 81       	ldd	r24, Y+2	; 0x02
    120c:	28 2f       	mov	r18, r24
    120e:	30 e0       	ldi	r19, 0x00	; 0
    1210:	81 e0       	ldi	r24, 0x01	; 1
    1212:	90 e0       	ldi	r25, 0x00	; 0
    1214:	02 2e       	mov	r0, r18
    1216:	02 c0       	rjmp	.+4      	; 0x121c <MDIO_Error_State_SetPinDirection+0x1ae>
    1218:	88 0f       	add	r24, r24
    121a:	99 1f       	adc	r25, r25
    121c:	0a 94       	dec	r0
    121e:	e2 f7       	brpl	.-8      	; 0x1218 <MDIO_Error_State_SetPinDirection+0x1aa>
    1220:	84 2b       	or	r24, r20
    1222:	8c 93       	st	X, r24
    1224:	1d c0       	rjmp	.+58     	; 0x1260 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    1226:	8c 81       	ldd	r24, Y+4	; 0x04
    1228:	88 23       	and	r24, r24
    122a:	a9 f4       	brne	.+42     	; 0x1256 <MDIO_Error_State_SetPinDirection+0x1e8>
			{
				CLR_BIT(DDRD,Copy_u8PinNumber);
    122c:	a1 e3       	ldi	r26, 0x31	; 49
    122e:	b0 e0       	ldi	r27, 0x00	; 0
    1230:	e1 e3       	ldi	r30, 0x31	; 49
    1232:	f0 e0       	ldi	r31, 0x00	; 0
    1234:	80 81       	ld	r24, Z
    1236:	48 2f       	mov	r20, r24
    1238:	8a 81       	ldd	r24, Y+2	; 0x02
    123a:	28 2f       	mov	r18, r24
    123c:	30 e0       	ldi	r19, 0x00	; 0
    123e:	81 e0       	ldi	r24, 0x01	; 1
    1240:	90 e0       	ldi	r25, 0x00	; 0
    1242:	02 2e       	mov	r0, r18
    1244:	02 c0       	rjmp	.+4      	; 0x124a <MDIO_Error_State_SetPinDirection+0x1dc>
    1246:	88 0f       	add	r24, r24
    1248:	99 1f       	adc	r25, r25
    124a:	0a 94       	dec	r0
    124c:	e2 f7       	brpl	.-8      	; 0x1246 <MDIO_Error_State_SetPinDirection+0x1d8>
    124e:	80 95       	com	r24
    1250:	84 23       	and	r24, r20
    1252:	8c 93       	st	X, r24
    1254:	05 c0       	rjmp	.+10     	; 0x1260 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1256:	19 82       	std	Y+1, r1	; 0x01
    1258:	03 c0       	rjmp	.+6      	; 0x1260 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    125a:	19 82       	std	Y+1, r1	; 0x01
    125c:	01 c0       	rjmp	.+2      	; 0x1260 <MDIO_Error_State_SetPinDirection+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    125e:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    1260:	89 81       	ldd	r24, Y+1	; 0x01
}
    1262:	26 96       	adiw	r28, 0x06	; 6
    1264:	0f b6       	in	r0, 0x3f	; 63
    1266:	f8 94       	cli
    1268:	de bf       	out	0x3e, r29	; 62
    126a:	0f be       	out	0x3f, r0	; 63
    126c:	cd bf       	out	0x3d, r28	; 61
    126e:	cf 91       	pop	r28
    1270:	df 91       	pop	r29
    1272:	08 95       	ret

00001274 <MDIO_Error_State_SetPortDirection>:
/*Set Port Direction Function */
Error_State MDIO_Error_State_SetPortDirection(u8 Copy_u8PortNumber,u8 Copy_u8PortDirection)
{
    1274:	df 93       	push	r29
    1276:	cf 93       	push	r28
    1278:	00 d0       	rcall	.+0      	; 0x127a <MDIO_Error_State_SetPortDirection+0x6>
    127a:	00 d0       	rcall	.+0      	; 0x127c <MDIO_Error_State_SetPortDirection+0x8>
    127c:	0f 92       	push	r0
    127e:	cd b7       	in	r28, 0x3d	; 61
    1280:	de b7       	in	r29, 0x3e	; 62
    1282:	8a 83       	std	Y+2, r24	; 0x02
    1284:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
    1286:	81 e0       	ldi	r24, 0x01	; 1
    1288:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortDirection==PORT_OUTPUT)||(Copy_u8PortDirection==PORT_INPUT))
    128a:	8b 81       	ldd	r24, Y+3	; 0x03
    128c:	8f 3f       	cpi	r24, 0xFF	; 255
    128e:	19 f0       	breq	.+6      	; 0x1296 <MDIO_Error_State_SetPortDirection+0x22>
    1290:	8b 81       	ldd	r24, Y+3	; 0x03
    1292:	88 23       	and	r24, r24
    1294:	a9 f5       	brne	.+106    	; 0x1300 <MDIO_Error_State_SetPortDirection+0x8c>
	{
		switch(Copy_u8PortNumber)
    1296:	8a 81       	ldd	r24, Y+2	; 0x02
    1298:	28 2f       	mov	r18, r24
    129a:	30 e0       	ldi	r19, 0x00	; 0
    129c:	3d 83       	std	Y+5, r19	; 0x05
    129e:	2c 83       	std	Y+4, r18	; 0x04
    12a0:	8c 81       	ldd	r24, Y+4	; 0x04
    12a2:	9d 81       	ldd	r25, Y+5	; 0x05
    12a4:	81 30       	cpi	r24, 0x01	; 1
    12a6:	91 05       	cpc	r25, r1
    12a8:	d1 f0       	breq	.+52     	; 0x12de <MDIO_Error_State_SetPortDirection+0x6a>
    12aa:	2c 81       	ldd	r18, Y+4	; 0x04
    12ac:	3d 81       	ldd	r19, Y+5	; 0x05
    12ae:	22 30       	cpi	r18, 0x02	; 2
    12b0:	31 05       	cpc	r19, r1
    12b2:	2c f4       	brge	.+10     	; 0x12be <MDIO_Error_State_SetPortDirection+0x4a>
    12b4:	8c 81       	ldd	r24, Y+4	; 0x04
    12b6:	9d 81       	ldd	r25, Y+5	; 0x05
    12b8:	00 97       	sbiw	r24, 0x00	; 0
    12ba:	61 f0       	breq	.+24     	; 0x12d4 <MDIO_Error_State_SetPortDirection+0x60>
    12bc:	1f c0       	rjmp	.+62     	; 0x12fc <MDIO_Error_State_SetPortDirection+0x88>
    12be:	2c 81       	ldd	r18, Y+4	; 0x04
    12c0:	3d 81       	ldd	r19, Y+5	; 0x05
    12c2:	22 30       	cpi	r18, 0x02	; 2
    12c4:	31 05       	cpc	r19, r1
    12c6:	81 f0       	breq	.+32     	; 0x12e8 <MDIO_Error_State_SetPortDirection+0x74>
    12c8:	8c 81       	ldd	r24, Y+4	; 0x04
    12ca:	9d 81       	ldd	r25, Y+5	; 0x05
    12cc:	83 30       	cpi	r24, 0x03	; 3
    12ce:	91 05       	cpc	r25, r1
    12d0:	81 f0       	breq	.+32     	; 0x12f2 <MDIO_Error_State_SetPortDirection+0x7e>
    12d2:	14 c0       	rjmp	.+40     	; 0x12fc <MDIO_Error_State_SetPortDirection+0x88>
		{
		case MDIO_PORTA:
			DDRA=Copy_u8PortDirection;
    12d4:	ea e3       	ldi	r30, 0x3A	; 58
    12d6:	f0 e0       	ldi	r31, 0x00	; 0
    12d8:	8b 81       	ldd	r24, Y+3	; 0x03
    12da:	80 83       	st	Z, r24
    12dc:	12 c0       	rjmp	.+36     	; 0x1302 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTB:
			DDRB=Copy_u8PortDirection;
    12de:	e7 e3       	ldi	r30, 0x37	; 55
    12e0:	f0 e0       	ldi	r31, 0x00	; 0
    12e2:	8b 81       	ldd	r24, Y+3	; 0x03
    12e4:	80 83       	st	Z, r24
    12e6:	0d c0       	rjmp	.+26     	; 0x1302 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTC:
			DDRC=Copy_u8PortDirection;
    12e8:	e4 e3       	ldi	r30, 0x34	; 52
    12ea:	f0 e0       	ldi	r31, 0x00	; 0
    12ec:	8b 81       	ldd	r24, Y+3	; 0x03
    12ee:	80 83       	st	Z, r24
    12f0:	08 c0       	rjmp	.+16     	; 0x1302 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTD:
			DDRD=Copy_u8PortDirection;
    12f2:	e1 e3       	ldi	r30, 0x31	; 49
    12f4:	f0 e0       	ldi	r31, 0x00	; 0
    12f6:	8b 81       	ldd	r24, Y+3	; 0x03
    12f8:	80 83       	st	Z, r24
    12fa:	03 c0       	rjmp	.+6      	; 0x1302 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    12fc:	19 82       	std	Y+1, r1	; 0x01
    12fe:	01 c0       	rjmp	.+2      	; 0x1302 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    1300:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
    1302:	89 81       	ldd	r24, Y+1	; 0x01
}
    1304:	0f 90       	pop	r0
    1306:	0f 90       	pop	r0
    1308:	0f 90       	pop	r0
    130a:	0f 90       	pop	r0
    130c:	0f 90       	pop	r0
    130e:	cf 91       	pop	r28
    1310:	df 91       	pop	r29
    1312:	08 95       	ret

00001314 <MDIO_Error_State_SetPinValue>:

/*Set Pin Value Function */
Error_State MDIO_Error_State_SetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8 Copy_u8PinValue)
{
    1314:	df 93       	push	r29
    1316:	cf 93       	push	r28
    1318:	00 d0       	rcall	.+0      	; 0x131a <MDIO_Error_State_SetPinValue+0x6>
    131a:	00 d0       	rcall	.+0      	; 0x131c <MDIO_Error_State_SetPinValue+0x8>
    131c:	00 d0       	rcall	.+0      	; 0x131e <MDIO_Error_State_SetPinValue+0xa>
    131e:	cd b7       	in	r28, 0x3d	; 61
    1320:	de b7       	in	r29, 0x3e	; 62
    1322:	8a 83       	std	Y+2, r24	; 0x02
    1324:	6b 83       	std	Y+3, r22	; 0x03
    1326:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    1328:	81 e0       	ldi	r24, 0x01	; 1
    132a:	89 83       	std	Y+1, r24	; 0x01

	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
    132c:	8a 81       	ldd	r24, Y+2	; 0x02
    132e:	88 30       	cpi	r24, 0x08	; 8
    1330:	08 f0       	brcs	.+2      	; 0x1334 <MDIO_Error_State_SetPinValue+0x20>
    1332:	e8 c0       	rjmp	.+464    	; 0x1504 <MDIO_Error_State_SetPinValue+0x1f0>
	{
		switch(Copy_u8PortNumber)
    1334:	8b 81       	ldd	r24, Y+3	; 0x03
    1336:	28 2f       	mov	r18, r24
    1338:	30 e0       	ldi	r19, 0x00	; 0
    133a:	3e 83       	std	Y+6, r19	; 0x06
    133c:	2d 83       	std	Y+5, r18	; 0x05
    133e:	8d 81       	ldd	r24, Y+5	; 0x05
    1340:	9e 81       	ldd	r25, Y+6	; 0x06
    1342:	81 30       	cpi	r24, 0x01	; 1
    1344:	91 05       	cpc	r25, r1
    1346:	09 f4       	brne	.+2      	; 0x134a <MDIO_Error_State_SetPinValue+0x36>
    1348:	48 c0       	rjmp	.+144    	; 0x13da <MDIO_Error_State_SetPinValue+0xc6>
    134a:	2d 81       	ldd	r18, Y+5	; 0x05
    134c:	3e 81       	ldd	r19, Y+6	; 0x06
    134e:	22 30       	cpi	r18, 0x02	; 2
    1350:	31 05       	cpc	r19, r1
    1352:	2c f4       	brge	.+10     	; 0x135e <MDIO_Error_State_SetPinValue+0x4a>
    1354:	8d 81       	ldd	r24, Y+5	; 0x05
    1356:	9e 81       	ldd	r25, Y+6	; 0x06
    1358:	00 97       	sbiw	r24, 0x00	; 0
    135a:	71 f0       	breq	.+28     	; 0x1378 <MDIO_Error_State_SetPinValue+0x64>
    135c:	d1 c0       	rjmp	.+418    	; 0x1500 <MDIO_Error_State_SetPinValue+0x1ec>
    135e:	2d 81       	ldd	r18, Y+5	; 0x05
    1360:	3e 81       	ldd	r19, Y+6	; 0x06
    1362:	22 30       	cpi	r18, 0x02	; 2
    1364:	31 05       	cpc	r19, r1
    1366:	09 f4       	brne	.+2      	; 0x136a <MDIO_Error_State_SetPinValue+0x56>
    1368:	69 c0       	rjmp	.+210    	; 0x143c <MDIO_Error_State_SetPinValue+0x128>
    136a:	8d 81       	ldd	r24, Y+5	; 0x05
    136c:	9e 81       	ldd	r25, Y+6	; 0x06
    136e:	83 30       	cpi	r24, 0x03	; 3
    1370:	91 05       	cpc	r25, r1
    1372:	09 f4       	brne	.+2      	; 0x1376 <MDIO_Error_State_SetPinValue+0x62>
    1374:	94 c0       	rjmp	.+296    	; 0x149e <MDIO_Error_State_SetPinValue+0x18a>
    1376:	c4 c0       	rjmp	.+392    	; 0x1500 <MDIO_Error_State_SetPinValue+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinValue==PIN_HIGH)
    1378:	8c 81       	ldd	r24, Y+4	; 0x04
    137a:	81 30       	cpi	r24, 0x01	; 1
    137c:	a1 f4       	brne	.+40     	; 0x13a6 <MDIO_Error_State_SetPinValue+0x92>
			{
				SET_BIT(PORTA,Copy_u8PinNumber);
    137e:	ab e3       	ldi	r26, 0x3B	; 59
    1380:	b0 e0       	ldi	r27, 0x00	; 0
    1382:	eb e3       	ldi	r30, 0x3B	; 59
    1384:	f0 e0       	ldi	r31, 0x00	; 0
    1386:	80 81       	ld	r24, Z
    1388:	48 2f       	mov	r20, r24
    138a:	8a 81       	ldd	r24, Y+2	; 0x02
    138c:	28 2f       	mov	r18, r24
    138e:	30 e0       	ldi	r19, 0x00	; 0
    1390:	81 e0       	ldi	r24, 0x01	; 1
    1392:	90 e0       	ldi	r25, 0x00	; 0
    1394:	02 2e       	mov	r0, r18
    1396:	02 c0       	rjmp	.+4      	; 0x139c <MDIO_Error_State_SetPinValue+0x88>
    1398:	88 0f       	add	r24, r24
    139a:	99 1f       	adc	r25, r25
    139c:	0a 94       	dec	r0
    139e:	e2 f7       	brpl	.-8      	; 0x1398 <MDIO_Error_State_SetPinValue+0x84>
    13a0:	84 2b       	or	r24, r20
    13a2:	8c 93       	st	X, r24
    13a4:	b0 c0       	rjmp	.+352    	; 0x1506 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    13a6:	8c 81       	ldd	r24, Y+4	; 0x04
    13a8:	88 23       	and	r24, r24
    13aa:	a9 f4       	brne	.+42     	; 0x13d6 <MDIO_Error_State_SetPinValue+0xc2>
			{
				CLR_BIT(PORTA,Copy_u8PinNumber);
    13ac:	ab e3       	ldi	r26, 0x3B	; 59
    13ae:	b0 e0       	ldi	r27, 0x00	; 0
    13b0:	eb e3       	ldi	r30, 0x3B	; 59
    13b2:	f0 e0       	ldi	r31, 0x00	; 0
    13b4:	80 81       	ld	r24, Z
    13b6:	48 2f       	mov	r20, r24
    13b8:	8a 81       	ldd	r24, Y+2	; 0x02
    13ba:	28 2f       	mov	r18, r24
    13bc:	30 e0       	ldi	r19, 0x00	; 0
    13be:	81 e0       	ldi	r24, 0x01	; 1
    13c0:	90 e0       	ldi	r25, 0x00	; 0
    13c2:	02 2e       	mov	r0, r18
    13c4:	02 c0       	rjmp	.+4      	; 0x13ca <MDIO_Error_State_SetPinValue+0xb6>
    13c6:	88 0f       	add	r24, r24
    13c8:	99 1f       	adc	r25, r25
    13ca:	0a 94       	dec	r0
    13cc:	e2 f7       	brpl	.-8      	; 0x13c6 <MDIO_Error_State_SetPinValue+0xb2>
    13ce:	80 95       	com	r24
    13d0:	84 23       	and	r24, r20
    13d2:	8c 93       	st	X, r24
    13d4:	98 c0       	rjmp	.+304    	; 0x1506 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    13d6:	19 82       	std	Y+1, r1	; 0x01
    13d8:	96 c0       	rjmp	.+300    	; 0x1506 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinValue==PIN_HIGH)
    13da:	8c 81       	ldd	r24, Y+4	; 0x04
    13dc:	81 30       	cpi	r24, 0x01	; 1
    13de:	a1 f4       	brne	.+40     	; 0x1408 <MDIO_Error_State_SetPinValue+0xf4>
			{
				SET_BIT(PORTB,Copy_u8PinNumber);
    13e0:	a8 e3       	ldi	r26, 0x38	; 56
    13e2:	b0 e0       	ldi	r27, 0x00	; 0
    13e4:	e8 e3       	ldi	r30, 0x38	; 56
    13e6:	f0 e0       	ldi	r31, 0x00	; 0
    13e8:	80 81       	ld	r24, Z
    13ea:	48 2f       	mov	r20, r24
    13ec:	8a 81       	ldd	r24, Y+2	; 0x02
    13ee:	28 2f       	mov	r18, r24
    13f0:	30 e0       	ldi	r19, 0x00	; 0
    13f2:	81 e0       	ldi	r24, 0x01	; 1
    13f4:	90 e0       	ldi	r25, 0x00	; 0
    13f6:	02 2e       	mov	r0, r18
    13f8:	02 c0       	rjmp	.+4      	; 0x13fe <MDIO_Error_State_SetPinValue+0xea>
    13fa:	88 0f       	add	r24, r24
    13fc:	99 1f       	adc	r25, r25
    13fe:	0a 94       	dec	r0
    1400:	e2 f7       	brpl	.-8      	; 0x13fa <MDIO_Error_State_SetPinValue+0xe6>
    1402:	84 2b       	or	r24, r20
    1404:	8c 93       	st	X, r24
    1406:	7f c0       	rjmp	.+254    	; 0x1506 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    1408:	8c 81       	ldd	r24, Y+4	; 0x04
    140a:	88 23       	and	r24, r24
    140c:	a9 f4       	brne	.+42     	; 0x1438 <MDIO_Error_State_SetPinValue+0x124>
			{
				CLR_BIT(PORTB,Copy_u8PinNumber);
    140e:	a8 e3       	ldi	r26, 0x38	; 56
    1410:	b0 e0       	ldi	r27, 0x00	; 0
    1412:	e8 e3       	ldi	r30, 0x38	; 56
    1414:	f0 e0       	ldi	r31, 0x00	; 0
    1416:	80 81       	ld	r24, Z
    1418:	48 2f       	mov	r20, r24
    141a:	8a 81       	ldd	r24, Y+2	; 0x02
    141c:	28 2f       	mov	r18, r24
    141e:	30 e0       	ldi	r19, 0x00	; 0
    1420:	81 e0       	ldi	r24, 0x01	; 1
    1422:	90 e0       	ldi	r25, 0x00	; 0
    1424:	02 2e       	mov	r0, r18
    1426:	02 c0       	rjmp	.+4      	; 0x142c <MDIO_Error_State_SetPinValue+0x118>
    1428:	88 0f       	add	r24, r24
    142a:	99 1f       	adc	r25, r25
    142c:	0a 94       	dec	r0
    142e:	e2 f7       	brpl	.-8      	; 0x1428 <MDIO_Error_State_SetPinValue+0x114>
    1430:	80 95       	com	r24
    1432:	84 23       	and	r24, r20
    1434:	8c 93       	st	X, r24
    1436:	67 c0       	rjmp	.+206    	; 0x1506 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1438:	19 82       	std	Y+1, r1	; 0x01
    143a:	65 c0       	rjmp	.+202    	; 0x1506 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinValue==PIN_HIGH)
    143c:	8c 81       	ldd	r24, Y+4	; 0x04
    143e:	81 30       	cpi	r24, 0x01	; 1
    1440:	a1 f4       	brne	.+40     	; 0x146a <MDIO_Error_State_SetPinValue+0x156>
			{
				SET_BIT(PORTC,Copy_u8PinNumber);
    1442:	a5 e3       	ldi	r26, 0x35	; 53
    1444:	b0 e0       	ldi	r27, 0x00	; 0
    1446:	e5 e3       	ldi	r30, 0x35	; 53
    1448:	f0 e0       	ldi	r31, 0x00	; 0
    144a:	80 81       	ld	r24, Z
    144c:	48 2f       	mov	r20, r24
    144e:	8a 81       	ldd	r24, Y+2	; 0x02
    1450:	28 2f       	mov	r18, r24
    1452:	30 e0       	ldi	r19, 0x00	; 0
    1454:	81 e0       	ldi	r24, 0x01	; 1
    1456:	90 e0       	ldi	r25, 0x00	; 0
    1458:	02 2e       	mov	r0, r18
    145a:	02 c0       	rjmp	.+4      	; 0x1460 <MDIO_Error_State_SetPinValue+0x14c>
    145c:	88 0f       	add	r24, r24
    145e:	99 1f       	adc	r25, r25
    1460:	0a 94       	dec	r0
    1462:	e2 f7       	brpl	.-8      	; 0x145c <MDIO_Error_State_SetPinValue+0x148>
    1464:	84 2b       	or	r24, r20
    1466:	8c 93       	st	X, r24
    1468:	4e c0       	rjmp	.+156    	; 0x1506 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    146a:	8c 81       	ldd	r24, Y+4	; 0x04
    146c:	88 23       	and	r24, r24
    146e:	a9 f4       	brne	.+42     	; 0x149a <MDIO_Error_State_SetPinValue+0x186>
			{
				CLR_BIT(PORTC,Copy_u8PinNumber);
    1470:	a5 e3       	ldi	r26, 0x35	; 53
    1472:	b0 e0       	ldi	r27, 0x00	; 0
    1474:	e5 e3       	ldi	r30, 0x35	; 53
    1476:	f0 e0       	ldi	r31, 0x00	; 0
    1478:	80 81       	ld	r24, Z
    147a:	48 2f       	mov	r20, r24
    147c:	8a 81       	ldd	r24, Y+2	; 0x02
    147e:	28 2f       	mov	r18, r24
    1480:	30 e0       	ldi	r19, 0x00	; 0
    1482:	81 e0       	ldi	r24, 0x01	; 1
    1484:	90 e0       	ldi	r25, 0x00	; 0
    1486:	02 2e       	mov	r0, r18
    1488:	02 c0       	rjmp	.+4      	; 0x148e <MDIO_Error_State_SetPinValue+0x17a>
    148a:	88 0f       	add	r24, r24
    148c:	99 1f       	adc	r25, r25
    148e:	0a 94       	dec	r0
    1490:	e2 f7       	brpl	.-8      	; 0x148a <MDIO_Error_State_SetPinValue+0x176>
    1492:	80 95       	com	r24
    1494:	84 23       	and	r24, r20
    1496:	8c 93       	st	X, r24
    1498:	36 c0       	rjmp	.+108    	; 0x1506 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    149a:	19 82       	std	Y+1, r1	; 0x01
    149c:	34 c0       	rjmp	.+104    	; 0x1506 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinValue==PIN_HIGH)
    149e:	8c 81       	ldd	r24, Y+4	; 0x04
    14a0:	81 30       	cpi	r24, 0x01	; 1
    14a2:	a1 f4       	brne	.+40     	; 0x14cc <MDIO_Error_State_SetPinValue+0x1b8>
			{
				SET_BIT(PORTD,Copy_u8PinNumber);
    14a4:	a2 e3       	ldi	r26, 0x32	; 50
    14a6:	b0 e0       	ldi	r27, 0x00	; 0
    14a8:	e2 e3       	ldi	r30, 0x32	; 50
    14aa:	f0 e0       	ldi	r31, 0x00	; 0
    14ac:	80 81       	ld	r24, Z
    14ae:	48 2f       	mov	r20, r24
    14b0:	8a 81       	ldd	r24, Y+2	; 0x02
    14b2:	28 2f       	mov	r18, r24
    14b4:	30 e0       	ldi	r19, 0x00	; 0
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	90 e0       	ldi	r25, 0x00	; 0
    14ba:	02 2e       	mov	r0, r18
    14bc:	02 c0       	rjmp	.+4      	; 0x14c2 <MDIO_Error_State_SetPinValue+0x1ae>
    14be:	88 0f       	add	r24, r24
    14c0:	99 1f       	adc	r25, r25
    14c2:	0a 94       	dec	r0
    14c4:	e2 f7       	brpl	.-8      	; 0x14be <MDIO_Error_State_SetPinValue+0x1aa>
    14c6:	84 2b       	or	r24, r20
    14c8:	8c 93       	st	X, r24
    14ca:	1d c0       	rjmp	.+58     	; 0x1506 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    14cc:	8c 81       	ldd	r24, Y+4	; 0x04
    14ce:	88 23       	and	r24, r24
    14d0:	a9 f4       	brne	.+42     	; 0x14fc <MDIO_Error_State_SetPinValue+0x1e8>
			{
				CLR_BIT(PORTD,Copy_u8PinNumber);
    14d2:	a2 e3       	ldi	r26, 0x32	; 50
    14d4:	b0 e0       	ldi	r27, 0x00	; 0
    14d6:	e2 e3       	ldi	r30, 0x32	; 50
    14d8:	f0 e0       	ldi	r31, 0x00	; 0
    14da:	80 81       	ld	r24, Z
    14dc:	48 2f       	mov	r20, r24
    14de:	8a 81       	ldd	r24, Y+2	; 0x02
    14e0:	28 2f       	mov	r18, r24
    14e2:	30 e0       	ldi	r19, 0x00	; 0
    14e4:	81 e0       	ldi	r24, 0x01	; 1
    14e6:	90 e0       	ldi	r25, 0x00	; 0
    14e8:	02 2e       	mov	r0, r18
    14ea:	02 c0       	rjmp	.+4      	; 0x14f0 <MDIO_Error_State_SetPinValue+0x1dc>
    14ec:	88 0f       	add	r24, r24
    14ee:	99 1f       	adc	r25, r25
    14f0:	0a 94       	dec	r0
    14f2:	e2 f7       	brpl	.-8      	; 0x14ec <MDIO_Error_State_SetPinValue+0x1d8>
    14f4:	80 95       	com	r24
    14f6:	84 23       	and	r24, r20
    14f8:	8c 93       	st	X, r24
    14fa:	05 c0       	rjmp	.+10     	; 0x1506 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    14fc:	19 82       	std	Y+1, r1	; 0x01
    14fe:	03 c0       	rjmp	.+6      	; 0x1506 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    1500:	19 82       	std	Y+1, r1	; 0x01
    1502:	01 c0       	rjmp	.+2      	; 0x1506 <MDIO_Error_State_SetPinValue+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    1504:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    1506:	89 81       	ldd	r24, Y+1	; 0x01
}
    1508:	26 96       	adiw	r28, 0x06	; 6
    150a:	0f b6       	in	r0, 0x3f	; 63
    150c:	f8 94       	cli
    150e:	de bf       	out	0x3e, r29	; 62
    1510:	0f be       	out	0x3f, r0	; 63
    1512:	cd bf       	out	0x3d, r28	; 61
    1514:	cf 91       	pop	r28
    1516:	df 91       	pop	r29
    1518:	08 95       	ret

0000151a <MDIO_Error_State_SetPortValue>:

/*Set Port Value Function */
Error_State MDIO_Error_State_SetPortValue(u8 Copy_u8PortNumber,u8 Copy_u8PortValue)
{
    151a:	df 93       	push	r29
    151c:	cf 93       	push	r28
    151e:	00 d0       	rcall	.+0      	; 0x1520 <MDIO_Error_State_SetPortValue+0x6>
    1520:	00 d0       	rcall	.+0      	; 0x1522 <MDIO_Error_State_SetPortValue+0x8>
    1522:	0f 92       	push	r0
    1524:	cd b7       	in	r28, 0x3d	; 61
    1526:	de b7       	in	r29, 0x3e	; 62
    1528:	8a 83       	std	Y+2, r24	; 0x02
    152a:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
    152c:	81 e0       	ldi	r24, 0x01	; 1
    152e:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8PortNumber)
    1530:	8a 81       	ldd	r24, Y+2	; 0x02
    1532:	28 2f       	mov	r18, r24
    1534:	30 e0       	ldi	r19, 0x00	; 0
    1536:	3d 83       	std	Y+5, r19	; 0x05
    1538:	2c 83       	std	Y+4, r18	; 0x04
    153a:	8c 81       	ldd	r24, Y+4	; 0x04
    153c:	9d 81       	ldd	r25, Y+5	; 0x05
    153e:	81 30       	cpi	r24, 0x01	; 1
    1540:	91 05       	cpc	r25, r1
    1542:	d1 f0       	breq	.+52     	; 0x1578 <MDIO_Error_State_SetPortValue+0x5e>
    1544:	2c 81       	ldd	r18, Y+4	; 0x04
    1546:	3d 81       	ldd	r19, Y+5	; 0x05
    1548:	22 30       	cpi	r18, 0x02	; 2
    154a:	31 05       	cpc	r19, r1
    154c:	2c f4       	brge	.+10     	; 0x1558 <MDIO_Error_State_SetPortValue+0x3e>
    154e:	8c 81       	ldd	r24, Y+4	; 0x04
    1550:	9d 81       	ldd	r25, Y+5	; 0x05
    1552:	00 97       	sbiw	r24, 0x00	; 0
    1554:	61 f0       	breq	.+24     	; 0x156e <MDIO_Error_State_SetPortValue+0x54>
    1556:	1f c0       	rjmp	.+62     	; 0x1596 <MDIO_Error_State_SetPortValue+0x7c>
    1558:	2c 81       	ldd	r18, Y+4	; 0x04
    155a:	3d 81       	ldd	r19, Y+5	; 0x05
    155c:	22 30       	cpi	r18, 0x02	; 2
    155e:	31 05       	cpc	r19, r1
    1560:	81 f0       	breq	.+32     	; 0x1582 <MDIO_Error_State_SetPortValue+0x68>
    1562:	8c 81       	ldd	r24, Y+4	; 0x04
    1564:	9d 81       	ldd	r25, Y+5	; 0x05
    1566:	83 30       	cpi	r24, 0x03	; 3
    1568:	91 05       	cpc	r25, r1
    156a:	81 f0       	breq	.+32     	; 0x158c <MDIO_Error_State_SetPortValue+0x72>
    156c:	14 c0       	rjmp	.+40     	; 0x1596 <MDIO_Error_State_SetPortValue+0x7c>
	{
	case MDIO_PORTA:
		PORTA=Copy_u8PortValue;
    156e:	eb e3       	ldi	r30, 0x3B	; 59
    1570:	f0 e0       	ldi	r31, 0x00	; 0
    1572:	8b 81       	ldd	r24, Y+3	; 0x03
    1574:	80 83       	st	Z, r24
    1576:	10 c0       	rjmp	.+32     	; 0x1598 <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTB:
		PORTB=Copy_u8PortValue;
    1578:	e8 e3       	ldi	r30, 0x38	; 56
    157a:	f0 e0       	ldi	r31, 0x00	; 0
    157c:	8b 81       	ldd	r24, Y+3	; 0x03
    157e:	80 83       	st	Z, r24
    1580:	0b c0       	rjmp	.+22     	; 0x1598 <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTC:
		PORTC=Copy_u8PortValue;
    1582:	e5 e3       	ldi	r30, 0x35	; 53
    1584:	f0 e0       	ldi	r31, 0x00	; 0
    1586:	8b 81       	ldd	r24, Y+3	; 0x03
    1588:	80 83       	st	Z, r24
    158a:	06 c0       	rjmp	.+12     	; 0x1598 <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	case MDIO_PORTD:
		PORTD=Copy_u8PortValue;
    158c:	e2 e3       	ldi	r30, 0x32	; 50
    158e:	f0 e0       	ldi	r31, 0x00	; 0
    1590:	8b 81       	ldd	r24, Y+3	; 0x03
    1592:	80 83       	st	Z, r24
    1594:	01 c0       	rjmp	.+2      	; 0x1598 <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	default:
		LOC_Error_State_ReturnState=NOK;
    1596:	19 82       	std	Y+1, r1	; 0x01
		break;
	}
	return LOC_Error_State_ReturnState;
    1598:	89 81       	ldd	r24, Y+1	; 0x01
}
    159a:	0f 90       	pop	r0
    159c:	0f 90       	pop	r0
    159e:	0f 90       	pop	r0
    15a0:	0f 90       	pop	r0
    15a2:	0f 90       	pop	r0
    15a4:	cf 91       	pop	r28
    15a6:	df 91       	pop	r29
    15a8:	08 95       	ret

000015aa <MDIO_Error_State_GetPinValue>:

/*Get Pin Value Function */
Error_State MDIO_Error_State_GetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8* P_u8PinValue)
{
    15aa:	df 93       	push	r29
    15ac:	cf 93       	push	r28
    15ae:	cd b7       	in	r28, 0x3d	; 61
    15b0:	de b7       	in	r29, 0x3e	; 62
    15b2:	27 97       	sbiw	r28, 0x07	; 7
    15b4:	0f b6       	in	r0, 0x3f	; 63
    15b6:	f8 94       	cli
    15b8:	de bf       	out	0x3e, r29	; 62
    15ba:	0f be       	out	0x3f, r0	; 63
    15bc:	cd bf       	out	0x3d, r28	; 61
    15be:	8a 83       	std	Y+2, r24	; 0x02
    15c0:	6b 83       	std	Y+3, r22	; 0x03
    15c2:	5d 83       	std	Y+5, r21	; 0x05
    15c4:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    15c6:	81 e0       	ldi	r24, 0x01	; 1
    15c8:	89 83       	std	Y+1, r24	; 0x01

	if(((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))&&(P_u8PinValue!=NULL_POINTER))
    15ca:	8a 81       	ldd	r24, Y+2	; 0x02
    15cc:	88 30       	cpi	r24, 0x08	; 8
    15ce:	08 f0       	brcs	.+2      	; 0x15d2 <MDIO_Error_State_GetPinValue+0x28>
    15d0:	79 c0       	rjmp	.+242    	; 0x16c4 <MDIO_Error_State_GetPinValue+0x11a>
    15d2:	8c 81       	ldd	r24, Y+4	; 0x04
    15d4:	9d 81       	ldd	r25, Y+5	; 0x05
    15d6:	81 30       	cpi	r24, 0x01	; 1
    15d8:	91 05       	cpc	r25, r1
    15da:	09 f4       	brne	.+2      	; 0x15de <MDIO_Error_State_GetPinValue+0x34>
    15dc:	73 c0       	rjmp	.+230    	; 0x16c4 <MDIO_Error_State_GetPinValue+0x11a>
	{
		switch(Copy_u8PortNumber)
    15de:	8b 81       	ldd	r24, Y+3	; 0x03
    15e0:	28 2f       	mov	r18, r24
    15e2:	30 e0       	ldi	r19, 0x00	; 0
    15e4:	3f 83       	std	Y+7, r19	; 0x07
    15e6:	2e 83       	std	Y+6, r18	; 0x06
    15e8:	4e 81       	ldd	r20, Y+6	; 0x06
    15ea:	5f 81       	ldd	r21, Y+7	; 0x07
    15ec:	41 30       	cpi	r20, 0x01	; 1
    15ee:	51 05       	cpc	r21, r1
    15f0:	59 f1       	breq	.+86     	; 0x1648 <MDIO_Error_State_GetPinValue+0x9e>
    15f2:	8e 81       	ldd	r24, Y+6	; 0x06
    15f4:	9f 81       	ldd	r25, Y+7	; 0x07
    15f6:	82 30       	cpi	r24, 0x02	; 2
    15f8:	91 05       	cpc	r25, r1
    15fa:	34 f4       	brge	.+12     	; 0x1608 <MDIO_Error_State_GetPinValue+0x5e>
    15fc:	2e 81       	ldd	r18, Y+6	; 0x06
    15fe:	3f 81       	ldd	r19, Y+7	; 0x07
    1600:	21 15       	cp	r18, r1
    1602:	31 05       	cpc	r19, r1
    1604:	69 f0       	breq	.+26     	; 0x1620 <MDIO_Error_State_GetPinValue+0x76>
    1606:	5c c0       	rjmp	.+184    	; 0x16c0 <MDIO_Error_State_GetPinValue+0x116>
    1608:	4e 81       	ldd	r20, Y+6	; 0x06
    160a:	5f 81       	ldd	r21, Y+7	; 0x07
    160c:	42 30       	cpi	r20, 0x02	; 2
    160e:	51 05       	cpc	r21, r1
    1610:	79 f1       	breq	.+94     	; 0x1670 <MDIO_Error_State_GetPinValue+0xc6>
    1612:	8e 81       	ldd	r24, Y+6	; 0x06
    1614:	9f 81       	ldd	r25, Y+7	; 0x07
    1616:	83 30       	cpi	r24, 0x03	; 3
    1618:	91 05       	cpc	r25, r1
    161a:	09 f4       	brne	.+2      	; 0x161e <MDIO_Error_State_GetPinValue+0x74>
    161c:	3d c0       	rjmp	.+122    	; 0x1698 <MDIO_Error_State_GetPinValue+0xee>
    161e:	50 c0       	rjmp	.+160    	; 0x16c0 <MDIO_Error_State_GetPinValue+0x116>
		{
		case MDIO_PORTA:
			*P_u8PinValue=GET_BIT(PINA,Copy_u8PinNumber);
    1620:	e9 e3       	ldi	r30, 0x39	; 57
    1622:	f0 e0       	ldi	r31, 0x00	; 0
    1624:	80 81       	ld	r24, Z
    1626:	28 2f       	mov	r18, r24
    1628:	30 e0       	ldi	r19, 0x00	; 0
    162a:	8a 81       	ldd	r24, Y+2	; 0x02
    162c:	88 2f       	mov	r24, r24
    162e:	90 e0       	ldi	r25, 0x00	; 0
    1630:	a9 01       	movw	r20, r18
    1632:	02 c0       	rjmp	.+4      	; 0x1638 <MDIO_Error_State_GetPinValue+0x8e>
    1634:	55 95       	asr	r21
    1636:	47 95       	ror	r20
    1638:	8a 95       	dec	r24
    163a:	e2 f7       	brpl	.-8      	; 0x1634 <MDIO_Error_State_GetPinValue+0x8a>
    163c:	ca 01       	movw	r24, r20
    163e:	81 70       	andi	r24, 0x01	; 1
    1640:	ec 81       	ldd	r30, Y+4	; 0x04
    1642:	fd 81       	ldd	r31, Y+5	; 0x05
    1644:	80 83       	st	Z, r24
    1646:	3f c0       	rjmp	.+126    	; 0x16c6 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTB:
			*P_u8PinValue=GET_BIT(PINB,Copy_u8PinNumber);
    1648:	e6 e3       	ldi	r30, 0x36	; 54
    164a:	f0 e0       	ldi	r31, 0x00	; 0
    164c:	80 81       	ld	r24, Z
    164e:	28 2f       	mov	r18, r24
    1650:	30 e0       	ldi	r19, 0x00	; 0
    1652:	8a 81       	ldd	r24, Y+2	; 0x02
    1654:	88 2f       	mov	r24, r24
    1656:	90 e0       	ldi	r25, 0x00	; 0
    1658:	a9 01       	movw	r20, r18
    165a:	02 c0       	rjmp	.+4      	; 0x1660 <MDIO_Error_State_GetPinValue+0xb6>
    165c:	55 95       	asr	r21
    165e:	47 95       	ror	r20
    1660:	8a 95       	dec	r24
    1662:	e2 f7       	brpl	.-8      	; 0x165c <MDIO_Error_State_GetPinValue+0xb2>
    1664:	ca 01       	movw	r24, r20
    1666:	81 70       	andi	r24, 0x01	; 1
    1668:	ec 81       	ldd	r30, Y+4	; 0x04
    166a:	fd 81       	ldd	r31, Y+5	; 0x05
    166c:	80 83       	st	Z, r24
    166e:	2b c0       	rjmp	.+86     	; 0x16c6 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTC:
			*P_u8PinValue=GET_BIT(PINC,Copy_u8PinNumber);
    1670:	e3 e3       	ldi	r30, 0x33	; 51
    1672:	f0 e0       	ldi	r31, 0x00	; 0
    1674:	80 81       	ld	r24, Z
    1676:	28 2f       	mov	r18, r24
    1678:	30 e0       	ldi	r19, 0x00	; 0
    167a:	8a 81       	ldd	r24, Y+2	; 0x02
    167c:	88 2f       	mov	r24, r24
    167e:	90 e0       	ldi	r25, 0x00	; 0
    1680:	a9 01       	movw	r20, r18
    1682:	02 c0       	rjmp	.+4      	; 0x1688 <MDIO_Error_State_GetPinValue+0xde>
    1684:	55 95       	asr	r21
    1686:	47 95       	ror	r20
    1688:	8a 95       	dec	r24
    168a:	e2 f7       	brpl	.-8      	; 0x1684 <MDIO_Error_State_GetPinValue+0xda>
    168c:	ca 01       	movw	r24, r20
    168e:	81 70       	andi	r24, 0x01	; 1
    1690:	ec 81       	ldd	r30, Y+4	; 0x04
    1692:	fd 81       	ldd	r31, Y+5	; 0x05
    1694:	80 83       	st	Z, r24
    1696:	17 c0       	rjmp	.+46     	; 0x16c6 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTD:
			*P_u8PinValue=GET_BIT(PIND,Copy_u8PinNumber);
    1698:	e0 e3       	ldi	r30, 0x30	; 48
    169a:	f0 e0       	ldi	r31, 0x00	; 0
    169c:	80 81       	ld	r24, Z
    169e:	28 2f       	mov	r18, r24
    16a0:	30 e0       	ldi	r19, 0x00	; 0
    16a2:	8a 81       	ldd	r24, Y+2	; 0x02
    16a4:	88 2f       	mov	r24, r24
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	a9 01       	movw	r20, r18
    16aa:	02 c0       	rjmp	.+4      	; 0x16b0 <MDIO_Error_State_GetPinValue+0x106>
    16ac:	55 95       	asr	r21
    16ae:	47 95       	ror	r20
    16b0:	8a 95       	dec	r24
    16b2:	e2 f7       	brpl	.-8      	; 0x16ac <MDIO_Error_State_GetPinValue+0x102>
    16b4:	ca 01       	movw	r24, r20
    16b6:	81 70       	andi	r24, 0x01	; 1
    16b8:	ec 81       	ldd	r30, Y+4	; 0x04
    16ba:	fd 81       	ldd	r31, Y+5	; 0x05
    16bc:	80 83       	st	Z, r24
    16be:	03 c0       	rjmp	.+6      	; 0x16c6 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    16c0:	19 82       	std	Y+1, r1	; 0x01
    16c2:	01 c0       	rjmp	.+2      	; 0x16c6 <MDIO_Error_State_GetPinValue+0x11c>
			break;		
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    16c4:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    16c6:	89 81       	ldd	r24, Y+1	; 0x01
}
    16c8:	27 96       	adiw	r28, 0x07	; 7
    16ca:	0f b6       	in	r0, 0x3f	; 63
    16cc:	f8 94       	cli
    16ce:	de bf       	out	0x3e, r29	; 62
    16d0:	0f be       	out	0x3f, r0	; 63
    16d2:	cd bf       	out	0x3d, r28	; 61
    16d4:	cf 91       	pop	r28
    16d6:	df 91       	pop	r29
    16d8:	08 95       	ret

000016da <MDIO_Error_State_SetNippleValue>:
/*Set Nipple Direction Function */

/*Set Nipple Values Function */
Error_State MDIO_Error_State_SetNippleValue(u8 Copy_u8PinStart,u8 Copy_u8PortNumber,u8 Copy_u8Value)
{
    16da:	df 93       	push	r29
    16dc:	cf 93       	push	r28
    16de:	00 d0       	rcall	.+0      	; 0x16e0 <MDIO_Error_State_SetNippleValue+0x6>
    16e0:	00 d0       	rcall	.+0      	; 0x16e2 <MDIO_Error_State_SetNippleValue+0x8>
    16e2:	00 d0       	rcall	.+0      	; 0x16e4 <MDIO_Error_State_SetNippleValue+0xa>
    16e4:	cd b7       	in	r28, 0x3d	; 61
    16e6:	de b7       	in	r29, 0x3e	; 62
    16e8:	8a 83       	std	Y+2, r24	; 0x02
    16ea:	6b 83       	std	Y+3, r22	; 0x03
    16ec:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    16ee:	81 e0       	ldi	r24, 0x01	; 1
    16f0:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PinStart<=4)
    16f2:	8a 81       	ldd	r24, Y+2	; 0x02
    16f4:	85 30       	cpi	r24, 0x05	; 5
    16f6:	08 f0       	brcs	.+2      	; 0x16fa <MDIO_Error_State_SetNippleValue+0x20>
    16f8:	97 c0       	rjmp	.+302    	; 0x1828 <MDIO_Error_State_SetNippleValue+0x14e>
	{
		switch(Copy_u8PortNumber)
    16fa:	8b 81       	ldd	r24, Y+3	; 0x03
    16fc:	28 2f       	mov	r18, r24
    16fe:	30 e0       	ldi	r19, 0x00	; 0
    1700:	3e 83       	std	Y+6, r19	; 0x06
    1702:	2d 83       	std	Y+5, r18	; 0x05
    1704:	8d 81       	ldd	r24, Y+5	; 0x05
    1706:	9e 81       	ldd	r25, Y+6	; 0x06
    1708:	81 30       	cpi	r24, 0x01	; 1
    170a:	91 05       	cpc	r25, r1
    170c:	a1 f1       	breq	.+104    	; 0x1776 <MDIO_Error_State_SetNippleValue+0x9c>
    170e:	2d 81       	ldd	r18, Y+5	; 0x05
    1710:	3e 81       	ldd	r19, Y+6	; 0x06
    1712:	22 30       	cpi	r18, 0x02	; 2
    1714:	31 05       	cpc	r19, r1
    1716:	2c f4       	brge	.+10     	; 0x1722 <MDIO_Error_State_SetNippleValue+0x48>
    1718:	8d 81       	ldd	r24, Y+5	; 0x05
    171a:	9e 81       	ldd	r25, Y+6	; 0x06
    171c:	00 97       	sbiw	r24, 0x00	; 0
    171e:	71 f0       	breq	.+28     	; 0x173c <MDIO_Error_State_SetNippleValue+0x62>
    1720:	81 c0       	rjmp	.+258    	; 0x1824 <MDIO_Error_State_SetNippleValue+0x14a>
    1722:	2d 81       	ldd	r18, Y+5	; 0x05
    1724:	3e 81       	ldd	r19, Y+6	; 0x06
    1726:	22 30       	cpi	r18, 0x02	; 2
    1728:	31 05       	cpc	r19, r1
    172a:	09 f4       	brne	.+2      	; 0x172e <MDIO_Error_State_SetNippleValue+0x54>
    172c:	41 c0       	rjmp	.+130    	; 0x17b0 <MDIO_Error_State_SetNippleValue+0xd6>
    172e:	8d 81       	ldd	r24, Y+5	; 0x05
    1730:	9e 81       	ldd	r25, Y+6	; 0x06
    1732:	83 30       	cpi	r24, 0x03	; 3
    1734:	91 05       	cpc	r25, r1
    1736:	09 f4       	brne	.+2      	; 0x173a <MDIO_Error_State_SetNippleValue+0x60>
    1738:	58 c0       	rjmp	.+176    	; 0x17ea <MDIO_Error_State_SetNippleValue+0x110>
    173a:	74 c0       	rjmp	.+232    	; 0x1824 <MDIO_Error_State_SetNippleValue+0x14a>
		case MDIO_PORTA:
		/*for(u8 i=Copy_u8PinStart;i<=7;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTA&=(~(0x0F<<Copy_u8PinStart));
    173c:	ab e3       	ldi	r26, 0x3B	; 59
    173e:	b0 e0       	ldi	r27, 0x00	; 0
    1740:	eb e3       	ldi	r30, 0x3B	; 59
    1742:	f0 e0       	ldi	r31, 0x00	; 0
    1744:	80 81       	ld	r24, Z
    1746:	48 2f       	mov	r20, r24
    1748:	8a 81       	ldd	r24, Y+2	; 0x02
    174a:	28 2f       	mov	r18, r24
    174c:	30 e0       	ldi	r19, 0x00	; 0
    174e:	8f e0       	ldi	r24, 0x0F	; 15
    1750:	90 e0       	ldi	r25, 0x00	; 0
    1752:	02 2e       	mov	r0, r18
    1754:	02 c0       	rjmp	.+4      	; 0x175a <MDIO_Error_State_SetNippleValue+0x80>
    1756:	88 0f       	add	r24, r24
    1758:	99 1f       	adc	r25, r25
    175a:	0a 94       	dec	r0
    175c:	e2 f7       	brpl	.-8      	; 0x1756 <MDIO_Error_State_SetNippleValue+0x7c>
    175e:	80 95       	com	r24
    1760:	84 23       	and	r24, r20
    1762:	8c 93       	st	X, r24
			PORTA|=Copy_u8Value;
    1764:	ab e3       	ldi	r26, 0x3B	; 59
    1766:	b0 e0       	ldi	r27, 0x00	; 0
    1768:	eb e3       	ldi	r30, 0x3B	; 59
    176a:	f0 e0       	ldi	r31, 0x00	; 0
    176c:	90 81       	ld	r25, Z
    176e:	8c 81       	ldd	r24, Y+4	; 0x04
    1770:	89 2b       	or	r24, r25
    1772:	8c 93       	st	X, r24
    1774:	5a c0       	rjmp	.+180    	; 0x182a <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTB:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTB&=(~(0x0F<<Copy_u8PinStart));
    1776:	a8 e3       	ldi	r26, 0x38	; 56
    1778:	b0 e0       	ldi	r27, 0x00	; 0
    177a:	e8 e3       	ldi	r30, 0x38	; 56
    177c:	f0 e0       	ldi	r31, 0x00	; 0
    177e:	80 81       	ld	r24, Z
    1780:	48 2f       	mov	r20, r24
    1782:	8a 81       	ldd	r24, Y+2	; 0x02
    1784:	28 2f       	mov	r18, r24
    1786:	30 e0       	ldi	r19, 0x00	; 0
    1788:	8f e0       	ldi	r24, 0x0F	; 15
    178a:	90 e0       	ldi	r25, 0x00	; 0
    178c:	02 2e       	mov	r0, r18
    178e:	02 c0       	rjmp	.+4      	; 0x1794 <MDIO_Error_State_SetNippleValue+0xba>
    1790:	88 0f       	add	r24, r24
    1792:	99 1f       	adc	r25, r25
    1794:	0a 94       	dec	r0
    1796:	e2 f7       	brpl	.-8      	; 0x1790 <MDIO_Error_State_SetNippleValue+0xb6>
    1798:	80 95       	com	r24
    179a:	84 23       	and	r24, r20
    179c:	8c 93       	st	X, r24
			PORTB|=Copy_u8Value;
    179e:	a8 e3       	ldi	r26, 0x38	; 56
    17a0:	b0 e0       	ldi	r27, 0x00	; 0
    17a2:	e8 e3       	ldi	r30, 0x38	; 56
    17a4:	f0 e0       	ldi	r31, 0x00	; 0
    17a6:	90 81       	ld	r25, Z
    17a8:	8c 81       	ldd	r24, Y+4	; 0x04
    17aa:	89 2b       	or	r24, r25
    17ac:	8c 93       	st	X, r24
    17ae:	3d c0       	rjmp	.+122    	; 0x182a <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTC:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTC&=(~(0x0F<<Copy_u8PinStart));
    17b0:	a5 e3       	ldi	r26, 0x35	; 53
    17b2:	b0 e0       	ldi	r27, 0x00	; 0
    17b4:	e5 e3       	ldi	r30, 0x35	; 53
    17b6:	f0 e0       	ldi	r31, 0x00	; 0
    17b8:	80 81       	ld	r24, Z
    17ba:	48 2f       	mov	r20, r24
    17bc:	8a 81       	ldd	r24, Y+2	; 0x02
    17be:	28 2f       	mov	r18, r24
    17c0:	30 e0       	ldi	r19, 0x00	; 0
    17c2:	8f e0       	ldi	r24, 0x0F	; 15
    17c4:	90 e0       	ldi	r25, 0x00	; 0
    17c6:	02 2e       	mov	r0, r18
    17c8:	02 c0       	rjmp	.+4      	; 0x17ce <MDIO_Error_State_SetNippleValue+0xf4>
    17ca:	88 0f       	add	r24, r24
    17cc:	99 1f       	adc	r25, r25
    17ce:	0a 94       	dec	r0
    17d0:	e2 f7       	brpl	.-8      	; 0x17ca <MDIO_Error_State_SetNippleValue+0xf0>
    17d2:	80 95       	com	r24
    17d4:	84 23       	and	r24, r20
    17d6:	8c 93       	st	X, r24
			PORTC|=Copy_u8Value;
    17d8:	a5 e3       	ldi	r26, 0x35	; 53
    17da:	b0 e0       	ldi	r27, 0x00	; 0
    17dc:	e5 e3       	ldi	r30, 0x35	; 53
    17de:	f0 e0       	ldi	r31, 0x00	; 0
    17e0:	90 81       	ld	r25, Z
    17e2:	8c 81       	ldd	r24, Y+4	; 0x04
    17e4:	89 2b       	or	r24, r25
    17e6:	8c 93       	st	X, r24
    17e8:	20 c0       	rjmp	.+64     	; 0x182a <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTD:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTD&=(~(0x0F<<Copy_u8PinStart));
    17ea:	a2 e3       	ldi	r26, 0x32	; 50
    17ec:	b0 e0       	ldi	r27, 0x00	; 0
    17ee:	e2 e3       	ldi	r30, 0x32	; 50
    17f0:	f0 e0       	ldi	r31, 0x00	; 0
    17f2:	80 81       	ld	r24, Z
    17f4:	48 2f       	mov	r20, r24
    17f6:	8a 81       	ldd	r24, Y+2	; 0x02
    17f8:	28 2f       	mov	r18, r24
    17fa:	30 e0       	ldi	r19, 0x00	; 0
    17fc:	8f e0       	ldi	r24, 0x0F	; 15
    17fe:	90 e0       	ldi	r25, 0x00	; 0
    1800:	02 2e       	mov	r0, r18
    1802:	02 c0       	rjmp	.+4      	; 0x1808 <MDIO_Error_State_SetNippleValue+0x12e>
    1804:	88 0f       	add	r24, r24
    1806:	99 1f       	adc	r25, r25
    1808:	0a 94       	dec	r0
    180a:	e2 f7       	brpl	.-8      	; 0x1804 <MDIO_Error_State_SetNippleValue+0x12a>
    180c:	80 95       	com	r24
    180e:	84 23       	and	r24, r20
    1810:	8c 93       	st	X, r24
			PORTD|=Copy_u8Value;
    1812:	a2 e3       	ldi	r26, 0x32	; 50
    1814:	b0 e0       	ldi	r27, 0x00	; 0
    1816:	e2 e3       	ldi	r30, 0x32	; 50
    1818:	f0 e0       	ldi	r31, 0x00	; 0
    181a:	90 81       	ld	r25, Z
    181c:	8c 81       	ldd	r24, Y+4	; 0x04
    181e:	89 2b       	or	r24, r25
    1820:	8c 93       	st	X, r24
    1822:	03 c0       	rjmp	.+6      	; 0x182a <MDIO_Error_State_SetNippleValue+0x150>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    1824:	19 82       	std	Y+1, r1	; 0x01
    1826:	01 c0       	rjmp	.+2      	; 0x182a <MDIO_Error_State_SetNippleValue+0x150>
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    1828:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
    182a:	89 81       	ldd	r24, Y+1	; 0x01
}
    182c:	26 96       	adiw	r28, 0x06	; 6
    182e:	0f b6       	in	r0, 0x3f	; 63
    1830:	f8 94       	cli
    1832:	de bf       	out	0x3e, r29	; 62
    1834:	0f be       	out	0x3f, r0	; 63
    1836:	cd bf       	out	0x3d, r28	; 61
    1838:	cf 91       	pop	r28
    183a:	df 91       	pop	r29
    183c:	08 95       	ret

0000183e <MADC_VidInit>:

void (*MADC_CallBack)(void);

/*ADC Initialization*/
void MADC_VidInit(void)
{
    183e:	df 93       	push	r29
    1840:	cf 93       	push	r28
    1842:	cd b7       	in	r28, 0x3d	; 61
    1844:	de b7       	in	r29, 0x3e	; 62
	/*Select Reference Voltage*/
#if MADC_SET_REFERENCEVOLATGE == MADC_AVCC_REFERENCEVOLATGE
	SET_BIT(ADMUX,6);
    1846:	a7 e2       	ldi	r26, 0x27	; 39
    1848:	b0 e0       	ldi	r27, 0x00	; 0
    184a:	e7 e2       	ldi	r30, 0x27	; 39
    184c:	f0 e0       	ldi	r31, 0x00	; 0
    184e:	80 81       	ld	r24, Z
    1850:	80 64       	ori	r24, 0x40	; 64
    1852:	8c 93       	st	X, r24
	CLR_BIT(ADMUX,7);
    1854:	a7 e2       	ldi	r26, 0x27	; 39
    1856:	b0 e0       	ldi	r27, 0x00	; 0
    1858:	e7 e2       	ldi	r30, 0x27	; 39
    185a:	f0 e0       	ldi	r31, 0x00	; 0
    185c:	80 81       	ld	r24, Z
    185e:	8f 77       	andi	r24, 0x7F	; 127
    1860:	8c 93       	st	X, r24
	SET_BIT(ADMUX,7);
#else
#error"ADC Reference Voltage Option I s not valid.... "
#endif
/*Set Prescaler*/
ADCSRA&=MADC_BIT_MASKING_PRESCALER;
    1862:	a6 e2       	ldi	r26, 0x26	; 38
    1864:	b0 e0       	ldi	r27, 0x00	; 0
    1866:	e6 e2       	ldi	r30, 0x26	; 38
    1868:	f0 e0       	ldi	r31, 0x00	; 0
    186a:	80 81       	ld	r24, Z
    186c:	88 7f       	andi	r24, 0xF8	; 248
    186e:	8c 93       	st	X, r24
ADCSRA|=MADC_SET_PRESCALER;
    1870:	a6 e2       	ldi	r26, 0x26	; 38
    1872:	b0 e0       	ldi	r27, 0x00	; 0
    1874:	e6 e2       	ldi	r30, 0x26	; 38
    1876:	f0 e0       	ldi	r31, 0x00	; 0
    1878:	80 81       	ld	r24, Z
    187a:	87 60       	ori	r24, 0x07	; 7
    187c:	8c 93       	st	X, r24

#if MADC_SET_ADJUST == MADC_LEFT_ADJUST
	SET_BIT(ADMUX,5);
#elif MADC_SET_ADJUST == MADC_RIGHT_ADJUST
	CLR_BIT(ADMUX,5);
    187e:	a7 e2       	ldi	r26, 0x27	; 39
    1880:	b0 e0       	ldi	r27, 0x00	; 0
    1882:	e7 e2       	ldi	r30, 0x27	; 39
    1884:	f0 e0       	ldi	r31, 0x00	; 0
    1886:	80 81       	ld	r24, Z
    1888:	8f 7d       	andi	r24, 0xDF	; 223
    188a:	8c 93       	st	X, r24
#else
#error"ADC Left adjust option is not valid...."
#endif
/*Enable To ADC*/
SET_BIT(ADCSRA,7);
    188c:	a6 e2       	ldi	r26, 0x26	; 38
    188e:	b0 e0       	ldi	r27, 0x00	; 0
    1890:	e6 e2       	ldi	r30, 0x26	; 38
    1892:	f0 e0       	ldi	r31, 0x00	; 0
    1894:	80 81       	ld	r24, Z
    1896:	80 68       	ori	r24, 0x80	; 128
    1898:	8c 93       	st	X, r24
}
    189a:	cf 91       	pop	r28
    189c:	df 91       	pop	r29
    189e:	08 95       	ret

000018a0 <MADC_VidADCInterruptEnable>:
void MADC_VidADCInterruptEnable(void)
{
    18a0:	df 93       	push	r29
    18a2:	cf 93       	push	r28
    18a4:	cd b7       	in	r28, 0x3d	; 61
    18a6:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(ADCSRA,3);
    18a8:	a6 e2       	ldi	r26, 0x26	; 38
    18aa:	b0 e0       	ldi	r27, 0x00	; 0
    18ac:	e6 e2       	ldi	r30, 0x26	; 38
    18ae:	f0 e0       	ldi	r31, 0x00	; 0
    18b0:	80 81       	ld	r24, Z
    18b2:	88 60       	ori	r24, 0x08	; 8
    18b4:	8c 93       	st	X, r24
}
    18b6:	cf 91       	pop	r28
    18b8:	df 91       	pop	r29
    18ba:	08 95       	ret

000018bc <MADC_u16ADC_StartConversion>:
/*ADC Start Conversion-->Polling , Return ADC Value*/
u16 MADC_u16ADC_StartConversion(u8 Copy_u8Channel)
{
    18bc:	df 93       	push	r29
    18be:	cf 93       	push	r28
    18c0:	0f 92       	push	r0
    18c2:	cd b7       	in	r28, 0x3d	; 61
    18c4:	de b7       	in	r29, 0x3e	; 62
    18c6:	89 83       	std	Y+1, r24	; 0x01
	/*Select Channel*/
	Copy_u8Channel&=MADC_BIT_MASKING_CHANNEL;
    18c8:	89 81       	ldd	r24, Y+1	; 0x01
    18ca:	87 70       	andi	r24, 0x07	; 7
    18cc:	89 83       	std	Y+1, r24	; 0x01
	ADMUX&=MADC_BIT_MASKING_REG_CHANNEL;
    18ce:	a7 e2       	ldi	r26, 0x27	; 39
    18d0:	b0 e0       	ldi	r27, 0x00	; 0
    18d2:	e7 e2       	ldi	r30, 0x27	; 39
    18d4:	f0 e0       	ldi	r31, 0x00	; 0
    18d6:	80 81       	ld	r24, Z
    18d8:	80 7e       	andi	r24, 0xE0	; 224
    18da:	8c 93       	st	X, r24
	ADMUX|=Copy_u8Channel;
    18dc:	a7 e2       	ldi	r26, 0x27	; 39
    18de:	b0 e0       	ldi	r27, 0x00	; 0
    18e0:	e7 e2       	ldi	r30, 0x27	; 39
    18e2:	f0 e0       	ldi	r31, 0x00	; 0
    18e4:	90 81       	ld	r25, Z
    18e6:	89 81       	ldd	r24, Y+1	; 0x01
    18e8:	89 2b       	or	r24, r25
    18ea:	8c 93       	st	X, r24
   /*send Start Conversion*/
	SET_BIT(ADCSRA,6);
    18ec:	a6 e2       	ldi	r26, 0x26	; 38
    18ee:	b0 e0       	ldi	r27, 0x00	; 0
    18f0:	e6 e2       	ldi	r30, 0x26	; 38
    18f2:	f0 e0       	ldi	r31, 0x00	; 0
    18f4:	80 81       	ld	r24, Z
    18f6:	80 64       	ori	r24, 0x40	; 64
    18f8:	8c 93       	st	X, r24
	/*Wait On ADC Conversion Completed Flag is set to one */
	while(GET_BIT(ADCSRA,4)==0);
    18fa:	e6 e2       	ldi	r30, 0x26	; 38
    18fc:	f0 e0       	ldi	r31, 0x00	; 0
    18fe:	80 81       	ld	r24, Z
    1900:	82 95       	swap	r24
    1902:	8f 70       	andi	r24, 0x0F	; 15
    1904:	88 2f       	mov	r24, r24
    1906:	90 e0       	ldi	r25, 0x00	; 0
    1908:	81 70       	andi	r24, 0x01	; 1
    190a:	90 70       	andi	r25, 0x00	; 0
    190c:	00 97       	sbiw	r24, 0x00	; 0
    190e:	a9 f3       	breq	.-22     	; 0x18fa <MADC_u16ADC_StartConversion+0x3e>

	return ADC;
    1910:	e4 e2       	ldi	r30, 0x24	; 36
    1912:	f0 e0       	ldi	r31, 0x00	; 0
    1914:	80 81       	ld	r24, Z
    1916:	91 81       	ldd	r25, Z+1	; 0x01
}
    1918:	0f 90       	pop	r0
    191a:	cf 91       	pop	r28
    191c:	df 91       	pop	r29
    191e:	08 95       	ret

00001920 <MADC_u16ADC_StartConversion_With_Interrupt>:
void MADC_u16ADC_StartConversion_With_Interrupt(u8 Copy_u8Channel)
{
    1920:	df 93       	push	r29
    1922:	cf 93       	push	r28
    1924:	0f 92       	push	r0
    1926:	cd b7       	in	r28, 0x3d	; 61
    1928:	de b7       	in	r29, 0x3e	; 62
    192a:	89 83       	std	Y+1, r24	; 0x01
	/*Select Channel*/
	Copy_u8Channel&=MADC_BIT_MASKING_CHANNEL;
    192c:	89 81       	ldd	r24, Y+1	; 0x01
    192e:	87 70       	andi	r24, 0x07	; 7
    1930:	89 83       	std	Y+1, r24	; 0x01
	ADMUX&=MADC_BIT_MASKING_REG_CHANNEL;
    1932:	a7 e2       	ldi	r26, 0x27	; 39
    1934:	b0 e0       	ldi	r27, 0x00	; 0
    1936:	e7 e2       	ldi	r30, 0x27	; 39
    1938:	f0 e0       	ldi	r31, 0x00	; 0
    193a:	80 81       	ld	r24, Z
    193c:	80 7e       	andi	r24, 0xE0	; 224
    193e:	8c 93       	st	X, r24
	ADMUX|=Copy_u8Channel;
    1940:	a7 e2       	ldi	r26, 0x27	; 39
    1942:	b0 e0       	ldi	r27, 0x00	; 0
    1944:	e7 e2       	ldi	r30, 0x27	; 39
    1946:	f0 e0       	ldi	r31, 0x00	; 0
    1948:	90 81       	ld	r25, Z
    194a:	89 81       	ldd	r24, Y+1	; 0x01
    194c:	89 2b       	or	r24, r25
    194e:	8c 93       	st	X, r24
   /*send Start Conversion*/
	SET_BIT(ADCSRA,6);
    1950:	a6 e2       	ldi	r26, 0x26	; 38
    1952:	b0 e0       	ldi	r27, 0x00	; 0
    1954:	e6 e2       	ldi	r30, 0x26	; 38
    1956:	f0 e0       	ldi	r31, 0x00	; 0
    1958:	80 81       	ld	r24, Z
    195a:	80 64       	ori	r24, 0x40	; 64
    195c:	8c 93       	st	X, r24
}
    195e:	0f 90       	pop	r0
    1960:	cf 91       	pop	r28
    1962:	df 91       	pop	r29
    1964:	08 95       	ret

00001966 <MADC_u16ADCRead>:
u16 MADC_u16ADCRead(void)
{
    1966:	df 93       	push	r29
    1968:	cf 93       	push	r28
    196a:	cd b7       	in	r28, 0x3d	; 61
    196c:	de b7       	in	r29, 0x3e	; 62
	return ADC;
    196e:	e4 e2       	ldi	r30, 0x24	; 36
    1970:	f0 e0       	ldi	r31, 0x00	; 0
    1972:	80 81       	ld	r24, Z
    1974:	91 81       	ldd	r25, Z+1	; 0x01
}
    1976:	cf 91       	pop	r28
    1978:	df 91       	pop	r29
    197a:	08 95       	ret

0000197c <MADC_VidSetCallBack>:
void MADC_VidSetCallBack(void (*Copy_pFun)(void))
{
    197c:	df 93       	push	r29
    197e:	cf 93       	push	r28
    1980:	00 d0       	rcall	.+0      	; 0x1982 <MADC_VidSetCallBack+0x6>
    1982:	cd b7       	in	r28, 0x3d	; 61
    1984:	de b7       	in	r29, 0x3e	; 62
    1986:	9a 83       	std	Y+2, r25	; 0x02
    1988:	89 83       	std	Y+1, r24	; 0x01
	MADC_CallBack=Copy_pFun;
    198a:	89 81       	ldd	r24, Y+1	; 0x01
    198c:	9a 81       	ldd	r25, Y+2	; 0x02
    198e:	90 93 e4 07 	sts	0x07E4, r25
    1992:	80 93 e3 07 	sts	0x07E3, r24
}
    1996:	0f 90       	pop	r0
    1998:	0f 90       	pop	r0
    199a:	cf 91       	pop	r28
    199c:	df 91       	pop	r29
    199e:	08 95       	ret

000019a0 <__vector_16>:

void __vector_16(void)
{
    19a0:	1f 92       	push	r1
    19a2:	0f 92       	push	r0
    19a4:	0f b6       	in	r0, 0x3f	; 63
    19a6:	0f 92       	push	r0
    19a8:	11 24       	eor	r1, r1
    19aa:	2f 93       	push	r18
    19ac:	3f 93       	push	r19
    19ae:	4f 93       	push	r20
    19b0:	5f 93       	push	r21
    19b2:	6f 93       	push	r22
    19b4:	7f 93       	push	r23
    19b6:	8f 93       	push	r24
    19b8:	9f 93       	push	r25
    19ba:	af 93       	push	r26
    19bc:	bf 93       	push	r27
    19be:	ef 93       	push	r30
    19c0:	ff 93       	push	r31
    19c2:	df 93       	push	r29
    19c4:	cf 93       	push	r28
    19c6:	cd b7       	in	r28, 0x3d	; 61
    19c8:	de b7       	in	r29, 0x3e	; 62
	MADC_CallBack();
    19ca:	e0 91 e3 07 	lds	r30, 0x07E3
    19ce:	f0 91 e4 07 	lds	r31, 0x07E4
    19d2:	09 95       	icall
}
    19d4:	cf 91       	pop	r28
    19d6:	df 91       	pop	r29
    19d8:	ff 91       	pop	r31
    19da:	ef 91       	pop	r30
    19dc:	bf 91       	pop	r27
    19de:	af 91       	pop	r26
    19e0:	9f 91       	pop	r25
    19e2:	8f 91       	pop	r24
    19e4:	7f 91       	pop	r23
    19e6:	6f 91       	pop	r22
    19e8:	5f 91       	pop	r21
    19ea:	4f 91       	pop	r20
    19ec:	3f 91       	pop	r19
    19ee:	2f 91       	pop	r18
    19f0:	0f 90       	pop	r0
    19f2:	0f be       	out	0x3f, r0	; 63
    19f4:	0f 90       	pop	r0
    19f6:	1f 90       	pop	r1
    19f8:	18 95       	reti

000019fa <HSTEPPER_VidInit>:
#include"HSTEPPER_Config.h"
#include"HSTEPPER_Private.h"


void HSTEPPER_VidInit (STEPPER_t * Copy_Stepper )
{
    19fa:	df 93       	push	r29
    19fc:	cf 93       	push	r28
    19fe:	00 d0       	rcall	.+0      	; 0x1a00 <HSTEPPER_VidInit+0x6>
    1a00:	cd b7       	in	r28, 0x3d	; 61
    1a02:	de b7       	in	r29, 0x3e	; 62
    1a04:	9a 83       	std	Y+2, r25	; 0x02
    1a06:	89 83       	std	Y+1, r24	; 0x01
	/*Setting Direction of Both Pins as Output*/
	MDIO_Error_State_SetPinDirection(Copy_Stepper->Copy_u8Pin1,Copy_Stepper->Copy_u8Pin1Port,PIN_OUTPUT);
    1a08:	e9 81       	ldd	r30, Y+1	; 0x01
    1a0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a0c:	80 81       	ld	r24, Z
    1a0e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a10:	fa 81       	ldd	r31, Y+2	; 0x02
    1a12:	91 81       	ldd	r25, Z+1	; 0x01
    1a14:	69 2f       	mov	r22, r25
    1a16:	41 e0       	ldi	r20, 0x01	; 1
    1a18:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(Copy_Stepper->Copy_u8Pin2,Copy_Stepper->Copy_u8Pin2Port,PIN_OUTPUT);
    1a1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1a20:	82 81       	ldd	r24, Z+2	; 0x02
    1a22:	e9 81       	ldd	r30, Y+1	; 0x01
    1a24:	fa 81       	ldd	r31, Y+2	; 0x02
    1a26:	93 81       	ldd	r25, Z+3	; 0x03
    1a28:	69 2f       	mov	r22, r25
    1a2a:	41 e0       	ldi	r20, 0x01	; 1
    1a2c:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(Copy_Stepper->Copy_u8Pin3,Copy_Stepper->Copy_u8Pin3Port,PIN_OUTPUT);
    1a30:	e9 81       	ldd	r30, Y+1	; 0x01
    1a32:	fa 81       	ldd	r31, Y+2	; 0x02
    1a34:	84 81       	ldd	r24, Z+4	; 0x04
    1a36:	e9 81       	ldd	r30, Y+1	; 0x01
    1a38:	fa 81       	ldd	r31, Y+2	; 0x02
    1a3a:	95 81       	ldd	r25, Z+5	; 0x05
    1a3c:	69 2f       	mov	r22, r25
    1a3e:	41 e0       	ldi	r20, 0x01	; 1
    1a40:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(Copy_Stepper->Copy_u8Pin4,Copy_Stepper->Copy_u8Pin4Port,PIN_OUTPUT);
    1a44:	e9 81       	ldd	r30, Y+1	; 0x01
    1a46:	fa 81       	ldd	r31, Y+2	; 0x02
    1a48:	86 81       	ldd	r24, Z+6	; 0x06
    1a4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1a4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1a4e:	97 81       	ldd	r25, Z+7	; 0x07
    1a50:	69 2f       	mov	r22, r25
    1a52:	41 e0       	ldi	r20, 0x01	; 1
    1a54:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
}
    1a58:	0f 90       	pop	r0
    1a5a:	0f 90       	pop	r0
    1a5c:	cf 91       	pop	r28
    1a5e:	df 91       	pop	r29
    1a60:	08 95       	ret

00001a62 <HSTEPPER_VidFullStepAntiClockwiseSequence>:

void HSTEPPER_VidFullStepAntiClockwiseSequence (STEPPER_t * Copy_Stepper, u8 Copy_u8TimeDelay)
{
    1a62:	df 93       	push	r29
    1a64:	cf 93       	push	r28
    1a66:	cd b7       	in	r28, 0x3d	; 61
    1a68:	de b7       	in	r29, 0x3e	; 62
    1a6a:	eb 97       	sbiw	r28, 0x3b	; 59
    1a6c:	0f b6       	in	r0, 0x3f	; 63
    1a6e:	f8 94       	cli
    1a70:	de bf       	out	0x3e, r29	; 62
    1a72:	0f be       	out	0x3f, r0	; 63
    1a74:	cd bf       	out	0x3d, r28	; 61
    1a76:	9a af       	std	Y+58, r25	; 0x3a
    1a78:	89 af       	std	Y+57, r24	; 0x39
    1a7a:	6b af       	std	Y+59, r22	; 0x3b
	if (Copy_u8TimeDelay >=1)
    1a7c:	8b ad       	ldd	r24, Y+59	; 0x3b
    1a7e:	88 23       	and	r24, r24
    1a80:	09 f4       	brne	.+2      	; 0x1a84 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x22>
    1a82:	84 c2       	rjmp	.+1288   	; 0x1f8c <HSTEPPER_VidFullStepAntiClockwiseSequence+0x52a>
	{

		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin1,Copy_Stepper->Copy_u8Pin1Port,PIN_LOW);
    1a84:	e9 ad       	ldd	r30, Y+57	; 0x39
    1a86:	fa ad       	ldd	r31, Y+58	; 0x3a
    1a88:	80 81       	ld	r24, Z
    1a8a:	e9 ad       	ldd	r30, Y+57	; 0x39
    1a8c:	fa ad       	ldd	r31, Y+58	; 0x3a
    1a8e:	91 81       	ldd	r25, Z+1	; 0x01
    1a90:	69 2f       	mov	r22, r25
    1a92:	40 e0       	ldi	r20, 0x00	; 0
    1a94:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin2,Copy_Stepper->Copy_u8Pin2Port,PIN_HIGH);
    1a98:	e9 ad       	ldd	r30, Y+57	; 0x39
    1a9a:	fa ad       	ldd	r31, Y+58	; 0x3a
    1a9c:	82 81       	ldd	r24, Z+2	; 0x02
    1a9e:	e9 ad       	ldd	r30, Y+57	; 0x39
    1aa0:	fa ad       	ldd	r31, Y+58	; 0x3a
    1aa2:	93 81       	ldd	r25, Z+3	; 0x03
    1aa4:	69 2f       	mov	r22, r25
    1aa6:	41 e0       	ldi	r20, 0x01	; 1
    1aa8:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin3,Copy_Stepper->Copy_u8Pin3Port,PIN_HIGH);
    1aac:	e9 ad       	ldd	r30, Y+57	; 0x39
    1aae:	fa ad       	ldd	r31, Y+58	; 0x3a
    1ab0:	84 81       	ldd	r24, Z+4	; 0x04
    1ab2:	e9 ad       	ldd	r30, Y+57	; 0x39
    1ab4:	fa ad       	ldd	r31, Y+58	; 0x3a
    1ab6:	95 81       	ldd	r25, Z+5	; 0x05
    1ab8:	69 2f       	mov	r22, r25
    1aba:	41 e0       	ldi	r20, 0x01	; 1
    1abc:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin4,Copy_Stepper->Copy_u8Pin4Port,PIN_HIGH);
    1ac0:	e9 ad       	ldd	r30, Y+57	; 0x39
    1ac2:	fa ad       	ldd	r31, Y+58	; 0x3a
    1ac4:	86 81       	ldd	r24, Z+6	; 0x06
    1ac6:	e9 ad       	ldd	r30, Y+57	; 0x39
    1ac8:	fa ad       	ldd	r31, Y+58	; 0x3a
    1aca:	97 81       	ldd	r25, Z+7	; 0x07
    1acc:	69 2f       	mov	r22, r25
    1ace:	41 e0       	ldi	r20, 0x01	; 1
    1ad0:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>

		_delay_ms(Copy_u8TimeDelay);
    1ad4:	8b ad       	ldd	r24, Y+59	; 0x3b
    1ad6:	88 2f       	mov	r24, r24
    1ad8:	90 e0       	ldi	r25, 0x00	; 0
    1ada:	a0 e0       	ldi	r26, 0x00	; 0
    1adc:	b0 e0       	ldi	r27, 0x00	; 0
    1ade:	bc 01       	movw	r22, r24
    1ae0:	cd 01       	movw	r24, r26
    1ae2:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    1ae6:	dc 01       	movw	r26, r24
    1ae8:	cb 01       	movw	r24, r22
    1aea:	8d ab       	std	Y+53, r24	; 0x35
    1aec:	9e ab       	std	Y+54, r25	; 0x36
    1aee:	af ab       	std	Y+55, r26	; 0x37
    1af0:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1af2:	6d a9       	ldd	r22, Y+53	; 0x35
    1af4:	7e a9       	ldd	r23, Y+54	; 0x36
    1af6:	8f a9       	ldd	r24, Y+55	; 0x37
    1af8:	98 ad       	ldd	r25, Y+56	; 0x38
    1afa:	20 e0       	ldi	r18, 0x00	; 0
    1afc:	30 e0       	ldi	r19, 0x00	; 0
    1afe:	4a ef       	ldi	r20, 0xFA	; 250
    1b00:	54 e4       	ldi	r21, 0x44	; 68
    1b02:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b06:	dc 01       	movw	r26, r24
    1b08:	cb 01       	movw	r24, r22
    1b0a:	89 ab       	std	Y+49, r24	; 0x31
    1b0c:	9a ab       	std	Y+50, r25	; 0x32
    1b0e:	ab ab       	std	Y+51, r26	; 0x33
    1b10:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1b12:	69 a9       	ldd	r22, Y+49	; 0x31
    1b14:	7a a9       	ldd	r23, Y+50	; 0x32
    1b16:	8b a9       	ldd	r24, Y+51	; 0x33
    1b18:	9c a9       	ldd	r25, Y+52	; 0x34
    1b1a:	20 e0       	ldi	r18, 0x00	; 0
    1b1c:	30 e0       	ldi	r19, 0x00	; 0
    1b1e:	40 e8       	ldi	r20, 0x80	; 128
    1b20:	5f e3       	ldi	r21, 0x3F	; 63
    1b22:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1b26:	88 23       	and	r24, r24
    1b28:	2c f4       	brge	.+10     	; 0x1b34 <HSTEPPER_VidFullStepAntiClockwiseSequence+0xd2>
		__ticks = 1;
    1b2a:	81 e0       	ldi	r24, 0x01	; 1
    1b2c:	90 e0       	ldi	r25, 0x00	; 0
    1b2e:	98 ab       	std	Y+48, r25	; 0x30
    1b30:	8f a7       	std	Y+47, r24	; 0x2f
    1b32:	3f c0       	rjmp	.+126    	; 0x1bb2 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x150>
	else if (__tmp > 65535)
    1b34:	69 a9       	ldd	r22, Y+49	; 0x31
    1b36:	7a a9       	ldd	r23, Y+50	; 0x32
    1b38:	8b a9       	ldd	r24, Y+51	; 0x33
    1b3a:	9c a9       	ldd	r25, Y+52	; 0x34
    1b3c:	20 e0       	ldi	r18, 0x00	; 0
    1b3e:	3f ef       	ldi	r19, 0xFF	; 255
    1b40:	4f e7       	ldi	r20, 0x7F	; 127
    1b42:	57 e4       	ldi	r21, 0x47	; 71
    1b44:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1b48:	18 16       	cp	r1, r24
    1b4a:	4c f5       	brge	.+82     	; 0x1b9e <HSTEPPER_VidFullStepAntiClockwiseSequence+0x13c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b4c:	6d a9       	ldd	r22, Y+53	; 0x35
    1b4e:	7e a9       	ldd	r23, Y+54	; 0x36
    1b50:	8f a9       	ldd	r24, Y+55	; 0x37
    1b52:	98 ad       	ldd	r25, Y+56	; 0x38
    1b54:	20 e0       	ldi	r18, 0x00	; 0
    1b56:	30 e0       	ldi	r19, 0x00	; 0
    1b58:	40 e2       	ldi	r20, 0x20	; 32
    1b5a:	51 e4       	ldi	r21, 0x41	; 65
    1b5c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b60:	dc 01       	movw	r26, r24
    1b62:	cb 01       	movw	r24, r22
    1b64:	bc 01       	movw	r22, r24
    1b66:	cd 01       	movw	r24, r26
    1b68:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b6c:	dc 01       	movw	r26, r24
    1b6e:	cb 01       	movw	r24, r22
    1b70:	98 ab       	std	Y+48, r25	; 0x30
    1b72:	8f a7       	std	Y+47, r24	; 0x2f
    1b74:	0f c0       	rjmp	.+30     	; 0x1b94 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x132>
    1b76:	88 ec       	ldi	r24, 0xC8	; 200
    1b78:	90 e0       	ldi	r25, 0x00	; 0
    1b7a:	9e a7       	std	Y+46, r25	; 0x2e
    1b7c:	8d a7       	std	Y+45, r24	; 0x2d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1b7e:	8d a5       	ldd	r24, Y+45	; 0x2d
    1b80:	9e a5       	ldd	r25, Y+46	; 0x2e
    1b82:	01 97       	sbiw	r24, 0x01	; 1
    1b84:	f1 f7       	brne	.-4      	; 0x1b82 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x120>
    1b86:	9e a7       	std	Y+46, r25	; 0x2e
    1b88:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b8a:	8f a5       	ldd	r24, Y+47	; 0x2f
    1b8c:	98 a9       	ldd	r25, Y+48	; 0x30
    1b8e:	01 97       	sbiw	r24, 0x01	; 1
    1b90:	98 ab       	std	Y+48, r25	; 0x30
    1b92:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b94:	8f a5       	ldd	r24, Y+47	; 0x2f
    1b96:	98 a9       	ldd	r25, Y+48	; 0x30
    1b98:	00 97       	sbiw	r24, 0x00	; 0
    1b9a:	69 f7       	brne	.-38     	; 0x1b76 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x114>
    1b9c:	14 c0       	rjmp	.+40     	; 0x1bc6 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x164>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1b9e:	69 a9       	ldd	r22, Y+49	; 0x31
    1ba0:	7a a9       	ldd	r23, Y+50	; 0x32
    1ba2:	8b a9       	ldd	r24, Y+51	; 0x33
    1ba4:	9c a9       	ldd	r25, Y+52	; 0x34
    1ba6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1baa:	dc 01       	movw	r26, r24
    1bac:	cb 01       	movw	r24, r22
    1bae:	98 ab       	std	Y+48, r25	; 0x30
    1bb0:	8f a7       	std	Y+47, r24	; 0x2f
    1bb2:	8f a5       	ldd	r24, Y+47	; 0x2f
    1bb4:	98 a9       	ldd	r25, Y+48	; 0x30
    1bb6:	9c a7       	std	Y+44, r25	; 0x2c
    1bb8:	8b a7       	std	Y+43, r24	; 0x2b
    1bba:	8b a5       	ldd	r24, Y+43	; 0x2b
    1bbc:	9c a5       	ldd	r25, Y+44	; 0x2c
    1bbe:	01 97       	sbiw	r24, 0x01	; 1
    1bc0:	f1 f7       	brne	.-4      	; 0x1bbe <HSTEPPER_VidFullStepAntiClockwiseSequence+0x15c>
    1bc2:	9c a7       	std	Y+44, r25	; 0x2c
    1bc4:	8b a7       	std	Y+43, r24	; 0x2b


		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin1,Copy_Stepper->Copy_u8Pin1Port,PIN_HIGH);
    1bc6:	e9 ad       	ldd	r30, Y+57	; 0x39
    1bc8:	fa ad       	ldd	r31, Y+58	; 0x3a
    1bca:	80 81       	ld	r24, Z
    1bcc:	e9 ad       	ldd	r30, Y+57	; 0x39
    1bce:	fa ad       	ldd	r31, Y+58	; 0x3a
    1bd0:	91 81       	ldd	r25, Z+1	; 0x01
    1bd2:	69 2f       	mov	r22, r25
    1bd4:	41 e0       	ldi	r20, 0x01	; 1
    1bd6:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin2,Copy_Stepper->Copy_u8Pin2Port,PIN_LOW);
    1bda:	e9 ad       	ldd	r30, Y+57	; 0x39
    1bdc:	fa ad       	ldd	r31, Y+58	; 0x3a
    1bde:	82 81       	ldd	r24, Z+2	; 0x02
    1be0:	e9 ad       	ldd	r30, Y+57	; 0x39
    1be2:	fa ad       	ldd	r31, Y+58	; 0x3a
    1be4:	93 81       	ldd	r25, Z+3	; 0x03
    1be6:	69 2f       	mov	r22, r25
    1be8:	40 e0       	ldi	r20, 0x00	; 0
    1bea:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin3,Copy_Stepper->Copy_u8Pin3Port,PIN_HIGH);
    1bee:	e9 ad       	ldd	r30, Y+57	; 0x39
    1bf0:	fa ad       	ldd	r31, Y+58	; 0x3a
    1bf2:	84 81       	ldd	r24, Z+4	; 0x04
    1bf4:	e9 ad       	ldd	r30, Y+57	; 0x39
    1bf6:	fa ad       	ldd	r31, Y+58	; 0x3a
    1bf8:	95 81       	ldd	r25, Z+5	; 0x05
    1bfa:	69 2f       	mov	r22, r25
    1bfc:	41 e0       	ldi	r20, 0x01	; 1
    1bfe:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin4,Copy_Stepper->Copy_u8Pin4Port,PIN_HIGH);
    1c02:	e9 ad       	ldd	r30, Y+57	; 0x39
    1c04:	fa ad       	ldd	r31, Y+58	; 0x3a
    1c06:	86 81       	ldd	r24, Z+6	; 0x06
    1c08:	e9 ad       	ldd	r30, Y+57	; 0x39
    1c0a:	fa ad       	ldd	r31, Y+58	; 0x3a
    1c0c:	97 81       	ldd	r25, Z+7	; 0x07
    1c0e:	69 2f       	mov	r22, r25
    1c10:	41 e0       	ldi	r20, 0x01	; 1
    1c12:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		_delay_ms(Copy_u8TimeDelay);
    1c16:	8b ad       	ldd	r24, Y+59	; 0x3b
    1c18:	88 2f       	mov	r24, r24
    1c1a:	90 e0       	ldi	r25, 0x00	; 0
    1c1c:	a0 e0       	ldi	r26, 0x00	; 0
    1c1e:	b0 e0       	ldi	r27, 0x00	; 0
    1c20:	bc 01       	movw	r22, r24
    1c22:	cd 01       	movw	r24, r26
    1c24:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    1c28:	dc 01       	movw	r26, r24
    1c2a:	cb 01       	movw	r24, r22
    1c2c:	8f a3       	std	Y+39, r24	; 0x27
    1c2e:	98 a7       	std	Y+40, r25	; 0x28
    1c30:	a9 a7       	std	Y+41, r26	; 0x29
    1c32:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c34:	6f a1       	ldd	r22, Y+39	; 0x27
    1c36:	78 a5       	ldd	r23, Y+40	; 0x28
    1c38:	89 a5       	ldd	r24, Y+41	; 0x29
    1c3a:	9a a5       	ldd	r25, Y+42	; 0x2a
    1c3c:	20 e0       	ldi	r18, 0x00	; 0
    1c3e:	30 e0       	ldi	r19, 0x00	; 0
    1c40:	4a ef       	ldi	r20, 0xFA	; 250
    1c42:	54 e4       	ldi	r21, 0x44	; 68
    1c44:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c48:	dc 01       	movw	r26, r24
    1c4a:	cb 01       	movw	r24, r22
    1c4c:	8b a3       	std	Y+35, r24	; 0x23
    1c4e:	9c a3       	std	Y+36, r25	; 0x24
    1c50:	ad a3       	std	Y+37, r26	; 0x25
    1c52:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1c54:	6b a1       	ldd	r22, Y+35	; 0x23
    1c56:	7c a1       	ldd	r23, Y+36	; 0x24
    1c58:	8d a1       	ldd	r24, Y+37	; 0x25
    1c5a:	9e a1       	ldd	r25, Y+38	; 0x26
    1c5c:	20 e0       	ldi	r18, 0x00	; 0
    1c5e:	30 e0       	ldi	r19, 0x00	; 0
    1c60:	40 e8       	ldi	r20, 0x80	; 128
    1c62:	5f e3       	ldi	r21, 0x3F	; 63
    1c64:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1c68:	88 23       	and	r24, r24
    1c6a:	2c f4       	brge	.+10     	; 0x1c76 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x214>
		__ticks = 1;
    1c6c:	81 e0       	ldi	r24, 0x01	; 1
    1c6e:	90 e0       	ldi	r25, 0x00	; 0
    1c70:	9a a3       	std	Y+34, r25	; 0x22
    1c72:	89 a3       	std	Y+33, r24	; 0x21
    1c74:	3f c0       	rjmp	.+126    	; 0x1cf4 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x292>
	else if (__tmp > 65535)
    1c76:	6b a1       	ldd	r22, Y+35	; 0x23
    1c78:	7c a1       	ldd	r23, Y+36	; 0x24
    1c7a:	8d a1       	ldd	r24, Y+37	; 0x25
    1c7c:	9e a1       	ldd	r25, Y+38	; 0x26
    1c7e:	20 e0       	ldi	r18, 0x00	; 0
    1c80:	3f ef       	ldi	r19, 0xFF	; 255
    1c82:	4f e7       	ldi	r20, 0x7F	; 127
    1c84:	57 e4       	ldi	r21, 0x47	; 71
    1c86:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1c8a:	18 16       	cp	r1, r24
    1c8c:	4c f5       	brge	.+82     	; 0x1ce0 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x27e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c8e:	6f a1       	ldd	r22, Y+39	; 0x27
    1c90:	78 a5       	ldd	r23, Y+40	; 0x28
    1c92:	89 a5       	ldd	r24, Y+41	; 0x29
    1c94:	9a a5       	ldd	r25, Y+42	; 0x2a
    1c96:	20 e0       	ldi	r18, 0x00	; 0
    1c98:	30 e0       	ldi	r19, 0x00	; 0
    1c9a:	40 e2       	ldi	r20, 0x20	; 32
    1c9c:	51 e4       	ldi	r21, 0x41	; 65
    1c9e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ca2:	dc 01       	movw	r26, r24
    1ca4:	cb 01       	movw	r24, r22
    1ca6:	bc 01       	movw	r22, r24
    1ca8:	cd 01       	movw	r24, r26
    1caa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cae:	dc 01       	movw	r26, r24
    1cb0:	cb 01       	movw	r24, r22
    1cb2:	9a a3       	std	Y+34, r25	; 0x22
    1cb4:	89 a3       	std	Y+33, r24	; 0x21
    1cb6:	0f c0       	rjmp	.+30     	; 0x1cd6 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x274>
    1cb8:	88 ec       	ldi	r24, 0xC8	; 200
    1cba:	90 e0       	ldi	r25, 0x00	; 0
    1cbc:	98 a3       	std	Y+32, r25	; 0x20
    1cbe:	8f 8f       	std	Y+31, r24	; 0x1f
    1cc0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1cc2:	98 a1       	ldd	r25, Y+32	; 0x20
    1cc4:	01 97       	sbiw	r24, 0x01	; 1
    1cc6:	f1 f7       	brne	.-4      	; 0x1cc4 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x262>
    1cc8:	98 a3       	std	Y+32, r25	; 0x20
    1cca:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ccc:	89 a1       	ldd	r24, Y+33	; 0x21
    1cce:	9a a1       	ldd	r25, Y+34	; 0x22
    1cd0:	01 97       	sbiw	r24, 0x01	; 1
    1cd2:	9a a3       	std	Y+34, r25	; 0x22
    1cd4:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1cd6:	89 a1       	ldd	r24, Y+33	; 0x21
    1cd8:	9a a1       	ldd	r25, Y+34	; 0x22
    1cda:	00 97       	sbiw	r24, 0x00	; 0
    1cdc:	69 f7       	brne	.-38     	; 0x1cb8 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x256>
    1cde:	14 c0       	rjmp	.+40     	; 0x1d08 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x2a6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ce0:	6b a1       	ldd	r22, Y+35	; 0x23
    1ce2:	7c a1       	ldd	r23, Y+36	; 0x24
    1ce4:	8d a1       	ldd	r24, Y+37	; 0x25
    1ce6:	9e a1       	ldd	r25, Y+38	; 0x26
    1ce8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cec:	dc 01       	movw	r26, r24
    1cee:	cb 01       	movw	r24, r22
    1cf0:	9a a3       	std	Y+34, r25	; 0x22
    1cf2:	89 a3       	std	Y+33, r24	; 0x21
    1cf4:	89 a1       	ldd	r24, Y+33	; 0x21
    1cf6:	9a a1       	ldd	r25, Y+34	; 0x22
    1cf8:	9e 8f       	std	Y+30, r25	; 0x1e
    1cfa:	8d 8f       	std	Y+29, r24	; 0x1d
    1cfc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1cfe:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1d00:	01 97       	sbiw	r24, 0x01	; 1
    1d02:	f1 f7       	brne	.-4      	; 0x1d00 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x29e>
    1d04:	9e 8f       	std	Y+30, r25	; 0x1e
    1d06:	8d 8f       	std	Y+29, r24	; 0x1d

		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin1,Copy_Stepper->Copy_u8Pin1Port,PIN_HIGH);
    1d08:	e9 ad       	ldd	r30, Y+57	; 0x39
    1d0a:	fa ad       	ldd	r31, Y+58	; 0x3a
    1d0c:	80 81       	ld	r24, Z
    1d0e:	e9 ad       	ldd	r30, Y+57	; 0x39
    1d10:	fa ad       	ldd	r31, Y+58	; 0x3a
    1d12:	91 81       	ldd	r25, Z+1	; 0x01
    1d14:	69 2f       	mov	r22, r25
    1d16:	41 e0       	ldi	r20, 0x01	; 1
    1d18:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin2,Copy_Stepper->Copy_u8Pin2Port,PIN_HIGH);
    1d1c:	e9 ad       	ldd	r30, Y+57	; 0x39
    1d1e:	fa ad       	ldd	r31, Y+58	; 0x3a
    1d20:	82 81       	ldd	r24, Z+2	; 0x02
    1d22:	e9 ad       	ldd	r30, Y+57	; 0x39
    1d24:	fa ad       	ldd	r31, Y+58	; 0x3a
    1d26:	93 81       	ldd	r25, Z+3	; 0x03
    1d28:	69 2f       	mov	r22, r25
    1d2a:	41 e0       	ldi	r20, 0x01	; 1
    1d2c:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin3,Copy_Stepper->Copy_u8Pin3Port,PIN_LOW);
    1d30:	e9 ad       	ldd	r30, Y+57	; 0x39
    1d32:	fa ad       	ldd	r31, Y+58	; 0x3a
    1d34:	84 81       	ldd	r24, Z+4	; 0x04
    1d36:	e9 ad       	ldd	r30, Y+57	; 0x39
    1d38:	fa ad       	ldd	r31, Y+58	; 0x3a
    1d3a:	95 81       	ldd	r25, Z+5	; 0x05
    1d3c:	69 2f       	mov	r22, r25
    1d3e:	40 e0       	ldi	r20, 0x00	; 0
    1d40:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin4,Copy_Stepper->Copy_u8Pin4Port,PIN_HIGH);
    1d44:	e9 ad       	ldd	r30, Y+57	; 0x39
    1d46:	fa ad       	ldd	r31, Y+58	; 0x3a
    1d48:	86 81       	ldd	r24, Z+6	; 0x06
    1d4a:	e9 ad       	ldd	r30, Y+57	; 0x39
    1d4c:	fa ad       	ldd	r31, Y+58	; 0x3a
    1d4e:	97 81       	ldd	r25, Z+7	; 0x07
    1d50:	69 2f       	mov	r22, r25
    1d52:	41 e0       	ldi	r20, 0x01	; 1
    1d54:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		_delay_ms(Copy_u8TimeDelay);
    1d58:	8b ad       	ldd	r24, Y+59	; 0x3b
    1d5a:	88 2f       	mov	r24, r24
    1d5c:	90 e0       	ldi	r25, 0x00	; 0
    1d5e:	a0 e0       	ldi	r26, 0x00	; 0
    1d60:	b0 e0       	ldi	r27, 0x00	; 0
    1d62:	bc 01       	movw	r22, r24
    1d64:	cd 01       	movw	r24, r26
    1d66:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    1d6a:	dc 01       	movw	r26, r24
    1d6c:	cb 01       	movw	r24, r22
    1d6e:	89 8f       	std	Y+25, r24	; 0x19
    1d70:	9a 8f       	std	Y+26, r25	; 0x1a
    1d72:	ab 8f       	std	Y+27, r26	; 0x1b
    1d74:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d76:	69 8d       	ldd	r22, Y+25	; 0x19
    1d78:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1d7a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1d7c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1d7e:	20 e0       	ldi	r18, 0x00	; 0
    1d80:	30 e0       	ldi	r19, 0x00	; 0
    1d82:	4a ef       	ldi	r20, 0xFA	; 250
    1d84:	54 e4       	ldi	r21, 0x44	; 68
    1d86:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d8a:	dc 01       	movw	r26, r24
    1d8c:	cb 01       	movw	r24, r22
    1d8e:	8d 8b       	std	Y+21, r24	; 0x15
    1d90:	9e 8b       	std	Y+22, r25	; 0x16
    1d92:	af 8b       	std	Y+23, r26	; 0x17
    1d94:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1d96:	6d 89       	ldd	r22, Y+21	; 0x15
    1d98:	7e 89       	ldd	r23, Y+22	; 0x16
    1d9a:	8f 89       	ldd	r24, Y+23	; 0x17
    1d9c:	98 8d       	ldd	r25, Y+24	; 0x18
    1d9e:	20 e0       	ldi	r18, 0x00	; 0
    1da0:	30 e0       	ldi	r19, 0x00	; 0
    1da2:	40 e8       	ldi	r20, 0x80	; 128
    1da4:	5f e3       	ldi	r21, 0x3F	; 63
    1da6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1daa:	88 23       	and	r24, r24
    1dac:	2c f4       	brge	.+10     	; 0x1db8 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x356>
		__ticks = 1;
    1dae:	81 e0       	ldi	r24, 0x01	; 1
    1db0:	90 e0       	ldi	r25, 0x00	; 0
    1db2:	9c 8b       	std	Y+20, r25	; 0x14
    1db4:	8b 8b       	std	Y+19, r24	; 0x13
    1db6:	3f c0       	rjmp	.+126    	; 0x1e36 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x3d4>
	else if (__tmp > 65535)
    1db8:	6d 89       	ldd	r22, Y+21	; 0x15
    1dba:	7e 89       	ldd	r23, Y+22	; 0x16
    1dbc:	8f 89       	ldd	r24, Y+23	; 0x17
    1dbe:	98 8d       	ldd	r25, Y+24	; 0x18
    1dc0:	20 e0       	ldi	r18, 0x00	; 0
    1dc2:	3f ef       	ldi	r19, 0xFF	; 255
    1dc4:	4f e7       	ldi	r20, 0x7F	; 127
    1dc6:	57 e4       	ldi	r21, 0x47	; 71
    1dc8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1dcc:	18 16       	cp	r1, r24
    1dce:	4c f5       	brge	.+82     	; 0x1e22 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x3c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1dd0:	69 8d       	ldd	r22, Y+25	; 0x19
    1dd2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1dd4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1dd6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1dd8:	20 e0       	ldi	r18, 0x00	; 0
    1dda:	30 e0       	ldi	r19, 0x00	; 0
    1ddc:	40 e2       	ldi	r20, 0x20	; 32
    1dde:	51 e4       	ldi	r21, 0x41	; 65
    1de0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1de4:	dc 01       	movw	r26, r24
    1de6:	cb 01       	movw	r24, r22
    1de8:	bc 01       	movw	r22, r24
    1dea:	cd 01       	movw	r24, r26
    1dec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1df0:	dc 01       	movw	r26, r24
    1df2:	cb 01       	movw	r24, r22
    1df4:	9c 8b       	std	Y+20, r25	; 0x14
    1df6:	8b 8b       	std	Y+19, r24	; 0x13
    1df8:	0f c0       	rjmp	.+30     	; 0x1e18 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x3b6>
    1dfa:	88 ec       	ldi	r24, 0xC8	; 200
    1dfc:	90 e0       	ldi	r25, 0x00	; 0
    1dfe:	9a 8b       	std	Y+18, r25	; 0x12
    1e00:	89 8b       	std	Y+17, r24	; 0x11
    1e02:	89 89       	ldd	r24, Y+17	; 0x11
    1e04:	9a 89       	ldd	r25, Y+18	; 0x12
    1e06:	01 97       	sbiw	r24, 0x01	; 1
    1e08:	f1 f7       	brne	.-4      	; 0x1e06 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x3a4>
    1e0a:	9a 8b       	std	Y+18, r25	; 0x12
    1e0c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e0e:	8b 89       	ldd	r24, Y+19	; 0x13
    1e10:	9c 89       	ldd	r25, Y+20	; 0x14
    1e12:	01 97       	sbiw	r24, 0x01	; 1
    1e14:	9c 8b       	std	Y+20, r25	; 0x14
    1e16:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e18:	8b 89       	ldd	r24, Y+19	; 0x13
    1e1a:	9c 89       	ldd	r25, Y+20	; 0x14
    1e1c:	00 97       	sbiw	r24, 0x00	; 0
    1e1e:	69 f7       	brne	.-38     	; 0x1dfa <HSTEPPER_VidFullStepAntiClockwiseSequence+0x398>
    1e20:	14 c0       	rjmp	.+40     	; 0x1e4a <HSTEPPER_VidFullStepAntiClockwiseSequence+0x3e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e22:	6d 89       	ldd	r22, Y+21	; 0x15
    1e24:	7e 89       	ldd	r23, Y+22	; 0x16
    1e26:	8f 89       	ldd	r24, Y+23	; 0x17
    1e28:	98 8d       	ldd	r25, Y+24	; 0x18
    1e2a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e2e:	dc 01       	movw	r26, r24
    1e30:	cb 01       	movw	r24, r22
    1e32:	9c 8b       	std	Y+20, r25	; 0x14
    1e34:	8b 8b       	std	Y+19, r24	; 0x13
    1e36:	8b 89       	ldd	r24, Y+19	; 0x13
    1e38:	9c 89       	ldd	r25, Y+20	; 0x14
    1e3a:	98 8b       	std	Y+16, r25	; 0x10
    1e3c:	8f 87       	std	Y+15, r24	; 0x0f
    1e3e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1e40:	98 89       	ldd	r25, Y+16	; 0x10
    1e42:	01 97       	sbiw	r24, 0x01	; 1
    1e44:	f1 f7       	brne	.-4      	; 0x1e42 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x3e0>
    1e46:	98 8b       	std	Y+16, r25	; 0x10
    1e48:	8f 87       	std	Y+15, r24	; 0x0f

		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin1,Copy_Stepper->Copy_u8Pin1Port,PIN_HIGH);
    1e4a:	e9 ad       	ldd	r30, Y+57	; 0x39
    1e4c:	fa ad       	ldd	r31, Y+58	; 0x3a
    1e4e:	80 81       	ld	r24, Z
    1e50:	e9 ad       	ldd	r30, Y+57	; 0x39
    1e52:	fa ad       	ldd	r31, Y+58	; 0x3a
    1e54:	91 81       	ldd	r25, Z+1	; 0x01
    1e56:	69 2f       	mov	r22, r25
    1e58:	41 e0       	ldi	r20, 0x01	; 1
    1e5a:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin2,Copy_Stepper->Copy_u8Pin2Port,PIN_HIGH);
    1e5e:	e9 ad       	ldd	r30, Y+57	; 0x39
    1e60:	fa ad       	ldd	r31, Y+58	; 0x3a
    1e62:	82 81       	ldd	r24, Z+2	; 0x02
    1e64:	e9 ad       	ldd	r30, Y+57	; 0x39
    1e66:	fa ad       	ldd	r31, Y+58	; 0x3a
    1e68:	93 81       	ldd	r25, Z+3	; 0x03
    1e6a:	69 2f       	mov	r22, r25
    1e6c:	41 e0       	ldi	r20, 0x01	; 1
    1e6e:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin3,Copy_Stepper->Copy_u8Pin3Port,PIN_HIGH);
    1e72:	e9 ad       	ldd	r30, Y+57	; 0x39
    1e74:	fa ad       	ldd	r31, Y+58	; 0x3a
    1e76:	84 81       	ldd	r24, Z+4	; 0x04
    1e78:	e9 ad       	ldd	r30, Y+57	; 0x39
    1e7a:	fa ad       	ldd	r31, Y+58	; 0x3a
    1e7c:	95 81       	ldd	r25, Z+5	; 0x05
    1e7e:	69 2f       	mov	r22, r25
    1e80:	41 e0       	ldi	r20, 0x01	; 1
    1e82:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin4,Copy_Stepper->Copy_u8Pin4Port,PIN_LOW);
    1e86:	e9 ad       	ldd	r30, Y+57	; 0x39
    1e88:	fa ad       	ldd	r31, Y+58	; 0x3a
    1e8a:	86 81       	ldd	r24, Z+6	; 0x06
    1e8c:	e9 ad       	ldd	r30, Y+57	; 0x39
    1e8e:	fa ad       	ldd	r31, Y+58	; 0x3a
    1e90:	97 81       	ldd	r25, Z+7	; 0x07
    1e92:	69 2f       	mov	r22, r25
    1e94:	40 e0       	ldi	r20, 0x00	; 0
    1e96:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>

		_delay_ms(Copy_u8TimeDelay);
    1e9a:	8b ad       	ldd	r24, Y+59	; 0x3b
    1e9c:	88 2f       	mov	r24, r24
    1e9e:	90 e0       	ldi	r25, 0x00	; 0
    1ea0:	a0 e0       	ldi	r26, 0x00	; 0
    1ea2:	b0 e0       	ldi	r27, 0x00	; 0
    1ea4:	bc 01       	movw	r22, r24
    1ea6:	cd 01       	movw	r24, r26
    1ea8:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    1eac:	dc 01       	movw	r26, r24
    1eae:	cb 01       	movw	r24, r22
    1eb0:	8b 87       	std	Y+11, r24	; 0x0b
    1eb2:	9c 87       	std	Y+12, r25	; 0x0c
    1eb4:	ad 87       	std	Y+13, r26	; 0x0d
    1eb6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1eb8:	6b 85       	ldd	r22, Y+11	; 0x0b
    1eba:	7c 85       	ldd	r23, Y+12	; 0x0c
    1ebc:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ebe:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ec0:	20 e0       	ldi	r18, 0x00	; 0
    1ec2:	30 e0       	ldi	r19, 0x00	; 0
    1ec4:	4a ef       	ldi	r20, 0xFA	; 250
    1ec6:	54 e4       	ldi	r21, 0x44	; 68
    1ec8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ecc:	dc 01       	movw	r26, r24
    1ece:	cb 01       	movw	r24, r22
    1ed0:	8f 83       	std	Y+7, r24	; 0x07
    1ed2:	98 87       	std	Y+8, r25	; 0x08
    1ed4:	a9 87       	std	Y+9, r26	; 0x09
    1ed6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1ed8:	6f 81       	ldd	r22, Y+7	; 0x07
    1eda:	78 85       	ldd	r23, Y+8	; 0x08
    1edc:	89 85       	ldd	r24, Y+9	; 0x09
    1ede:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ee0:	20 e0       	ldi	r18, 0x00	; 0
    1ee2:	30 e0       	ldi	r19, 0x00	; 0
    1ee4:	40 e8       	ldi	r20, 0x80	; 128
    1ee6:	5f e3       	ldi	r21, 0x3F	; 63
    1ee8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1eec:	88 23       	and	r24, r24
    1eee:	2c f4       	brge	.+10     	; 0x1efa <HSTEPPER_VidFullStepAntiClockwiseSequence+0x498>
		__ticks = 1;
    1ef0:	81 e0       	ldi	r24, 0x01	; 1
    1ef2:	90 e0       	ldi	r25, 0x00	; 0
    1ef4:	9e 83       	std	Y+6, r25	; 0x06
    1ef6:	8d 83       	std	Y+5, r24	; 0x05
    1ef8:	3f c0       	rjmp	.+126    	; 0x1f78 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x516>
	else if (__tmp > 65535)
    1efa:	6f 81       	ldd	r22, Y+7	; 0x07
    1efc:	78 85       	ldd	r23, Y+8	; 0x08
    1efe:	89 85       	ldd	r24, Y+9	; 0x09
    1f00:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f02:	20 e0       	ldi	r18, 0x00	; 0
    1f04:	3f ef       	ldi	r19, 0xFF	; 255
    1f06:	4f e7       	ldi	r20, 0x7F	; 127
    1f08:	57 e4       	ldi	r21, 0x47	; 71
    1f0a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1f0e:	18 16       	cp	r1, r24
    1f10:	4c f5       	brge	.+82     	; 0x1f64 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x502>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f12:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f14:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f16:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f18:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f1a:	20 e0       	ldi	r18, 0x00	; 0
    1f1c:	30 e0       	ldi	r19, 0x00	; 0
    1f1e:	40 e2       	ldi	r20, 0x20	; 32
    1f20:	51 e4       	ldi	r21, 0x41	; 65
    1f22:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f26:	dc 01       	movw	r26, r24
    1f28:	cb 01       	movw	r24, r22
    1f2a:	bc 01       	movw	r22, r24
    1f2c:	cd 01       	movw	r24, r26
    1f2e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f32:	dc 01       	movw	r26, r24
    1f34:	cb 01       	movw	r24, r22
    1f36:	9e 83       	std	Y+6, r25	; 0x06
    1f38:	8d 83       	std	Y+5, r24	; 0x05
    1f3a:	0f c0       	rjmp	.+30     	; 0x1f5a <HSTEPPER_VidFullStepAntiClockwiseSequence+0x4f8>
    1f3c:	88 ec       	ldi	r24, 0xC8	; 200
    1f3e:	90 e0       	ldi	r25, 0x00	; 0
    1f40:	9c 83       	std	Y+4, r25	; 0x04
    1f42:	8b 83       	std	Y+3, r24	; 0x03
    1f44:	8b 81       	ldd	r24, Y+3	; 0x03
    1f46:	9c 81       	ldd	r25, Y+4	; 0x04
    1f48:	01 97       	sbiw	r24, 0x01	; 1
    1f4a:	f1 f7       	brne	.-4      	; 0x1f48 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x4e6>
    1f4c:	9c 83       	std	Y+4, r25	; 0x04
    1f4e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f50:	8d 81       	ldd	r24, Y+5	; 0x05
    1f52:	9e 81       	ldd	r25, Y+6	; 0x06
    1f54:	01 97       	sbiw	r24, 0x01	; 1
    1f56:	9e 83       	std	Y+6, r25	; 0x06
    1f58:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f5a:	8d 81       	ldd	r24, Y+5	; 0x05
    1f5c:	9e 81       	ldd	r25, Y+6	; 0x06
    1f5e:	00 97       	sbiw	r24, 0x00	; 0
    1f60:	69 f7       	brne	.-38     	; 0x1f3c <HSTEPPER_VidFullStepAntiClockwiseSequence+0x4da>
    1f62:	14 c0       	rjmp	.+40     	; 0x1f8c <HSTEPPER_VidFullStepAntiClockwiseSequence+0x52a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1f64:	6f 81       	ldd	r22, Y+7	; 0x07
    1f66:	78 85       	ldd	r23, Y+8	; 0x08
    1f68:	89 85       	ldd	r24, Y+9	; 0x09
    1f6a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f6c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f70:	dc 01       	movw	r26, r24
    1f72:	cb 01       	movw	r24, r22
    1f74:	9e 83       	std	Y+6, r25	; 0x06
    1f76:	8d 83       	std	Y+5, r24	; 0x05
    1f78:	8d 81       	ldd	r24, Y+5	; 0x05
    1f7a:	9e 81       	ldd	r25, Y+6	; 0x06
    1f7c:	9a 83       	std	Y+2, r25	; 0x02
    1f7e:	89 83       	std	Y+1, r24	; 0x01
    1f80:	89 81       	ldd	r24, Y+1	; 0x01
    1f82:	9a 81       	ldd	r25, Y+2	; 0x02
    1f84:	01 97       	sbiw	r24, 0x01	; 1
    1f86:	f1 f7       	brne	.-4      	; 0x1f84 <HSTEPPER_VidFullStepAntiClockwiseSequence+0x522>
    1f88:	9a 83       	std	Y+2, r25	; 0x02
    1f8a:	89 83       	std	Y+1, r24	; 0x01
	{
		/*Do Nothing*/
		}


}
    1f8c:	eb 96       	adiw	r28, 0x3b	; 59
    1f8e:	0f b6       	in	r0, 0x3f	; 63
    1f90:	f8 94       	cli
    1f92:	de bf       	out	0x3e, r29	; 62
    1f94:	0f be       	out	0x3f, r0	; 63
    1f96:	cd bf       	out	0x3d, r28	; 61
    1f98:	cf 91       	pop	r28
    1f9a:	df 91       	pop	r29
    1f9c:	08 95       	ret

00001f9e <HSTEPPER_VidFullStepClockwiseSequence>:

void HSTEPPER_VidFullStepClockwiseSequence (STEPPER_t * Copy_Stepper , u8 Copy_u8TimeDelay)
{
    1f9e:	df 93       	push	r29
    1fa0:	cf 93       	push	r28
    1fa2:	cd b7       	in	r28, 0x3d	; 61
    1fa4:	de b7       	in	r29, 0x3e	; 62
    1fa6:	eb 97       	sbiw	r28, 0x3b	; 59
    1fa8:	0f b6       	in	r0, 0x3f	; 63
    1faa:	f8 94       	cli
    1fac:	de bf       	out	0x3e, r29	; 62
    1fae:	0f be       	out	0x3f, r0	; 63
    1fb0:	cd bf       	out	0x3d, r28	; 61
    1fb2:	9a af       	std	Y+58, r25	; 0x3a
    1fb4:	89 af       	std	Y+57, r24	; 0x39
    1fb6:	6b af       	std	Y+59, r22	; 0x3b
	if (Copy_u8TimeDelay >=1)
    1fb8:	8b ad       	ldd	r24, Y+59	; 0x3b
    1fba:	88 23       	and	r24, r24
    1fbc:	09 f4       	brne	.+2      	; 0x1fc0 <HSTEPPER_VidFullStepClockwiseSequence+0x22>
    1fbe:	84 c2       	rjmp	.+1288   	; 0x24c8 <HSTEPPER_VidFullStepClockwiseSequence+0x52a>
	{
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin1,Copy_Stepper->Copy_u8Pin1Port,PIN_HIGH);
    1fc0:	e9 ad       	ldd	r30, Y+57	; 0x39
    1fc2:	fa ad       	ldd	r31, Y+58	; 0x3a
    1fc4:	80 81       	ld	r24, Z
    1fc6:	e9 ad       	ldd	r30, Y+57	; 0x39
    1fc8:	fa ad       	ldd	r31, Y+58	; 0x3a
    1fca:	91 81       	ldd	r25, Z+1	; 0x01
    1fcc:	69 2f       	mov	r22, r25
    1fce:	41 e0       	ldi	r20, 0x01	; 1
    1fd0:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin2,Copy_Stepper->Copy_u8Pin2Port,PIN_HIGH);
    1fd4:	e9 ad       	ldd	r30, Y+57	; 0x39
    1fd6:	fa ad       	ldd	r31, Y+58	; 0x3a
    1fd8:	82 81       	ldd	r24, Z+2	; 0x02
    1fda:	e9 ad       	ldd	r30, Y+57	; 0x39
    1fdc:	fa ad       	ldd	r31, Y+58	; 0x3a
    1fde:	93 81       	ldd	r25, Z+3	; 0x03
    1fe0:	69 2f       	mov	r22, r25
    1fe2:	41 e0       	ldi	r20, 0x01	; 1
    1fe4:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin3,Copy_Stepper->Copy_u8Pin3Port,PIN_HIGH);
    1fe8:	e9 ad       	ldd	r30, Y+57	; 0x39
    1fea:	fa ad       	ldd	r31, Y+58	; 0x3a
    1fec:	84 81       	ldd	r24, Z+4	; 0x04
    1fee:	e9 ad       	ldd	r30, Y+57	; 0x39
    1ff0:	fa ad       	ldd	r31, Y+58	; 0x3a
    1ff2:	95 81       	ldd	r25, Z+5	; 0x05
    1ff4:	69 2f       	mov	r22, r25
    1ff6:	41 e0       	ldi	r20, 0x01	; 1
    1ff8:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin4,Copy_Stepper->Copy_u8Pin4Port,PIN_LOW);
    1ffc:	e9 ad       	ldd	r30, Y+57	; 0x39
    1ffe:	fa ad       	ldd	r31, Y+58	; 0x3a
    2000:	86 81       	ldd	r24, Z+6	; 0x06
    2002:	e9 ad       	ldd	r30, Y+57	; 0x39
    2004:	fa ad       	ldd	r31, Y+58	; 0x3a
    2006:	97 81       	ldd	r25, Z+7	; 0x07
    2008:	69 2f       	mov	r22, r25
    200a:	40 e0       	ldi	r20, 0x00	; 0
    200c:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		_delay_ms(Copy_u8TimeDelay);
    2010:	8b ad       	ldd	r24, Y+59	; 0x3b
    2012:	88 2f       	mov	r24, r24
    2014:	90 e0       	ldi	r25, 0x00	; 0
    2016:	a0 e0       	ldi	r26, 0x00	; 0
    2018:	b0 e0       	ldi	r27, 0x00	; 0
    201a:	bc 01       	movw	r22, r24
    201c:	cd 01       	movw	r24, r26
    201e:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    2022:	dc 01       	movw	r26, r24
    2024:	cb 01       	movw	r24, r22
    2026:	8d ab       	std	Y+53, r24	; 0x35
    2028:	9e ab       	std	Y+54, r25	; 0x36
    202a:	af ab       	std	Y+55, r26	; 0x37
    202c:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    202e:	6d a9       	ldd	r22, Y+53	; 0x35
    2030:	7e a9       	ldd	r23, Y+54	; 0x36
    2032:	8f a9       	ldd	r24, Y+55	; 0x37
    2034:	98 ad       	ldd	r25, Y+56	; 0x38
    2036:	20 e0       	ldi	r18, 0x00	; 0
    2038:	30 e0       	ldi	r19, 0x00	; 0
    203a:	4a ef       	ldi	r20, 0xFA	; 250
    203c:	54 e4       	ldi	r21, 0x44	; 68
    203e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2042:	dc 01       	movw	r26, r24
    2044:	cb 01       	movw	r24, r22
    2046:	89 ab       	std	Y+49, r24	; 0x31
    2048:	9a ab       	std	Y+50, r25	; 0x32
    204a:	ab ab       	std	Y+51, r26	; 0x33
    204c:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    204e:	69 a9       	ldd	r22, Y+49	; 0x31
    2050:	7a a9       	ldd	r23, Y+50	; 0x32
    2052:	8b a9       	ldd	r24, Y+51	; 0x33
    2054:	9c a9       	ldd	r25, Y+52	; 0x34
    2056:	20 e0       	ldi	r18, 0x00	; 0
    2058:	30 e0       	ldi	r19, 0x00	; 0
    205a:	40 e8       	ldi	r20, 0x80	; 128
    205c:	5f e3       	ldi	r21, 0x3F	; 63
    205e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2062:	88 23       	and	r24, r24
    2064:	2c f4       	brge	.+10     	; 0x2070 <HSTEPPER_VidFullStepClockwiseSequence+0xd2>
		__ticks = 1;
    2066:	81 e0       	ldi	r24, 0x01	; 1
    2068:	90 e0       	ldi	r25, 0x00	; 0
    206a:	98 ab       	std	Y+48, r25	; 0x30
    206c:	8f a7       	std	Y+47, r24	; 0x2f
    206e:	3f c0       	rjmp	.+126    	; 0x20ee <HSTEPPER_VidFullStepClockwiseSequence+0x150>
	else if (__tmp > 65535)
    2070:	69 a9       	ldd	r22, Y+49	; 0x31
    2072:	7a a9       	ldd	r23, Y+50	; 0x32
    2074:	8b a9       	ldd	r24, Y+51	; 0x33
    2076:	9c a9       	ldd	r25, Y+52	; 0x34
    2078:	20 e0       	ldi	r18, 0x00	; 0
    207a:	3f ef       	ldi	r19, 0xFF	; 255
    207c:	4f e7       	ldi	r20, 0x7F	; 127
    207e:	57 e4       	ldi	r21, 0x47	; 71
    2080:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2084:	18 16       	cp	r1, r24
    2086:	4c f5       	brge	.+82     	; 0x20da <HSTEPPER_VidFullStepClockwiseSequence+0x13c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2088:	6d a9       	ldd	r22, Y+53	; 0x35
    208a:	7e a9       	ldd	r23, Y+54	; 0x36
    208c:	8f a9       	ldd	r24, Y+55	; 0x37
    208e:	98 ad       	ldd	r25, Y+56	; 0x38
    2090:	20 e0       	ldi	r18, 0x00	; 0
    2092:	30 e0       	ldi	r19, 0x00	; 0
    2094:	40 e2       	ldi	r20, 0x20	; 32
    2096:	51 e4       	ldi	r21, 0x41	; 65
    2098:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    209c:	dc 01       	movw	r26, r24
    209e:	cb 01       	movw	r24, r22
    20a0:	bc 01       	movw	r22, r24
    20a2:	cd 01       	movw	r24, r26
    20a4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    20a8:	dc 01       	movw	r26, r24
    20aa:	cb 01       	movw	r24, r22
    20ac:	98 ab       	std	Y+48, r25	; 0x30
    20ae:	8f a7       	std	Y+47, r24	; 0x2f
    20b0:	0f c0       	rjmp	.+30     	; 0x20d0 <HSTEPPER_VidFullStepClockwiseSequence+0x132>
    20b2:	88 ec       	ldi	r24, 0xC8	; 200
    20b4:	90 e0       	ldi	r25, 0x00	; 0
    20b6:	9e a7       	std	Y+46, r25	; 0x2e
    20b8:	8d a7       	std	Y+45, r24	; 0x2d
    20ba:	8d a5       	ldd	r24, Y+45	; 0x2d
    20bc:	9e a5       	ldd	r25, Y+46	; 0x2e
    20be:	01 97       	sbiw	r24, 0x01	; 1
    20c0:	f1 f7       	brne	.-4      	; 0x20be <HSTEPPER_VidFullStepClockwiseSequence+0x120>
    20c2:	9e a7       	std	Y+46, r25	; 0x2e
    20c4:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    20c6:	8f a5       	ldd	r24, Y+47	; 0x2f
    20c8:	98 a9       	ldd	r25, Y+48	; 0x30
    20ca:	01 97       	sbiw	r24, 0x01	; 1
    20cc:	98 ab       	std	Y+48, r25	; 0x30
    20ce:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    20d0:	8f a5       	ldd	r24, Y+47	; 0x2f
    20d2:	98 a9       	ldd	r25, Y+48	; 0x30
    20d4:	00 97       	sbiw	r24, 0x00	; 0
    20d6:	69 f7       	brne	.-38     	; 0x20b2 <HSTEPPER_VidFullStepClockwiseSequence+0x114>
    20d8:	14 c0       	rjmp	.+40     	; 0x2102 <HSTEPPER_VidFullStepClockwiseSequence+0x164>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    20da:	69 a9       	ldd	r22, Y+49	; 0x31
    20dc:	7a a9       	ldd	r23, Y+50	; 0x32
    20de:	8b a9       	ldd	r24, Y+51	; 0x33
    20e0:	9c a9       	ldd	r25, Y+52	; 0x34
    20e2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    20e6:	dc 01       	movw	r26, r24
    20e8:	cb 01       	movw	r24, r22
    20ea:	98 ab       	std	Y+48, r25	; 0x30
    20ec:	8f a7       	std	Y+47, r24	; 0x2f
    20ee:	8f a5       	ldd	r24, Y+47	; 0x2f
    20f0:	98 a9       	ldd	r25, Y+48	; 0x30
    20f2:	9c a7       	std	Y+44, r25	; 0x2c
    20f4:	8b a7       	std	Y+43, r24	; 0x2b
    20f6:	8b a5       	ldd	r24, Y+43	; 0x2b
    20f8:	9c a5       	ldd	r25, Y+44	; 0x2c
    20fa:	01 97       	sbiw	r24, 0x01	; 1
    20fc:	f1 f7       	brne	.-4      	; 0x20fa <HSTEPPER_VidFullStepClockwiseSequence+0x15c>
    20fe:	9c a7       	std	Y+44, r25	; 0x2c
    2100:	8b a7       	std	Y+43, r24	; 0x2b

		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin1,Copy_Stepper->Copy_u8Pin1Port,PIN_HIGH);
    2102:	e9 ad       	ldd	r30, Y+57	; 0x39
    2104:	fa ad       	ldd	r31, Y+58	; 0x3a
    2106:	80 81       	ld	r24, Z
    2108:	e9 ad       	ldd	r30, Y+57	; 0x39
    210a:	fa ad       	ldd	r31, Y+58	; 0x3a
    210c:	91 81       	ldd	r25, Z+1	; 0x01
    210e:	69 2f       	mov	r22, r25
    2110:	41 e0       	ldi	r20, 0x01	; 1
    2112:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin2,Copy_Stepper->Copy_u8Pin2Port,PIN_HIGH);
    2116:	e9 ad       	ldd	r30, Y+57	; 0x39
    2118:	fa ad       	ldd	r31, Y+58	; 0x3a
    211a:	82 81       	ldd	r24, Z+2	; 0x02
    211c:	e9 ad       	ldd	r30, Y+57	; 0x39
    211e:	fa ad       	ldd	r31, Y+58	; 0x3a
    2120:	93 81       	ldd	r25, Z+3	; 0x03
    2122:	69 2f       	mov	r22, r25
    2124:	41 e0       	ldi	r20, 0x01	; 1
    2126:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin3,Copy_Stepper->Copy_u8Pin3Port,PIN_LOW);
    212a:	e9 ad       	ldd	r30, Y+57	; 0x39
    212c:	fa ad       	ldd	r31, Y+58	; 0x3a
    212e:	84 81       	ldd	r24, Z+4	; 0x04
    2130:	e9 ad       	ldd	r30, Y+57	; 0x39
    2132:	fa ad       	ldd	r31, Y+58	; 0x3a
    2134:	95 81       	ldd	r25, Z+5	; 0x05
    2136:	69 2f       	mov	r22, r25
    2138:	40 e0       	ldi	r20, 0x00	; 0
    213a:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin4,Copy_Stepper->Copy_u8Pin4Port,PIN_HIGH);
    213e:	e9 ad       	ldd	r30, Y+57	; 0x39
    2140:	fa ad       	ldd	r31, Y+58	; 0x3a
    2142:	86 81       	ldd	r24, Z+6	; 0x06
    2144:	e9 ad       	ldd	r30, Y+57	; 0x39
    2146:	fa ad       	ldd	r31, Y+58	; 0x3a
    2148:	97 81       	ldd	r25, Z+7	; 0x07
    214a:	69 2f       	mov	r22, r25
    214c:	41 e0       	ldi	r20, 0x01	; 1
    214e:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		_delay_ms(Copy_u8TimeDelay);
    2152:	8b ad       	ldd	r24, Y+59	; 0x3b
    2154:	88 2f       	mov	r24, r24
    2156:	90 e0       	ldi	r25, 0x00	; 0
    2158:	a0 e0       	ldi	r26, 0x00	; 0
    215a:	b0 e0       	ldi	r27, 0x00	; 0
    215c:	bc 01       	movw	r22, r24
    215e:	cd 01       	movw	r24, r26
    2160:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    2164:	dc 01       	movw	r26, r24
    2166:	cb 01       	movw	r24, r22
    2168:	8f a3       	std	Y+39, r24	; 0x27
    216a:	98 a7       	std	Y+40, r25	; 0x28
    216c:	a9 a7       	std	Y+41, r26	; 0x29
    216e:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2170:	6f a1       	ldd	r22, Y+39	; 0x27
    2172:	78 a5       	ldd	r23, Y+40	; 0x28
    2174:	89 a5       	ldd	r24, Y+41	; 0x29
    2176:	9a a5       	ldd	r25, Y+42	; 0x2a
    2178:	20 e0       	ldi	r18, 0x00	; 0
    217a:	30 e0       	ldi	r19, 0x00	; 0
    217c:	4a ef       	ldi	r20, 0xFA	; 250
    217e:	54 e4       	ldi	r21, 0x44	; 68
    2180:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2184:	dc 01       	movw	r26, r24
    2186:	cb 01       	movw	r24, r22
    2188:	8b a3       	std	Y+35, r24	; 0x23
    218a:	9c a3       	std	Y+36, r25	; 0x24
    218c:	ad a3       	std	Y+37, r26	; 0x25
    218e:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2190:	6b a1       	ldd	r22, Y+35	; 0x23
    2192:	7c a1       	ldd	r23, Y+36	; 0x24
    2194:	8d a1       	ldd	r24, Y+37	; 0x25
    2196:	9e a1       	ldd	r25, Y+38	; 0x26
    2198:	20 e0       	ldi	r18, 0x00	; 0
    219a:	30 e0       	ldi	r19, 0x00	; 0
    219c:	40 e8       	ldi	r20, 0x80	; 128
    219e:	5f e3       	ldi	r21, 0x3F	; 63
    21a0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    21a4:	88 23       	and	r24, r24
    21a6:	2c f4       	brge	.+10     	; 0x21b2 <HSTEPPER_VidFullStepClockwiseSequence+0x214>
		__ticks = 1;
    21a8:	81 e0       	ldi	r24, 0x01	; 1
    21aa:	90 e0       	ldi	r25, 0x00	; 0
    21ac:	9a a3       	std	Y+34, r25	; 0x22
    21ae:	89 a3       	std	Y+33, r24	; 0x21
    21b0:	3f c0       	rjmp	.+126    	; 0x2230 <HSTEPPER_VidFullStepClockwiseSequence+0x292>
	else if (__tmp > 65535)
    21b2:	6b a1       	ldd	r22, Y+35	; 0x23
    21b4:	7c a1       	ldd	r23, Y+36	; 0x24
    21b6:	8d a1       	ldd	r24, Y+37	; 0x25
    21b8:	9e a1       	ldd	r25, Y+38	; 0x26
    21ba:	20 e0       	ldi	r18, 0x00	; 0
    21bc:	3f ef       	ldi	r19, 0xFF	; 255
    21be:	4f e7       	ldi	r20, 0x7F	; 127
    21c0:	57 e4       	ldi	r21, 0x47	; 71
    21c2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    21c6:	18 16       	cp	r1, r24
    21c8:	4c f5       	brge	.+82     	; 0x221c <HSTEPPER_VidFullStepClockwiseSequence+0x27e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    21ca:	6f a1       	ldd	r22, Y+39	; 0x27
    21cc:	78 a5       	ldd	r23, Y+40	; 0x28
    21ce:	89 a5       	ldd	r24, Y+41	; 0x29
    21d0:	9a a5       	ldd	r25, Y+42	; 0x2a
    21d2:	20 e0       	ldi	r18, 0x00	; 0
    21d4:	30 e0       	ldi	r19, 0x00	; 0
    21d6:	40 e2       	ldi	r20, 0x20	; 32
    21d8:	51 e4       	ldi	r21, 0x41	; 65
    21da:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21de:	dc 01       	movw	r26, r24
    21e0:	cb 01       	movw	r24, r22
    21e2:	bc 01       	movw	r22, r24
    21e4:	cd 01       	movw	r24, r26
    21e6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21ea:	dc 01       	movw	r26, r24
    21ec:	cb 01       	movw	r24, r22
    21ee:	9a a3       	std	Y+34, r25	; 0x22
    21f0:	89 a3       	std	Y+33, r24	; 0x21
    21f2:	0f c0       	rjmp	.+30     	; 0x2212 <HSTEPPER_VidFullStepClockwiseSequence+0x274>
    21f4:	88 ec       	ldi	r24, 0xC8	; 200
    21f6:	90 e0       	ldi	r25, 0x00	; 0
    21f8:	98 a3       	std	Y+32, r25	; 0x20
    21fa:	8f 8f       	std	Y+31, r24	; 0x1f
    21fc:	8f 8d       	ldd	r24, Y+31	; 0x1f
    21fe:	98 a1       	ldd	r25, Y+32	; 0x20
    2200:	01 97       	sbiw	r24, 0x01	; 1
    2202:	f1 f7       	brne	.-4      	; 0x2200 <HSTEPPER_VidFullStepClockwiseSequence+0x262>
    2204:	98 a3       	std	Y+32, r25	; 0x20
    2206:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2208:	89 a1       	ldd	r24, Y+33	; 0x21
    220a:	9a a1       	ldd	r25, Y+34	; 0x22
    220c:	01 97       	sbiw	r24, 0x01	; 1
    220e:	9a a3       	std	Y+34, r25	; 0x22
    2210:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2212:	89 a1       	ldd	r24, Y+33	; 0x21
    2214:	9a a1       	ldd	r25, Y+34	; 0x22
    2216:	00 97       	sbiw	r24, 0x00	; 0
    2218:	69 f7       	brne	.-38     	; 0x21f4 <HSTEPPER_VidFullStepClockwiseSequence+0x256>
    221a:	14 c0       	rjmp	.+40     	; 0x2244 <HSTEPPER_VidFullStepClockwiseSequence+0x2a6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    221c:	6b a1       	ldd	r22, Y+35	; 0x23
    221e:	7c a1       	ldd	r23, Y+36	; 0x24
    2220:	8d a1       	ldd	r24, Y+37	; 0x25
    2222:	9e a1       	ldd	r25, Y+38	; 0x26
    2224:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2228:	dc 01       	movw	r26, r24
    222a:	cb 01       	movw	r24, r22
    222c:	9a a3       	std	Y+34, r25	; 0x22
    222e:	89 a3       	std	Y+33, r24	; 0x21
    2230:	89 a1       	ldd	r24, Y+33	; 0x21
    2232:	9a a1       	ldd	r25, Y+34	; 0x22
    2234:	9e 8f       	std	Y+30, r25	; 0x1e
    2236:	8d 8f       	std	Y+29, r24	; 0x1d
    2238:	8d 8d       	ldd	r24, Y+29	; 0x1d
    223a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    223c:	01 97       	sbiw	r24, 0x01	; 1
    223e:	f1 f7       	brne	.-4      	; 0x223c <HSTEPPER_VidFullStepClockwiseSequence+0x29e>
    2240:	9e 8f       	std	Y+30, r25	; 0x1e
    2242:	8d 8f       	std	Y+29, r24	; 0x1d

		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin1,Copy_Stepper->Copy_u8Pin1Port,PIN_HIGH);
    2244:	e9 ad       	ldd	r30, Y+57	; 0x39
    2246:	fa ad       	ldd	r31, Y+58	; 0x3a
    2248:	80 81       	ld	r24, Z
    224a:	e9 ad       	ldd	r30, Y+57	; 0x39
    224c:	fa ad       	ldd	r31, Y+58	; 0x3a
    224e:	91 81       	ldd	r25, Z+1	; 0x01
    2250:	69 2f       	mov	r22, r25
    2252:	41 e0       	ldi	r20, 0x01	; 1
    2254:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin2,Copy_Stepper->Copy_u8Pin2Port,PIN_LOW);
    2258:	e9 ad       	ldd	r30, Y+57	; 0x39
    225a:	fa ad       	ldd	r31, Y+58	; 0x3a
    225c:	82 81       	ldd	r24, Z+2	; 0x02
    225e:	e9 ad       	ldd	r30, Y+57	; 0x39
    2260:	fa ad       	ldd	r31, Y+58	; 0x3a
    2262:	93 81       	ldd	r25, Z+3	; 0x03
    2264:	69 2f       	mov	r22, r25
    2266:	40 e0       	ldi	r20, 0x00	; 0
    2268:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin3,Copy_Stepper->Copy_u8Pin3Port,PIN_HIGH);
    226c:	e9 ad       	ldd	r30, Y+57	; 0x39
    226e:	fa ad       	ldd	r31, Y+58	; 0x3a
    2270:	84 81       	ldd	r24, Z+4	; 0x04
    2272:	e9 ad       	ldd	r30, Y+57	; 0x39
    2274:	fa ad       	ldd	r31, Y+58	; 0x3a
    2276:	95 81       	ldd	r25, Z+5	; 0x05
    2278:	69 2f       	mov	r22, r25
    227a:	41 e0       	ldi	r20, 0x01	; 1
    227c:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin4,Copy_Stepper->Copy_u8Pin4Port,PIN_HIGH);
    2280:	e9 ad       	ldd	r30, Y+57	; 0x39
    2282:	fa ad       	ldd	r31, Y+58	; 0x3a
    2284:	86 81       	ldd	r24, Z+6	; 0x06
    2286:	e9 ad       	ldd	r30, Y+57	; 0x39
    2288:	fa ad       	ldd	r31, Y+58	; 0x3a
    228a:	97 81       	ldd	r25, Z+7	; 0x07
    228c:	69 2f       	mov	r22, r25
    228e:	41 e0       	ldi	r20, 0x01	; 1
    2290:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		_delay_ms(Copy_u8TimeDelay);
    2294:	8b ad       	ldd	r24, Y+59	; 0x3b
    2296:	88 2f       	mov	r24, r24
    2298:	90 e0       	ldi	r25, 0x00	; 0
    229a:	a0 e0       	ldi	r26, 0x00	; 0
    229c:	b0 e0       	ldi	r27, 0x00	; 0
    229e:	bc 01       	movw	r22, r24
    22a0:	cd 01       	movw	r24, r26
    22a2:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    22a6:	dc 01       	movw	r26, r24
    22a8:	cb 01       	movw	r24, r22
    22aa:	89 8f       	std	Y+25, r24	; 0x19
    22ac:	9a 8f       	std	Y+26, r25	; 0x1a
    22ae:	ab 8f       	std	Y+27, r26	; 0x1b
    22b0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    22b2:	69 8d       	ldd	r22, Y+25	; 0x19
    22b4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    22b6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    22b8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    22ba:	20 e0       	ldi	r18, 0x00	; 0
    22bc:	30 e0       	ldi	r19, 0x00	; 0
    22be:	4a ef       	ldi	r20, 0xFA	; 250
    22c0:	54 e4       	ldi	r21, 0x44	; 68
    22c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22c6:	dc 01       	movw	r26, r24
    22c8:	cb 01       	movw	r24, r22
    22ca:	8d 8b       	std	Y+21, r24	; 0x15
    22cc:	9e 8b       	std	Y+22, r25	; 0x16
    22ce:	af 8b       	std	Y+23, r26	; 0x17
    22d0:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    22d2:	6d 89       	ldd	r22, Y+21	; 0x15
    22d4:	7e 89       	ldd	r23, Y+22	; 0x16
    22d6:	8f 89       	ldd	r24, Y+23	; 0x17
    22d8:	98 8d       	ldd	r25, Y+24	; 0x18
    22da:	20 e0       	ldi	r18, 0x00	; 0
    22dc:	30 e0       	ldi	r19, 0x00	; 0
    22de:	40 e8       	ldi	r20, 0x80	; 128
    22e0:	5f e3       	ldi	r21, 0x3F	; 63
    22e2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    22e6:	88 23       	and	r24, r24
    22e8:	2c f4       	brge	.+10     	; 0x22f4 <HSTEPPER_VidFullStepClockwiseSequence+0x356>
		__ticks = 1;
    22ea:	81 e0       	ldi	r24, 0x01	; 1
    22ec:	90 e0       	ldi	r25, 0x00	; 0
    22ee:	9c 8b       	std	Y+20, r25	; 0x14
    22f0:	8b 8b       	std	Y+19, r24	; 0x13
    22f2:	3f c0       	rjmp	.+126    	; 0x2372 <HSTEPPER_VidFullStepClockwiseSequence+0x3d4>
	else if (__tmp > 65535)
    22f4:	6d 89       	ldd	r22, Y+21	; 0x15
    22f6:	7e 89       	ldd	r23, Y+22	; 0x16
    22f8:	8f 89       	ldd	r24, Y+23	; 0x17
    22fa:	98 8d       	ldd	r25, Y+24	; 0x18
    22fc:	20 e0       	ldi	r18, 0x00	; 0
    22fe:	3f ef       	ldi	r19, 0xFF	; 255
    2300:	4f e7       	ldi	r20, 0x7F	; 127
    2302:	57 e4       	ldi	r21, 0x47	; 71
    2304:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2308:	18 16       	cp	r1, r24
    230a:	4c f5       	brge	.+82     	; 0x235e <HSTEPPER_VidFullStepClockwiseSequence+0x3c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    230c:	69 8d       	ldd	r22, Y+25	; 0x19
    230e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2310:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2312:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2314:	20 e0       	ldi	r18, 0x00	; 0
    2316:	30 e0       	ldi	r19, 0x00	; 0
    2318:	40 e2       	ldi	r20, 0x20	; 32
    231a:	51 e4       	ldi	r21, 0x41	; 65
    231c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2320:	dc 01       	movw	r26, r24
    2322:	cb 01       	movw	r24, r22
    2324:	bc 01       	movw	r22, r24
    2326:	cd 01       	movw	r24, r26
    2328:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    232c:	dc 01       	movw	r26, r24
    232e:	cb 01       	movw	r24, r22
    2330:	9c 8b       	std	Y+20, r25	; 0x14
    2332:	8b 8b       	std	Y+19, r24	; 0x13
    2334:	0f c0       	rjmp	.+30     	; 0x2354 <HSTEPPER_VidFullStepClockwiseSequence+0x3b6>
    2336:	88 ec       	ldi	r24, 0xC8	; 200
    2338:	90 e0       	ldi	r25, 0x00	; 0
    233a:	9a 8b       	std	Y+18, r25	; 0x12
    233c:	89 8b       	std	Y+17, r24	; 0x11
    233e:	89 89       	ldd	r24, Y+17	; 0x11
    2340:	9a 89       	ldd	r25, Y+18	; 0x12
    2342:	01 97       	sbiw	r24, 0x01	; 1
    2344:	f1 f7       	brne	.-4      	; 0x2342 <HSTEPPER_VidFullStepClockwiseSequence+0x3a4>
    2346:	9a 8b       	std	Y+18, r25	; 0x12
    2348:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    234a:	8b 89       	ldd	r24, Y+19	; 0x13
    234c:	9c 89       	ldd	r25, Y+20	; 0x14
    234e:	01 97       	sbiw	r24, 0x01	; 1
    2350:	9c 8b       	std	Y+20, r25	; 0x14
    2352:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2354:	8b 89       	ldd	r24, Y+19	; 0x13
    2356:	9c 89       	ldd	r25, Y+20	; 0x14
    2358:	00 97       	sbiw	r24, 0x00	; 0
    235a:	69 f7       	brne	.-38     	; 0x2336 <HSTEPPER_VidFullStepClockwiseSequence+0x398>
    235c:	14 c0       	rjmp	.+40     	; 0x2386 <HSTEPPER_VidFullStepClockwiseSequence+0x3e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    235e:	6d 89       	ldd	r22, Y+21	; 0x15
    2360:	7e 89       	ldd	r23, Y+22	; 0x16
    2362:	8f 89       	ldd	r24, Y+23	; 0x17
    2364:	98 8d       	ldd	r25, Y+24	; 0x18
    2366:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    236a:	dc 01       	movw	r26, r24
    236c:	cb 01       	movw	r24, r22
    236e:	9c 8b       	std	Y+20, r25	; 0x14
    2370:	8b 8b       	std	Y+19, r24	; 0x13
    2372:	8b 89       	ldd	r24, Y+19	; 0x13
    2374:	9c 89       	ldd	r25, Y+20	; 0x14
    2376:	98 8b       	std	Y+16, r25	; 0x10
    2378:	8f 87       	std	Y+15, r24	; 0x0f
    237a:	8f 85       	ldd	r24, Y+15	; 0x0f
    237c:	98 89       	ldd	r25, Y+16	; 0x10
    237e:	01 97       	sbiw	r24, 0x01	; 1
    2380:	f1 f7       	brne	.-4      	; 0x237e <HSTEPPER_VidFullStepClockwiseSequence+0x3e0>
    2382:	98 8b       	std	Y+16, r25	; 0x10
    2384:	8f 87       	std	Y+15, r24	; 0x0f

		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin1,Copy_Stepper->Copy_u8Pin1Port,PIN_LOW);
    2386:	e9 ad       	ldd	r30, Y+57	; 0x39
    2388:	fa ad       	ldd	r31, Y+58	; 0x3a
    238a:	80 81       	ld	r24, Z
    238c:	e9 ad       	ldd	r30, Y+57	; 0x39
    238e:	fa ad       	ldd	r31, Y+58	; 0x3a
    2390:	91 81       	ldd	r25, Z+1	; 0x01
    2392:	69 2f       	mov	r22, r25
    2394:	40 e0       	ldi	r20, 0x00	; 0
    2396:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin2,Copy_Stepper->Copy_u8Pin2Port,PIN_HIGH);
    239a:	e9 ad       	ldd	r30, Y+57	; 0x39
    239c:	fa ad       	ldd	r31, Y+58	; 0x3a
    239e:	82 81       	ldd	r24, Z+2	; 0x02
    23a0:	e9 ad       	ldd	r30, Y+57	; 0x39
    23a2:	fa ad       	ldd	r31, Y+58	; 0x3a
    23a4:	93 81       	ldd	r25, Z+3	; 0x03
    23a6:	69 2f       	mov	r22, r25
    23a8:	41 e0       	ldi	r20, 0x01	; 1
    23aa:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin3,Copy_Stepper->Copy_u8Pin3Port,PIN_HIGH);
    23ae:	e9 ad       	ldd	r30, Y+57	; 0x39
    23b0:	fa ad       	ldd	r31, Y+58	; 0x3a
    23b2:	84 81       	ldd	r24, Z+4	; 0x04
    23b4:	e9 ad       	ldd	r30, Y+57	; 0x39
    23b6:	fa ad       	ldd	r31, Y+58	; 0x3a
    23b8:	95 81       	ldd	r25, Z+5	; 0x05
    23ba:	69 2f       	mov	r22, r25
    23bc:	41 e0       	ldi	r20, 0x01	; 1
    23be:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin4,Copy_Stepper->Copy_u8Pin4Port,PIN_HIGH);
    23c2:	e9 ad       	ldd	r30, Y+57	; 0x39
    23c4:	fa ad       	ldd	r31, Y+58	; 0x3a
    23c6:	86 81       	ldd	r24, Z+6	; 0x06
    23c8:	e9 ad       	ldd	r30, Y+57	; 0x39
    23ca:	fa ad       	ldd	r31, Y+58	; 0x3a
    23cc:	97 81       	ldd	r25, Z+7	; 0x07
    23ce:	69 2f       	mov	r22, r25
    23d0:	41 e0       	ldi	r20, 0x01	; 1
    23d2:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		_delay_ms(Copy_u8TimeDelay);
    23d6:	8b ad       	ldd	r24, Y+59	; 0x3b
    23d8:	88 2f       	mov	r24, r24
    23da:	90 e0       	ldi	r25, 0x00	; 0
    23dc:	a0 e0       	ldi	r26, 0x00	; 0
    23de:	b0 e0       	ldi	r27, 0x00	; 0
    23e0:	bc 01       	movw	r22, r24
    23e2:	cd 01       	movw	r24, r26
    23e4:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    23e8:	dc 01       	movw	r26, r24
    23ea:	cb 01       	movw	r24, r22
    23ec:	8b 87       	std	Y+11, r24	; 0x0b
    23ee:	9c 87       	std	Y+12, r25	; 0x0c
    23f0:	ad 87       	std	Y+13, r26	; 0x0d
    23f2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    23f4:	6b 85       	ldd	r22, Y+11	; 0x0b
    23f6:	7c 85       	ldd	r23, Y+12	; 0x0c
    23f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    23fa:	9e 85       	ldd	r25, Y+14	; 0x0e
    23fc:	20 e0       	ldi	r18, 0x00	; 0
    23fe:	30 e0       	ldi	r19, 0x00	; 0
    2400:	4a ef       	ldi	r20, 0xFA	; 250
    2402:	54 e4       	ldi	r21, 0x44	; 68
    2404:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2408:	dc 01       	movw	r26, r24
    240a:	cb 01       	movw	r24, r22
    240c:	8f 83       	std	Y+7, r24	; 0x07
    240e:	98 87       	std	Y+8, r25	; 0x08
    2410:	a9 87       	std	Y+9, r26	; 0x09
    2412:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2414:	6f 81       	ldd	r22, Y+7	; 0x07
    2416:	78 85       	ldd	r23, Y+8	; 0x08
    2418:	89 85       	ldd	r24, Y+9	; 0x09
    241a:	9a 85       	ldd	r25, Y+10	; 0x0a
    241c:	20 e0       	ldi	r18, 0x00	; 0
    241e:	30 e0       	ldi	r19, 0x00	; 0
    2420:	40 e8       	ldi	r20, 0x80	; 128
    2422:	5f e3       	ldi	r21, 0x3F	; 63
    2424:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2428:	88 23       	and	r24, r24
    242a:	2c f4       	brge	.+10     	; 0x2436 <HSTEPPER_VidFullStepClockwiseSequence+0x498>
		__ticks = 1;
    242c:	81 e0       	ldi	r24, 0x01	; 1
    242e:	90 e0       	ldi	r25, 0x00	; 0
    2430:	9e 83       	std	Y+6, r25	; 0x06
    2432:	8d 83       	std	Y+5, r24	; 0x05
    2434:	3f c0       	rjmp	.+126    	; 0x24b4 <HSTEPPER_VidFullStepClockwiseSequence+0x516>
	else if (__tmp > 65535)
    2436:	6f 81       	ldd	r22, Y+7	; 0x07
    2438:	78 85       	ldd	r23, Y+8	; 0x08
    243a:	89 85       	ldd	r24, Y+9	; 0x09
    243c:	9a 85       	ldd	r25, Y+10	; 0x0a
    243e:	20 e0       	ldi	r18, 0x00	; 0
    2440:	3f ef       	ldi	r19, 0xFF	; 255
    2442:	4f e7       	ldi	r20, 0x7F	; 127
    2444:	57 e4       	ldi	r21, 0x47	; 71
    2446:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    244a:	18 16       	cp	r1, r24
    244c:	4c f5       	brge	.+82     	; 0x24a0 <HSTEPPER_VidFullStepClockwiseSequence+0x502>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    244e:	6b 85       	ldd	r22, Y+11	; 0x0b
    2450:	7c 85       	ldd	r23, Y+12	; 0x0c
    2452:	8d 85       	ldd	r24, Y+13	; 0x0d
    2454:	9e 85       	ldd	r25, Y+14	; 0x0e
    2456:	20 e0       	ldi	r18, 0x00	; 0
    2458:	30 e0       	ldi	r19, 0x00	; 0
    245a:	40 e2       	ldi	r20, 0x20	; 32
    245c:	51 e4       	ldi	r21, 0x41	; 65
    245e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2462:	dc 01       	movw	r26, r24
    2464:	cb 01       	movw	r24, r22
    2466:	bc 01       	movw	r22, r24
    2468:	cd 01       	movw	r24, r26
    246a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    246e:	dc 01       	movw	r26, r24
    2470:	cb 01       	movw	r24, r22
    2472:	9e 83       	std	Y+6, r25	; 0x06
    2474:	8d 83       	std	Y+5, r24	; 0x05
    2476:	0f c0       	rjmp	.+30     	; 0x2496 <HSTEPPER_VidFullStepClockwiseSequence+0x4f8>
    2478:	88 ec       	ldi	r24, 0xC8	; 200
    247a:	90 e0       	ldi	r25, 0x00	; 0
    247c:	9c 83       	std	Y+4, r25	; 0x04
    247e:	8b 83       	std	Y+3, r24	; 0x03
    2480:	8b 81       	ldd	r24, Y+3	; 0x03
    2482:	9c 81       	ldd	r25, Y+4	; 0x04
    2484:	01 97       	sbiw	r24, 0x01	; 1
    2486:	f1 f7       	brne	.-4      	; 0x2484 <HSTEPPER_VidFullStepClockwiseSequence+0x4e6>
    2488:	9c 83       	std	Y+4, r25	; 0x04
    248a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    248c:	8d 81       	ldd	r24, Y+5	; 0x05
    248e:	9e 81       	ldd	r25, Y+6	; 0x06
    2490:	01 97       	sbiw	r24, 0x01	; 1
    2492:	9e 83       	std	Y+6, r25	; 0x06
    2494:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2496:	8d 81       	ldd	r24, Y+5	; 0x05
    2498:	9e 81       	ldd	r25, Y+6	; 0x06
    249a:	00 97       	sbiw	r24, 0x00	; 0
    249c:	69 f7       	brne	.-38     	; 0x2478 <HSTEPPER_VidFullStepClockwiseSequence+0x4da>
    249e:	14 c0       	rjmp	.+40     	; 0x24c8 <HSTEPPER_VidFullStepClockwiseSequence+0x52a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    24a0:	6f 81       	ldd	r22, Y+7	; 0x07
    24a2:	78 85       	ldd	r23, Y+8	; 0x08
    24a4:	89 85       	ldd	r24, Y+9	; 0x09
    24a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    24a8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    24ac:	dc 01       	movw	r26, r24
    24ae:	cb 01       	movw	r24, r22
    24b0:	9e 83       	std	Y+6, r25	; 0x06
    24b2:	8d 83       	std	Y+5, r24	; 0x05
    24b4:	8d 81       	ldd	r24, Y+5	; 0x05
    24b6:	9e 81       	ldd	r25, Y+6	; 0x06
    24b8:	9a 83       	std	Y+2, r25	; 0x02
    24ba:	89 83       	std	Y+1, r24	; 0x01
    24bc:	89 81       	ldd	r24, Y+1	; 0x01
    24be:	9a 81       	ldd	r25, Y+2	; 0x02
    24c0:	01 97       	sbiw	r24, 0x01	; 1
    24c2:	f1 f7       	brne	.-4      	; 0x24c0 <HSTEPPER_VidFullStepClockwiseSequence+0x522>
    24c4:	9a 83       	std	Y+2, r25	; 0x02
    24c6:	89 83       	std	Y+1, r24	; 0x01


	}


}
    24c8:	eb 96       	adiw	r28, 0x3b	; 59
    24ca:	0f b6       	in	r0, 0x3f	; 63
    24cc:	f8 94       	cli
    24ce:	de bf       	out	0x3e, r29	; 62
    24d0:	0f be       	out	0x3f, r0	; 63
    24d2:	cd bf       	out	0x3d, r28	; 61
    24d4:	cf 91       	pop	r28
    24d6:	df 91       	pop	r29
    24d8:	08 95       	ret

000024da <HSTEPPER_VidStop>:

void HSTEPPER_VidStop (STEPPER_t * Copy_Stepper)
{
    24da:	df 93       	push	r29
    24dc:	cf 93       	push	r28
    24de:	00 d0       	rcall	.+0      	; 0x24e0 <HSTEPPER_VidStop+0x6>
    24e0:	cd b7       	in	r28, 0x3d	; 61
    24e2:	de b7       	in	r29, 0x3e	; 62
    24e4:	9a 83       	std	Y+2, r25	; 0x02
    24e6:	89 83       	std	Y+1, r24	; 0x01
	MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin1,Copy_Stepper->Copy_u8Pin1Port,PIN_HIGH);
    24e8:	e9 81       	ldd	r30, Y+1	; 0x01
    24ea:	fa 81       	ldd	r31, Y+2	; 0x02
    24ec:	80 81       	ld	r24, Z
    24ee:	e9 81       	ldd	r30, Y+1	; 0x01
    24f0:	fa 81       	ldd	r31, Y+2	; 0x02
    24f2:	91 81       	ldd	r25, Z+1	; 0x01
    24f4:	69 2f       	mov	r22, r25
    24f6:	41 e0       	ldi	r20, 0x01	; 1
    24f8:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin2,Copy_Stepper->Copy_u8Pin2Port,PIN_HIGH);
    24fc:	e9 81       	ldd	r30, Y+1	; 0x01
    24fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2500:	82 81       	ldd	r24, Z+2	; 0x02
    2502:	e9 81       	ldd	r30, Y+1	; 0x01
    2504:	fa 81       	ldd	r31, Y+2	; 0x02
    2506:	93 81       	ldd	r25, Z+3	; 0x03
    2508:	69 2f       	mov	r22, r25
    250a:	41 e0       	ldi	r20, 0x01	; 1
    250c:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin3,Copy_Stepper->Copy_u8Pin3Port,PIN_HIGH);
    2510:	e9 81       	ldd	r30, Y+1	; 0x01
    2512:	fa 81       	ldd	r31, Y+2	; 0x02
    2514:	84 81       	ldd	r24, Z+4	; 0x04
    2516:	e9 81       	ldd	r30, Y+1	; 0x01
    2518:	fa 81       	ldd	r31, Y+2	; 0x02
    251a:	95 81       	ldd	r25, Z+5	; 0x05
    251c:	69 2f       	mov	r22, r25
    251e:	41 e0       	ldi	r20, 0x01	; 1
    2520:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(Copy_Stepper->Copy_u8Pin4,Copy_Stepper->Copy_u8Pin4Port,PIN_HIGH);
    2524:	e9 81       	ldd	r30, Y+1	; 0x01
    2526:	fa 81       	ldd	r31, Y+2	; 0x02
    2528:	86 81       	ldd	r24, Z+6	; 0x06
    252a:	e9 81       	ldd	r30, Y+1	; 0x01
    252c:	fa 81       	ldd	r31, Y+2	; 0x02
    252e:	97 81       	ldd	r25, Z+7	; 0x07
    2530:	69 2f       	mov	r22, r25
    2532:	41 e0       	ldi	r20, 0x01	; 1
    2534:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
}
    2538:	0f 90       	pop	r0
    253a:	0f 90       	pop	r0
    253c:	cf 91       	pop	r28
    253e:	df 91       	pop	r29
    2540:	08 95       	ret

00002542 <HSTEPPER_VidGoToAngle>:

void HSTEPPER_VidGoToAngle (STEPPER_t * Copy_Stepper , u16 Copy_u16DesiredAngle , u8 Copy_u8Direction , u8 Copy_u8TimeDelay)
{
    2542:	df 93       	push	r29
    2544:	cf 93       	push	r28
    2546:	cd b7       	in	r28, 0x3d	; 61
    2548:	de b7       	in	r29, 0x3e	; 62
    254a:	2e 97       	sbiw	r28, 0x0e	; 14
    254c:	0f b6       	in	r0, 0x3f	; 63
    254e:	f8 94       	cli
    2550:	de bf       	out	0x3e, r29	; 62
    2552:	0f be       	out	0x3f, r0	; 63
    2554:	cd bf       	out	0x3d, r28	; 61
    2556:	98 87       	std	Y+8, r25	; 0x08
    2558:	8f 83       	std	Y+7, r24	; 0x07
    255a:	7a 87       	std	Y+10, r23	; 0x0a
    255c:	69 87       	std	Y+9, r22	; 0x09
    255e:	4b 87       	std	Y+11, r20	; 0x0b
    2560:	2c 87       	std	Y+12, r18	; 0x0c
	/*Calculates Number of Full Steps Needed To reach Desired Angle
	 * 1 Full Speed 		=====> 		0.176 degrees
	 * No of Steps required =======> Desired Angle
	 * No of Steps Required = Desired Angle / 0.176  */

	u16 Loc_u16_Steps_Required = Copy_u16DesiredAngle/0.176  ;
    2562:	89 85       	ldd	r24, Y+9	; 0x09
    2564:	9a 85       	ldd	r25, Y+10	; 0x0a
    2566:	cc 01       	movw	r24, r24
    2568:	a0 e0       	ldi	r26, 0x00	; 0
    256a:	b0 e0       	ldi	r27, 0x00	; 0
    256c:	bc 01       	movw	r22, r24
    256e:	cd 01       	movw	r24, r26
    2570:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    2574:	dc 01       	movw	r26, r24
    2576:	cb 01       	movw	r24, r22
    2578:	bc 01       	movw	r22, r24
    257a:	cd 01       	movw	r24, r26
    257c:	28 e5       	ldi	r18, 0x58	; 88
    257e:	39 e3       	ldi	r19, 0x39	; 57
    2580:	44 e3       	ldi	r20, 0x34	; 52
    2582:	5e e3       	ldi	r21, 0x3E	; 62
    2584:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2588:	dc 01       	movw	r26, r24
    258a:	cb 01       	movw	r24, r22
    258c:	bc 01       	movw	r22, r24
    258e:	cd 01       	movw	r24, r26
    2590:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2594:	dc 01       	movw	r26, r24
    2596:	cb 01       	movw	r24, r22
    2598:	9e 83       	std	Y+6, r25	; 0x06
    259a:	8d 83       	std	Y+5, r24	; 0x05

	/*Adding One To Compensate for the Fraction Neglected due to using integer variables*/
	u16 Loc_u16_SequenceIterations = Loc_u16_Steps_Required/4+1 ;
    259c:	8d 81       	ldd	r24, Y+5	; 0x05
    259e:	9e 81       	ldd	r25, Y+6	; 0x06
    25a0:	96 95       	lsr	r25
    25a2:	87 95       	ror	r24
    25a4:	96 95       	lsr	r25
    25a6:	87 95       	ror	r24
    25a8:	01 96       	adiw	r24, 0x01	; 1
    25aa:	9c 83       	std	Y+4, r25	; 0x04
    25ac:	8b 83       	std	Y+3, r24	; 0x03
	u16 Loc_u8_Counter  ;

	switch (Copy_u8Direction)
    25ae:	8b 85       	ldd	r24, Y+11	; 0x0b
    25b0:	28 2f       	mov	r18, r24
    25b2:	30 e0       	ldi	r19, 0x00	; 0
    25b4:	3e 87       	std	Y+14, r19	; 0x0e
    25b6:	2d 87       	std	Y+13, r18	; 0x0d
    25b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    25ba:	9e 85       	ldd	r25, Y+14	; 0x0e
    25bc:	81 30       	cpi	r24, 0x01	; 1
    25be:	91 05       	cpc	r25, r1
    25c0:	31 f0       	breq	.+12     	; 0x25ce <HSTEPPER_VidGoToAngle+0x8c>
    25c2:	2d 85       	ldd	r18, Y+13	; 0x0d
    25c4:	3e 85       	ldd	r19, Y+14	; 0x0e
    25c6:	22 30       	cpi	r18, 0x02	; 2
    25c8:	31 05       	cpc	r19, r1
    25ca:	a9 f0       	breq	.+42     	; 0x25f6 <HSTEPPER_VidGoToAngle+0xb4>
    25cc:	27 c0       	rjmp	.+78     	; 0x261c <HSTEPPER_VidGoToAngle+0xda>
	{
	case HSTEPPER_ANTICLOCKWISE:
		for(Loc_u8_Counter=Loc_u16_SequenceIterations ; Loc_u8_Counter>0 ; Loc_u8_Counter--)
    25ce:	8b 81       	ldd	r24, Y+3	; 0x03
    25d0:	9c 81       	ldd	r25, Y+4	; 0x04
    25d2:	9a 83       	std	Y+2, r25	; 0x02
    25d4:	89 83       	std	Y+1, r24	; 0x01
    25d6:	0a c0       	rjmp	.+20     	; 0x25ec <HSTEPPER_VidGoToAngle+0xaa>
		{
			HSTEPPER_VidFullStepAntiClockwiseSequence(Copy_Stepper ,Copy_u8TimeDelay)  ;
    25d8:	8f 81       	ldd	r24, Y+7	; 0x07
    25da:	98 85       	ldd	r25, Y+8	; 0x08
    25dc:	6c 85       	ldd	r22, Y+12	; 0x0c
    25de:	0e 94 31 0d 	call	0x1a62	; 0x1a62 <HSTEPPER_VidFullStepAntiClockwiseSequence>
	u16 Loc_u8_Counter  ;

	switch (Copy_u8Direction)
	{
	case HSTEPPER_ANTICLOCKWISE:
		for(Loc_u8_Counter=Loc_u16_SequenceIterations ; Loc_u8_Counter>0 ; Loc_u8_Counter--)
    25e2:	89 81       	ldd	r24, Y+1	; 0x01
    25e4:	9a 81       	ldd	r25, Y+2	; 0x02
    25e6:	01 97       	sbiw	r24, 0x01	; 1
    25e8:	9a 83       	std	Y+2, r25	; 0x02
    25ea:	89 83       	std	Y+1, r24	; 0x01
    25ec:	89 81       	ldd	r24, Y+1	; 0x01
    25ee:	9a 81       	ldd	r25, Y+2	; 0x02
    25f0:	00 97       	sbiw	r24, 0x00	; 0
    25f2:	91 f7       	brne	.-28     	; 0x25d8 <HSTEPPER_VidGoToAngle+0x96>
    25f4:	13 c0       	rjmp	.+38     	; 0x261c <HSTEPPER_VidGoToAngle+0xda>
		{
			HSTEPPER_VidFullStepAntiClockwiseSequence(Copy_Stepper ,Copy_u8TimeDelay)  ;
		}
		break  ;
	case HSTEPPER_CLOCKWISE:
		for(Loc_u8_Counter=Loc_u16_SequenceIterations ; Loc_u8_Counter>0 ; Loc_u8_Counter--)
    25f6:	8b 81       	ldd	r24, Y+3	; 0x03
    25f8:	9c 81       	ldd	r25, Y+4	; 0x04
    25fa:	9a 83       	std	Y+2, r25	; 0x02
    25fc:	89 83       	std	Y+1, r24	; 0x01
    25fe:	0a c0       	rjmp	.+20     	; 0x2614 <HSTEPPER_VidGoToAngle+0xd2>
		{
			HSTEPPER_VidFullStepClockwiseSequence(Copy_Stepper ,Copy_u8TimeDelay)  ;
    2600:	8f 81       	ldd	r24, Y+7	; 0x07
    2602:	98 85       	ldd	r25, Y+8	; 0x08
    2604:	6c 85       	ldd	r22, Y+12	; 0x0c
    2606:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <HSTEPPER_VidFullStepClockwiseSequence>
		{
			HSTEPPER_VidFullStepAntiClockwiseSequence(Copy_Stepper ,Copy_u8TimeDelay)  ;
		}
		break  ;
	case HSTEPPER_CLOCKWISE:
		for(Loc_u8_Counter=Loc_u16_SequenceIterations ; Loc_u8_Counter>0 ; Loc_u8_Counter--)
    260a:	89 81       	ldd	r24, Y+1	; 0x01
    260c:	9a 81       	ldd	r25, Y+2	; 0x02
    260e:	01 97       	sbiw	r24, 0x01	; 1
    2610:	9a 83       	std	Y+2, r25	; 0x02
    2612:	89 83       	std	Y+1, r24	; 0x01
    2614:	89 81       	ldd	r24, Y+1	; 0x01
    2616:	9a 81       	ldd	r25, Y+2	; 0x02
    2618:	00 97       	sbiw	r24, 0x00	; 0
    261a:	91 f7       	brne	.-28     	; 0x2600 <HSTEPPER_VidGoToAngle+0xbe>
		break  ;
	default :
		/*Do Nothing */
		break  ;
	}
}
    261c:	2e 96       	adiw	r28, 0x0e	; 14
    261e:	0f b6       	in	r0, 0x3f	; 63
    2620:	f8 94       	cli
    2622:	de bf       	out	0x3e, r29	; 62
    2624:	0f be       	out	0x3f, r0	; 63
    2626:	cd bf       	out	0x3d, r28	; 61
    2628:	cf 91       	pop	r28
    262a:	df 91       	pop	r29
    262c:	08 95       	ret

0000262e <HSTEPPER_VidRotateCycles>:



void HSTEPPER_VidRotateCycles(STEPPER_t * Copy_Stepper , u8 Copy_u8NoOfCycles , u8 Copy_u8Direction , u8 Copy_u8TimeDelay)
{
    262e:	df 93       	push	r29
    2630:	cf 93       	push	r28
    2632:	00 d0       	rcall	.+0      	; 0x2634 <HSTEPPER_VidRotateCycles+0x6>
    2634:	00 d0       	rcall	.+0      	; 0x2636 <HSTEPPER_VidRotateCycles+0x8>
    2636:	00 d0       	rcall	.+0      	; 0x2638 <HSTEPPER_VidRotateCycles+0xa>
    2638:	cd b7       	in	r28, 0x3d	; 61
    263a:	de b7       	in	r29, 0x3e	; 62
    263c:	9b 83       	std	Y+3, r25	; 0x03
    263e:	8a 83       	std	Y+2, r24	; 0x02
    2640:	6c 83       	std	Y+4, r22	; 0x04
    2642:	4d 83       	std	Y+5, r20	; 0x05
    2644:	2e 83       	std	Y+6, r18	; 0x06
	u8 Loc_u8_Counter;
	for(Loc_u8_Counter=0;Loc_u8_Counter<Copy_u8NoOfCycles;Loc_u8_Counter++)
    2646:	19 82       	std	Y+1, r1	; 0x01
    2648:	0b c0       	rjmp	.+22     	; 0x2660 <HSTEPPER_VidRotateCycles+0x32>
	{
		HSTEPPER_VidGoToAngle(Copy_Stepper,360,Copy_u8Direction,Copy_u8TimeDelay);
    264a:	8a 81       	ldd	r24, Y+2	; 0x02
    264c:	9b 81       	ldd	r25, Y+3	; 0x03
    264e:	68 e6       	ldi	r22, 0x68	; 104
    2650:	71 e0       	ldi	r23, 0x01	; 1
    2652:	4d 81       	ldd	r20, Y+5	; 0x05
    2654:	2e 81       	ldd	r18, Y+6	; 0x06
    2656:	0e 94 a1 12 	call	0x2542	; 0x2542 <HSTEPPER_VidGoToAngle>


void HSTEPPER_VidRotateCycles(STEPPER_t * Copy_Stepper , u8 Copy_u8NoOfCycles , u8 Copy_u8Direction , u8 Copy_u8TimeDelay)
{
	u8 Loc_u8_Counter;
	for(Loc_u8_Counter=0;Loc_u8_Counter<Copy_u8NoOfCycles;Loc_u8_Counter++)
    265a:	89 81       	ldd	r24, Y+1	; 0x01
    265c:	8f 5f       	subi	r24, 0xFF	; 255
    265e:	89 83       	std	Y+1, r24	; 0x01
    2660:	99 81       	ldd	r25, Y+1	; 0x01
    2662:	8c 81       	ldd	r24, Y+4	; 0x04
    2664:	98 17       	cp	r25, r24
    2666:	88 f3       	brcs	.-30     	; 0x264a <HSTEPPER_VidRotateCycles+0x1c>
	{
		HSTEPPER_VidGoToAngle(Copy_Stepper,360,Copy_u8Direction,Copy_u8TimeDelay);
	}
}
    2668:	26 96       	adiw	r28, 0x06	; 6
    266a:	0f b6       	in	r0, 0x3f	; 63
    266c:	f8 94       	cli
    266e:	de bf       	out	0x3e, r29	; 62
    2670:	0f be       	out	0x3f, r0	; 63
    2672:	cd bf       	out	0x3d, r28	; 61
    2674:	cf 91       	pop	r28
    2676:	df 91       	pop	r29
    2678:	08 95       	ret

0000267a <HKPD_VidInit>:

/**********/
/*KPD INIT*/
/**********/
void HKPD_VidInit(void)
{
    267a:	df 93       	push	r29
    267c:	cf 93       	push	r28
    267e:	cd b7       	in	r28, 0x3d	; 61
    2680:	de b7       	in	r29, 0x3e	; 62
	/* Set Row Pins as an Input */
	//MDIO_Error_State_SetNibbleDirection(ROW_PORT,ROW_NIBBLE_INPUT);
	MDIO_Error_State_SetPinDirection(ROW_PIN0,ROW_PORT,PIN_INPUT);
    2682:	84 e0       	ldi	r24, 0x04	; 4
    2684:	61 e0       	ldi	r22, 0x01	; 1
    2686:	40 e0       	ldi	r20, 0x00	; 0
    2688:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(ROW_PIN1,ROW_PORT,PIN_INPUT);
    268c:	85 e0       	ldi	r24, 0x05	; 5
    268e:	61 e0       	ldi	r22, 0x01	; 1
    2690:	40 e0       	ldi	r20, 0x00	; 0
    2692:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(ROW_PIN2,ROW_PORT,PIN_INPUT);
    2696:	86 e0       	ldi	r24, 0x06	; 6
    2698:	61 e0       	ldi	r22, 0x01	; 1
    269a:	40 e0       	ldi	r20, 0x00	; 0
    269c:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(ROW_PIN3,ROW_PORT,PIN_INPUT);
    26a0:	87 e0       	ldi	r24, 0x07	; 7
    26a2:	61 e0       	ldi	r22, 0x01	; 1
    26a4:	40 e0       	ldi	r20, 0x00	; 0
    26a6:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	/* Set Column Pins as an Output */
	//MDIO_Error_State_SetNibbleDirection(COL_PORT,COL_NIBBLE_OUTPUT);
	MDIO_Error_State_SetPinDirection(COL_PIN0,COL_PORT,PIN_OUTPUT);
    26aa:	82 e0       	ldi	r24, 0x02	; 2
    26ac:	63 e0       	ldi	r22, 0x03	; 3
    26ae:	41 e0       	ldi	r20, 0x01	; 1
    26b0:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(COL_PIN1,COL_PORT,PIN_OUTPUT);
    26b4:	83 e0       	ldi	r24, 0x03	; 3
    26b6:	63 e0       	ldi	r22, 0x03	; 3
    26b8:	41 e0       	ldi	r20, 0x01	; 1
    26ba:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(COL_PIN2,COL_PORT,PIN_OUTPUT);
    26be:	84 e0       	ldi	r24, 0x04	; 4
    26c0:	63 e0       	ldi	r22, 0x03	; 3
    26c2:	41 e0       	ldi	r20, 0x01	; 1
    26c4:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(COL_PIN3,COL_PORT,PIN_OUTPUT);
    26c8:	85 e0       	ldi	r24, 0x05	; 5
    26ca:	63 e0       	ldi	r22, 0x03	; 3
    26cc:	41 e0       	ldi	r20, 0x01	; 1
    26ce:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	/* Active Pull Up Resistor For Row Pins */
	//MDIO_Error_State_SetLeastSignificantNibbleValues(ROW_PORT,LEAST_NIBBLE_HIGH);
	MDIO_Error_State_SetPinValue(ROW_PIN0,ROW_PORT,PIN_HIGH);
    26d2:	84 e0       	ldi	r24, 0x04	; 4
    26d4:	61 e0       	ldi	r22, 0x01	; 1
    26d6:	41 e0       	ldi	r20, 0x01	; 1
    26d8:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(ROW_PIN1,ROW_PORT,PIN_HIGH);
    26dc:	85 e0       	ldi	r24, 0x05	; 5
    26de:	61 e0       	ldi	r22, 0x01	; 1
    26e0:	41 e0       	ldi	r20, 0x01	; 1
    26e2:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(ROW_PIN2,ROW_PORT,PIN_HIGH);
    26e6:	86 e0       	ldi	r24, 0x06	; 6
    26e8:	61 e0       	ldi	r22, 0x01	; 1
    26ea:	41 e0       	ldi	r20, 0x01	; 1
    26ec:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(ROW_PIN3,ROW_PORT,PIN_HIGH);
    26f0:	87 e0       	ldi	r24, 0x07	; 7
    26f2:	61 e0       	ldi	r22, 0x01	; 1
    26f4:	41 e0       	ldi	r20, 0x01	; 1
    26f6:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	/* Initialize 4 Column Pins By Ones */
	//MDIO_Error_State_SetMostSignificantNibbleValues(COL_PORT,MOST_NIBBLE_HIGH);
	MDIO_Error_State_SetPinValue(COL_PIN0,COL_PORT,PIN_HIGH);
    26fa:	82 e0       	ldi	r24, 0x02	; 2
    26fc:	63 e0       	ldi	r22, 0x03	; 3
    26fe:	41 e0       	ldi	r20, 0x01	; 1
    2700:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(COL_PIN1,COL_PORT,PIN_HIGH);
    2704:	83 e0       	ldi	r24, 0x03	; 3
    2706:	63 e0       	ldi	r22, 0x03	; 3
    2708:	41 e0       	ldi	r20, 0x01	; 1
    270a:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(COL_PIN2,COL_PORT,PIN_HIGH);
    270e:	84 e0       	ldi	r24, 0x04	; 4
    2710:	63 e0       	ldi	r22, 0x03	; 3
    2712:	41 e0       	ldi	r20, 0x01	; 1
    2714:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(COL_PIN3,COL_PORT,PIN_HIGH);
    2718:	85 e0       	ldi	r24, 0x05	; 5
    271a:	63 e0       	ldi	r22, 0x03	; 3
    271c:	41 e0       	ldi	r20, 0x01	; 1
    271e:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
}
    2722:	cf 91       	pop	r28
    2724:	df 91       	pop	r29
    2726:	08 95       	ret

00002728 <HKPD_u8GetKeyPressed>:

/*****************/
/*KPD Get pressed*/
/*****************/
u8 HKPD_u8GetKeyPressed(void)
{
    2728:	df 93       	push	r29
    272a:	cf 93       	push	r28
    272c:	00 d0       	rcall	.+0      	; 0x272e <HKPD_u8GetKeyPressed+0x6>
    272e:	00 d0       	rcall	.+0      	; 0x2730 <HKPD_u8GetKeyPressed+0x8>
    2730:	cd b7       	in	r28, 0x3d	; 61
    2732:	de b7       	in	r29, 0x3e	; 62
	u8 LOC_u8RowCount;
	u8 LOC_u8ColCount;
	
	/*Initialize the switch status to NOT PRESSED*/
	u8 LOC_u8ReturnValue=NOT_PRESSED;
    2734:	8f ef       	ldi	r24, 0xFF	; 255
    2736:	89 83       	std	Y+1, r24	; 0x01
	u8 LOC_u8PinState;
	
	/*Looping on columns of the keypad*/
	for(LOC_u8ColCount=COL_INIT ; LOC_u8ColCount<COL_END ; LOC_u8ColCount++)
    2738:	82 e0       	ldi	r24, 0x02	; 2
    273a:	8a 83       	std	Y+2, r24	; 0x02
    273c:	45 c0       	rjmp	.+138    	; 0x27c8 <HKPD_u8GetKeyPressed+0xa0>
	{
		/*Active the Column to check */
		MDIO_Error_State_SetPinValue(LOC_u8ColCount, COL_PORT, PIN_LOW);
    273e:	8a 81       	ldd	r24, Y+2	; 0x02
    2740:	63 e0       	ldi	r22, 0x03	; 3
    2742:	40 e0       	ldi	r20, 0x00	; 0
    2744:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		
		/*Loop to read the all row pins*/
		for(LOC_u8RowCount=ROW_INIT ; LOC_u8RowCount<ROW_END ; LOC_u8RowCount++)
    2748:	84 e0       	ldi	r24, 0x04	; 4
    274a:	8b 83       	std	Y+3, r24	; 0x03
    274c:	32 c0       	rjmp	.+100    	; 0x27b2 <HKPD_u8GetKeyPressed+0x8a>
		{
			/*check the status of the switch*/
			MDIO_Error_State_GetPinValue(LOC_u8RowCount, ROW_PORT, &LOC_u8PinState);
    274e:	9e 01       	movw	r18, r28
    2750:	2c 5f       	subi	r18, 0xFC	; 252
    2752:	3f 4f       	sbci	r19, 0xFF	; 255
    2754:	8b 81       	ldd	r24, Y+3	; 0x03
    2756:	61 e0       	ldi	r22, 0x01	; 1
    2758:	a9 01       	movw	r20, r18
    275a:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <MDIO_Error_State_GetPinValue>
			if(LOC_u8PinState==0)
    275e:	8c 81       	ldd	r24, Y+4	; 0x04
    2760:	88 23       	and	r24, r24
    2762:	21 f5       	brne	.+72     	; 0x27ac <HKPD_u8GetKeyPressed+0x84>
			{
				/*Get the Value of the current pressed switch*/
				LOC_u8ReturnValue=KPD_u8SwitchVal[LOC_u8ColCount - COL_INIT][LOC_u8RowCount - ROW_INIT];
    2764:	8a 81       	ldd	r24, Y+2	; 0x02
    2766:	88 2f       	mov	r24, r24
    2768:	90 e0       	ldi	r25, 0x00	; 0
    276a:	ac 01       	movw	r20, r24
    276c:	42 50       	subi	r20, 0x02	; 2
    276e:	50 40       	sbci	r21, 0x00	; 0
    2770:	8b 81       	ldd	r24, Y+3	; 0x03
    2772:	88 2f       	mov	r24, r24
    2774:	90 e0       	ldi	r25, 0x00	; 0
    2776:	9c 01       	movw	r18, r24
    2778:	24 50       	subi	r18, 0x04	; 4
    277a:	30 40       	sbci	r19, 0x00	; 0
    277c:	ca 01       	movw	r24, r20
    277e:	88 0f       	add	r24, r24
    2780:	99 1f       	adc	r25, r25
    2782:	88 0f       	add	r24, r24
    2784:	99 1f       	adc	r25, r25
    2786:	82 0f       	add	r24, r18
    2788:	93 1f       	adc	r25, r19
    278a:	fc 01       	movw	r30, r24
    278c:	e4 51       	subi	r30, 0x14	; 20
    278e:	fe 4f       	sbci	r31, 0xFE	; 254
    2790:	80 81       	ld	r24, Z
    2792:	89 83       	std	Y+1, r24	; 0x01
    2794:	08 c0       	rjmp	.+16     	; 0x27a6 <HKPD_u8GetKeyPressed+0x7e>
				
				/*wait until the switch is released(Single Press)*/
				while(LOC_u8PinState==0)
				{
					MDIO_Error_State_GetPinValue(LOC_u8RowCount,ROW_PORT,&LOC_u8PinState);
    2796:	9e 01       	movw	r18, r28
    2798:	2c 5f       	subi	r18, 0xFC	; 252
    279a:	3f 4f       	sbci	r19, 0xFF	; 255
    279c:	8b 81       	ldd	r24, Y+3	; 0x03
    279e:	61 e0       	ldi	r22, 0x01	; 1
    27a0:	a9 01       	movw	r20, r18
    27a2:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <MDIO_Error_State_GetPinValue>
			{
				/*Get the Value of the current pressed switch*/
				LOC_u8ReturnValue=KPD_u8SwitchVal[LOC_u8ColCount - COL_INIT][LOC_u8RowCount - ROW_INIT];
				
				/*wait until the switch is released(Single Press)*/
				while(LOC_u8PinState==0)
    27a6:	8c 81       	ldd	r24, Y+4	; 0x04
    27a8:	88 23       	and	r24, r24
    27aa:	a9 f3       	breq	.-22     	; 0x2796 <HKPD_u8GetKeyPressed+0x6e>
	{
		/*Active the Column to check */
		MDIO_Error_State_SetPinValue(LOC_u8ColCount, COL_PORT, PIN_LOW);
		
		/*Loop to read the all row pins*/
		for(LOC_u8RowCount=ROW_INIT ; LOC_u8RowCount<ROW_END ; LOC_u8RowCount++)
    27ac:	8b 81       	ldd	r24, Y+3	; 0x03
    27ae:	8f 5f       	subi	r24, 0xFF	; 255
    27b0:	8b 83       	std	Y+3, r24	; 0x03
    27b2:	8b 81       	ldd	r24, Y+3	; 0x03
    27b4:	88 30       	cpi	r24, 0x08	; 8
    27b6:	58 f2       	brcs	.-106    	; 0x274e <HKPD_u8GetKeyPressed+0x26>
			{
				/*Do Nothing*/
			}
		}
		/*Deactivate the Column*/
		MDIO_Error_State_SetPinValue(LOC_u8ColCount,COL_PORT,PIN_HIGH);
    27b8:	8a 81       	ldd	r24, Y+2	; 0x02
    27ba:	63 e0       	ldi	r22, 0x03	; 3
    27bc:	41 e0       	ldi	r20, 0x01	; 1
    27be:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	/*Initialize the switch status to NOT PRESSED*/
	u8 LOC_u8ReturnValue=NOT_PRESSED;
	u8 LOC_u8PinState;
	
	/*Looping on columns of the keypad*/
	for(LOC_u8ColCount=COL_INIT ; LOC_u8ColCount<COL_END ; LOC_u8ColCount++)
    27c2:	8a 81       	ldd	r24, Y+2	; 0x02
    27c4:	8f 5f       	subi	r24, 0xFF	; 255
    27c6:	8a 83       	std	Y+2, r24	; 0x02
    27c8:	8a 81       	ldd	r24, Y+2	; 0x02
    27ca:	86 30       	cpi	r24, 0x06	; 6
    27cc:	08 f4       	brcc	.+2      	; 0x27d0 <HKPD_u8GetKeyPressed+0xa8>
    27ce:	b7 cf       	rjmp	.-146    	; 0x273e <HKPD_u8GetKeyPressed+0x16>
			}
		}
		/*Deactivate the Column*/
		MDIO_Error_State_SetPinValue(LOC_u8ColCount,COL_PORT,PIN_HIGH);
	}
	return LOC_u8ReturnValue;
    27d0:	89 81       	ldd	r24, Y+1	; 0x01
}
    27d2:	0f 90       	pop	r0
    27d4:	0f 90       	pop	r0
    27d6:	0f 90       	pop	r0
    27d8:	0f 90       	pop	r0
    27da:	cf 91       	pop	r28
    27dc:	df 91       	pop	r29
    27de:	08 95       	ret

000027e0 <HCLCD_VidWriteCommand_8Bits>:
#include"HCLCD_Interface.h"

#include"util/delay.h"

void HCLCD_VidWriteCommand_8Bits(u8 Copy_u8Command)
{
    27e0:	df 93       	push	r29
    27e2:	cf 93       	push	r28
    27e4:	cd b7       	in	r28, 0x3d	; 61
    27e6:	de b7       	in	r29, 0x3e	; 62
    27e8:	6d 97       	sbiw	r28, 0x1d	; 29
    27ea:	0f b6       	in	r0, 0x3f	; 63
    27ec:	f8 94       	cli
    27ee:	de bf       	out	0x3e, r29	; 62
    27f0:	0f be       	out	0x3f, r0	; 63
    27f2:	cd bf       	out	0x3d, r28	; 61
    27f4:	8d 8f       	std	Y+29, r24	; 0x1d
	/*select Command register--> Write zero on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_LOW);
    27f6:	81 e0       	ldi	r24, 0x01	; 1
    27f8:	60 e0       	ldi	r22, 0x00	; 0
    27fa:	40 e0       	ldi	r20, 0x00	; 0
    27fc:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send Command ON port Data*/
	MDIO_Error_State_SetPortValue(DATA_PORT,Copy_u8Command);
    2800:	80 e0       	ldi	r24, 0x00	; 0
    2802:	6d 8d       	ldd	r22, Y+29	; 0x1d
    2804:	0e 94 8d 0a 	call	0x151a	; 0x151a <MDIO_Error_State_SetPortValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    2808:	82 e0       	ldi	r24, 0x02	; 2
    280a:	60 e0       	ldi	r22, 0x00	; 0
    280c:	41 e0       	ldi	r20, 0x01	; 1
    280e:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
    2812:	80 e0       	ldi	r24, 0x00	; 0
    2814:	90 e0       	ldi	r25, 0x00	; 0
    2816:	a0 e0       	ldi	r26, 0x00	; 0
    2818:	b0 e4       	ldi	r27, 0x40	; 64
    281a:	89 8f       	std	Y+25, r24	; 0x19
    281c:	9a 8f       	std	Y+26, r25	; 0x1a
    281e:	ab 8f       	std	Y+27, r26	; 0x1b
    2820:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2822:	69 8d       	ldd	r22, Y+25	; 0x19
    2824:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2826:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2828:	9c 8d       	ldd	r25, Y+28	; 0x1c
    282a:	20 e0       	ldi	r18, 0x00	; 0
    282c:	30 e0       	ldi	r19, 0x00	; 0
    282e:	4a ef       	ldi	r20, 0xFA	; 250
    2830:	54 e4       	ldi	r21, 0x44	; 68
    2832:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2836:	dc 01       	movw	r26, r24
    2838:	cb 01       	movw	r24, r22
    283a:	8d 8b       	std	Y+21, r24	; 0x15
    283c:	9e 8b       	std	Y+22, r25	; 0x16
    283e:	af 8b       	std	Y+23, r26	; 0x17
    2840:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2842:	6d 89       	ldd	r22, Y+21	; 0x15
    2844:	7e 89       	ldd	r23, Y+22	; 0x16
    2846:	8f 89       	ldd	r24, Y+23	; 0x17
    2848:	98 8d       	ldd	r25, Y+24	; 0x18
    284a:	20 e0       	ldi	r18, 0x00	; 0
    284c:	30 e0       	ldi	r19, 0x00	; 0
    284e:	40 e8       	ldi	r20, 0x80	; 128
    2850:	5f e3       	ldi	r21, 0x3F	; 63
    2852:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2856:	88 23       	and	r24, r24
    2858:	2c f4       	brge	.+10     	; 0x2864 <HCLCD_VidWriteCommand_8Bits+0x84>
		__ticks = 1;
    285a:	81 e0       	ldi	r24, 0x01	; 1
    285c:	90 e0       	ldi	r25, 0x00	; 0
    285e:	9c 8b       	std	Y+20, r25	; 0x14
    2860:	8b 8b       	std	Y+19, r24	; 0x13
    2862:	3f c0       	rjmp	.+126    	; 0x28e2 <HCLCD_VidWriteCommand_8Bits+0x102>
	else if (__tmp > 65535)
    2864:	6d 89       	ldd	r22, Y+21	; 0x15
    2866:	7e 89       	ldd	r23, Y+22	; 0x16
    2868:	8f 89       	ldd	r24, Y+23	; 0x17
    286a:	98 8d       	ldd	r25, Y+24	; 0x18
    286c:	20 e0       	ldi	r18, 0x00	; 0
    286e:	3f ef       	ldi	r19, 0xFF	; 255
    2870:	4f e7       	ldi	r20, 0x7F	; 127
    2872:	57 e4       	ldi	r21, 0x47	; 71
    2874:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2878:	18 16       	cp	r1, r24
    287a:	4c f5       	brge	.+82     	; 0x28ce <HCLCD_VidWriteCommand_8Bits+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    287c:	69 8d       	ldd	r22, Y+25	; 0x19
    287e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2880:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2882:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2884:	20 e0       	ldi	r18, 0x00	; 0
    2886:	30 e0       	ldi	r19, 0x00	; 0
    2888:	40 e2       	ldi	r20, 0x20	; 32
    288a:	51 e4       	ldi	r21, 0x41	; 65
    288c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2890:	dc 01       	movw	r26, r24
    2892:	cb 01       	movw	r24, r22
    2894:	bc 01       	movw	r22, r24
    2896:	cd 01       	movw	r24, r26
    2898:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    289c:	dc 01       	movw	r26, r24
    289e:	cb 01       	movw	r24, r22
    28a0:	9c 8b       	std	Y+20, r25	; 0x14
    28a2:	8b 8b       	std	Y+19, r24	; 0x13
    28a4:	0f c0       	rjmp	.+30     	; 0x28c4 <HCLCD_VidWriteCommand_8Bits+0xe4>
    28a6:	88 ec       	ldi	r24, 0xC8	; 200
    28a8:	90 e0       	ldi	r25, 0x00	; 0
    28aa:	9a 8b       	std	Y+18, r25	; 0x12
    28ac:	89 8b       	std	Y+17, r24	; 0x11
    28ae:	89 89       	ldd	r24, Y+17	; 0x11
    28b0:	9a 89       	ldd	r25, Y+18	; 0x12
    28b2:	01 97       	sbiw	r24, 0x01	; 1
    28b4:	f1 f7       	brne	.-4      	; 0x28b2 <HCLCD_VidWriteCommand_8Bits+0xd2>
    28b6:	9a 8b       	std	Y+18, r25	; 0x12
    28b8:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    28ba:	8b 89       	ldd	r24, Y+19	; 0x13
    28bc:	9c 89       	ldd	r25, Y+20	; 0x14
    28be:	01 97       	sbiw	r24, 0x01	; 1
    28c0:	9c 8b       	std	Y+20, r25	; 0x14
    28c2:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    28c4:	8b 89       	ldd	r24, Y+19	; 0x13
    28c6:	9c 89       	ldd	r25, Y+20	; 0x14
    28c8:	00 97       	sbiw	r24, 0x00	; 0
    28ca:	69 f7       	brne	.-38     	; 0x28a6 <HCLCD_VidWriteCommand_8Bits+0xc6>
    28cc:	14 c0       	rjmp	.+40     	; 0x28f6 <HCLCD_VidWriteCommand_8Bits+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    28ce:	6d 89       	ldd	r22, Y+21	; 0x15
    28d0:	7e 89       	ldd	r23, Y+22	; 0x16
    28d2:	8f 89       	ldd	r24, Y+23	; 0x17
    28d4:	98 8d       	ldd	r25, Y+24	; 0x18
    28d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    28da:	dc 01       	movw	r26, r24
    28dc:	cb 01       	movw	r24, r22
    28de:	9c 8b       	std	Y+20, r25	; 0x14
    28e0:	8b 8b       	std	Y+19, r24	; 0x13
    28e2:	8b 89       	ldd	r24, Y+19	; 0x13
    28e4:	9c 89       	ldd	r25, Y+20	; 0x14
    28e6:	98 8b       	std	Y+16, r25	; 0x10
    28e8:	8f 87       	std	Y+15, r24	; 0x0f
    28ea:	8f 85       	ldd	r24, Y+15	; 0x0f
    28ec:	98 89       	ldd	r25, Y+16	; 0x10
    28ee:	01 97       	sbiw	r24, 0x01	; 1
    28f0:	f1 f7       	brne	.-4      	; 0x28ee <HCLCD_VidWriteCommand_8Bits+0x10e>
    28f2:	98 8b       	std	Y+16, r25	; 0x10
    28f4:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    28f6:	82 e0       	ldi	r24, 0x02	; 2
    28f8:	60 e0       	ldi	r22, 0x00	; 0
    28fa:	40 e0       	ldi	r20, 0x00	; 0
    28fc:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
    2900:	80 e0       	ldi	r24, 0x00	; 0
    2902:	90 e0       	ldi	r25, 0x00	; 0
    2904:	a0 e0       	ldi	r26, 0x00	; 0
    2906:	b0 e4       	ldi	r27, 0x40	; 64
    2908:	8b 87       	std	Y+11, r24	; 0x0b
    290a:	9c 87       	std	Y+12, r25	; 0x0c
    290c:	ad 87       	std	Y+13, r26	; 0x0d
    290e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2910:	6b 85       	ldd	r22, Y+11	; 0x0b
    2912:	7c 85       	ldd	r23, Y+12	; 0x0c
    2914:	8d 85       	ldd	r24, Y+13	; 0x0d
    2916:	9e 85       	ldd	r25, Y+14	; 0x0e
    2918:	20 e0       	ldi	r18, 0x00	; 0
    291a:	30 e0       	ldi	r19, 0x00	; 0
    291c:	4a ef       	ldi	r20, 0xFA	; 250
    291e:	54 e4       	ldi	r21, 0x44	; 68
    2920:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2924:	dc 01       	movw	r26, r24
    2926:	cb 01       	movw	r24, r22
    2928:	8f 83       	std	Y+7, r24	; 0x07
    292a:	98 87       	std	Y+8, r25	; 0x08
    292c:	a9 87       	std	Y+9, r26	; 0x09
    292e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2930:	6f 81       	ldd	r22, Y+7	; 0x07
    2932:	78 85       	ldd	r23, Y+8	; 0x08
    2934:	89 85       	ldd	r24, Y+9	; 0x09
    2936:	9a 85       	ldd	r25, Y+10	; 0x0a
    2938:	20 e0       	ldi	r18, 0x00	; 0
    293a:	30 e0       	ldi	r19, 0x00	; 0
    293c:	40 e8       	ldi	r20, 0x80	; 128
    293e:	5f e3       	ldi	r21, 0x3F	; 63
    2940:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2944:	88 23       	and	r24, r24
    2946:	2c f4       	brge	.+10     	; 0x2952 <HCLCD_VidWriteCommand_8Bits+0x172>
		__ticks = 1;
    2948:	81 e0       	ldi	r24, 0x01	; 1
    294a:	90 e0       	ldi	r25, 0x00	; 0
    294c:	9e 83       	std	Y+6, r25	; 0x06
    294e:	8d 83       	std	Y+5, r24	; 0x05
    2950:	3f c0       	rjmp	.+126    	; 0x29d0 <HCLCD_VidWriteCommand_8Bits+0x1f0>
	else if (__tmp > 65535)
    2952:	6f 81       	ldd	r22, Y+7	; 0x07
    2954:	78 85       	ldd	r23, Y+8	; 0x08
    2956:	89 85       	ldd	r24, Y+9	; 0x09
    2958:	9a 85       	ldd	r25, Y+10	; 0x0a
    295a:	20 e0       	ldi	r18, 0x00	; 0
    295c:	3f ef       	ldi	r19, 0xFF	; 255
    295e:	4f e7       	ldi	r20, 0x7F	; 127
    2960:	57 e4       	ldi	r21, 0x47	; 71
    2962:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2966:	18 16       	cp	r1, r24
    2968:	4c f5       	brge	.+82     	; 0x29bc <HCLCD_VidWriteCommand_8Bits+0x1dc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    296a:	6b 85       	ldd	r22, Y+11	; 0x0b
    296c:	7c 85       	ldd	r23, Y+12	; 0x0c
    296e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2970:	9e 85       	ldd	r25, Y+14	; 0x0e
    2972:	20 e0       	ldi	r18, 0x00	; 0
    2974:	30 e0       	ldi	r19, 0x00	; 0
    2976:	40 e2       	ldi	r20, 0x20	; 32
    2978:	51 e4       	ldi	r21, 0x41	; 65
    297a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    297e:	dc 01       	movw	r26, r24
    2980:	cb 01       	movw	r24, r22
    2982:	bc 01       	movw	r22, r24
    2984:	cd 01       	movw	r24, r26
    2986:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    298a:	dc 01       	movw	r26, r24
    298c:	cb 01       	movw	r24, r22
    298e:	9e 83       	std	Y+6, r25	; 0x06
    2990:	8d 83       	std	Y+5, r24	; 0x05
    2992:	0f c0       	rjmp	.+30     	; 0x29b2 <HCLCD_VidWriteCommand_8Bits+0x1d2>
    2994:	88 ec       	ldi	r24, 0xC8	; 200
    2996:	90 e0       	ldi	r25, 0x00	; 0
    2998:	9c 83       	std	Y+4, r25	; 0x04
    299a:	8b 83       	std	Y+3, r24	; 0x03
    299c:	8b 81       	ldd	r24, Y+3	; 0x03
    299e:	9c 81       	ldd	r25, Y+4	; 0x04
    29a0:	01 97       	sbiw	r24, 0x01	; 1
    29a2:	f1 f7       	brne	.-4      	; 0x29a0 <HCLCD_VidWriteCommand_8Bits+0x1c0>
    29a4:	9c 83       	std	Y+4, r25	; 0x04
    29a6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    29a8:	8d 81       	ldd	r24, Y+5	; 0x05
    29aa:	9e 81       	ldd	r25, Y+6	; 0x06
    29ac:	01 97       	sbiw	r24, 0x01	; 1
    29ae:	9e 83       	std	Y+6, r25	; 0x06
    29b0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    29b2:	8d 81       	ldd	r24, Y+5	; 0x05
    29b4:	9e 81       	ldd	r25, Y+6	; 0x06
    29b6:	00 97       	sbiw	r24, 0x00	; 0
    29b8:	69 f7       	brne	.-38     	; 0x2994 <HCLCD_VidWriteCommand_8Bits+0x1b4>
    29ba:	14 c0       	rjmp	.+40     	; 0x29e4 <HCLCD_VidWriteCommand_8Bits+0x204>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    29bc:	6f 81       	ldd	r22, Y+7	; 0x07
    29be:	78 85       	ldd	r23, Y+8	; 0x08
    29c0:	89 85       	ldd	r24, Y+9	; 0x09
    29c2:	9a 85       	ldd	r25, Y+10	; 0x0a
    29c4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    29c8:	dc 01       	movw	r26, r24
    29ca:	cb 01       	movw	r24, r22
    29cc:	9e 83       	std	Y+6, r25	; 0x06
    29ce:	8d 83       	std	Y+5, r24	; 0x05
    29d0:	8d 81       	ldd	r24, Y+5	; 0x05
    29d2:	9e 81       	ldd	r25, Y+6	; 0x06
    29d4:	9a 83       	std	Y+2, r25	; 0x02
    29d6:	89 83       	std	Y+1, r24	; 0x01
    29d8:	89 81       	ldd	r24, Y+1	; 0x01
    29da:	9a 81       	ldd	r25, Y+2	; 0x02
    29dc:	01 97       	sbiw	r24, 0x01	; 1
    29de:	f1 f7       	brne	.-4      	; 0x29dc <HCLCD_VidWriteCommand_8Bits+0x1fc>
    29e0:	9a 83       	std	Y+2, r25	; 0x02
    29e2:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);	
    29e4:	82 e0       	ldi	r24, 0x02	; 2
    29e6:	60 e0       	ldi	r22, 0x00	; 0
    29e8:	41 e0       	ldi	r20, 0x01	; 1
    29ea:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
}
    29ee:	6d 96       	adiw	r28, 0x1d	; 29
    29f0:	0f b6       	in	r0, 0x3f	; 63
    29f2:	f8 94       	cli
    29f4:	de bf       	out	0x3e, r29	; 62
    29f6:	0f be       	out	0x3f, r0	; 63
    29f8:	cd bf       	out	0x3d, r28	; 61
    29fa:	cf 91       	pop	r28
    29fc:	df 91       	pop	r29
    29fe:	08 95       	ret

00002a00 <HCLCD_Vid8Bits_Init>:

void HCLCD_Vid8Bits_Init(void)
{
    2a00:	df 93       	push	r29
    2a02:	cf 93       	push	r28
    2a04:	cd b7       	in	r28, 0x3d	; 61
    2a06:	de b7       	in	r29, 0x3e	; 62
    2a08:	e8 97       	sbiw	r28, 0x38	; 56
    2a0a:	0f b6       	in	r0, 0x3f	; 63
    2a0c:	f8 94       	cli
    2a0e:	de bf       	out	0x3e, r29	; 62
    2a10:	0f be       	out	0x3f, r0	; 63
    2a12:	cd bf       	out	0x3d, r28	; 61
	/*LCD Data and control port intialization*/
	MDIO_Error_State_SetPortDirection(DATA_PORT,PORT_OUTPUT);
    2a14:	80 e0       	ldi	r24, 0x00	; 0
    2a16:	6f ef       	ldi	r22, 0xFF	; 255
    2a18:	0e 94 3a 09 	call	0x1274	; 0x1274 <MDIO_Error_State_SetPortDirection>
	MDIO_Error_State_SetPinDirection(RS,CONTROL_PORT,PIN_OUTPUT);
    2a1c:	81 e0       	ldi	r24, 0x01	; 1
    2a1e:	60 e0       	ldi	r22, 0x00	; 0
    2a20:	41 e0       	ldi	r20, 0x01	; 1
    2a22:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	//MDIO_Error_State_SetPinDirection(RW,CONTROL_PORT,PIN_OUTPUT);
	MDIO_Error_State_SetPinDirection(E,CONTROL_PORT,PIN_OUTPUT);
    2a26:	82 e0       	ldi	r24, 0x02	; 2
    2a28:	60 e0       	ldi	r22, 0x00	; 0
    2a2a:	41 e0       	ldi	r20, 0x01	; 1
    2a2c:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
    2a30:	80 e0       	ldi	r24, 0x00	; 0
    2a32:	90 e0       	ldi	r25, 0x00	; 0
    2a34:	a0 ef       	ldi	r26, 0xF0	; 240
    2a36:	b1 e4       	ldi	r27, 0x41	; 65
    2a38:	8d ab       	std	Y+53, r24	; 0x35
    2a3a:	9e ab       	std	Y+54, r25	; 0x36
    2a3c:	af ab       	std	Y+55, r26	; 0x37
    2a3e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2a40:	6d a9       	ldd	r22, Y+53	; 0x35
    2a42:	7e a9       	ldd	r23, Y+54	; 0x36
    2a44:	8f a9       	ldd	r24, Y+55	; 0x37
    2a46:	98 ad       	ldd	r25, Y+56	; 0x38
    2a48:	20 e0       	ldi	r18, 0x00	; 0
    2a4a:	30 e0       	ldi	r19, 0x00	; 0
    2a4c:	4a ef       	ldi	r20, 0xFA	; 250
    2a4e:	54 e4       	ldi	r21, 0x44	; 68
    2a50:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2a54:	dc 01       	movw	r26, r24
    2a56:	cb 01       	movw	r24, r22
    2a58:	89 ab       	std	Y+49, r24	; 0x31
    2a5a:	9a ab       	std	Y+50, r25	; 0x32
    2a5c:	ab ab       	std	Y+51, r26	; 0x33
    2a5e:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    2a60:	69 a9       	ldd	r22, Y+49	; 0x31
    2a62:	7a a9       	ldd	r23, Y+50	; 0x32
    2a64:	8b a9       	ldd	r24, Y+51	; 0x33
    2a66:	9c a9       	ldd	r25, Y+52	; 0x34
    2a68:	20 e0       	ldi	r18, 0x00	; 0
    2a6a:	30 e0       	ldi	r19, 0x00	; 0
    2a6c:	40 e8       	ldi	r20, 0x80	; 128
    2a6e:	5f e3       	ldi	r21, 0x3F	; 63
    2a70:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2a74:	88 23       	and	r24, r24
    2a76:	2c f4       	brge	.+10     	; 0x2a82 <HCLCD_Vid8Bits_Init+0x82>
		__ticks = 1;
    2a78:	81 e0       	ldi	r24, 0x01	; 1
    2a7a:	90 e0       	ldi	r25, 0x00	; 0
    2a7c:	98 ab       	std	Y+48, r25	; 0x30
    2a7e:	8f a7       	std	Y+47, r24	; 0x2f
    2a80:	3f c0       	rjmp	.+126    	; 0x2b00 <HCLCD_Vid8Bits_Init+0x100>
	else if (__tmp > 65535)
    2a82:	69 a9       	ldd	r22, Y+49	; 0x31
    2a84:	7a a9       	ldd	r23, Y+50	; 0x32
    2a86:	8b a9       	ldd	r24, Y+51	; 0x33
    2a88:	9c a9       	ldd	r25, Y+52	; 0x34
    2a8a:	20 e0       	ldi	r18, 0x00	; 0
    2a8c:	3f ef       	ldi	r19, 0xFF	; 255
    2a8e:	4f e7       	ldi	r20, 0x7F	; 127
    2a90:	57 e4       	ldi	r21, 0x47	; 71
    2a92:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2a96:	18 16       	cp	r1, r24
    2a98:	4c f5       	brge	.+82     	; 0x2aec <HCLCD_Vid8Bits_Init+0xec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2a9a:	6d a9       	ldd	r22, Y+53	; 0x35
    2a9c:	7e a9       	ldd	r23, Y+54	; 0x36
    2a9e:	8f a9       	ldd	r24, Y+55	; 0x37
    2aa0:	98 ad       	ldd	r25, Y+56	; 0x38
    2aa2:	20 e0       	ldi	r18, 0x00	; 0
    2aa4:	30 e0       	ldi	r19, 0x00	; 0
    2aa6:	40 e2       	ldi	r20, 0x20	; 32
    2aa8:	51 e4       	ldi	r21, 0x41	; 65
    2aaa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2aae:	dc 01       	movw	r26, r24
    2ab0:	cb 01       	movw	r24, r22
    2ab2:	bc 01       	movw	r22, r24
    2ab4:	cd 01       	movw	r24, r26
    2ab6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2aba:	dc 01       	movw	r26, r24
    2abc:	cb 01       	movw	r24, r22
    2abe:	98 ab       	std	Y+48, r25	; 0x30
    2ac0:	8f a7       	std	Y+47, r24	; 0x2f
    2ac2:	0f c0       	rjmp	.+30     	; 0x2ae2 <HCLCD_Vid8Bits_Init+0xe2>
    2ac4:	88 ec       	ldi	r24, 0xC8	; 200
    2ac6:	90 e0       	ldi	r25, 0x00	; 0
    2ac8:	9e a7       	std	Y+46, r25	; 0x2e
    2aca:	8d a7       	std	Y+45, r24	; 0x2d
    2acc:	8d a5       	ldd	r24, Y+45	; 0x2d
    2ace:	9e a5       	ldd	r25, Y+46	; 0x2e
    2ad0:	01 97       	sbiw	r24, 0x01	; 1
    2ad2:	f1 f7       	brne	.-4      	; 0x2ad0 <HCLCD_Vid8Bits_Init+0xd0>
    2ad4:	9e a7       	std	Y+46, r25	; 0x2e
    2ad6:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2ad8:	8f a5       	ldd	r24, Y+47	; 0x2f
    2ada:	98 a9       	ldd	r25, Y+48	; 0x30
    2adc:	01 97       	sbiw	r24, 0x01	; 1
    2ade:	98 ab       	std	Y+48, r25	; 0x30
    2ae0:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2ae2:	8f a5       	ldd	r24, Y+47	; 0x2f
    2ae4:	98 a9       	ldd	r25, Y+48	; 0x30
    2ae6:	00 97       	sbiw	r24, 0x00	; 0
    2ae8:	69 f7       	brne	.-38     	; 0x2ac4 <HCLCD_Vid8Bits_Init+0xc4>
    2aea:	14 c0       	rjmp	.+40     	; 0x2b14 <HCLCD_Vid8Bits_Init+0x114>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2aec:	69 a9       	ldd	r22, Y+49	; 0x31
    2aee:	7a a9       	ldd	r23, Y+50	; 0x32
    2af0:	8b a9       	ldd	r24, Y+51	; 0x33
    2af2:	9c a9       	ldd	r25, Y+52	; 0x34
    2af4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2af8:	dc 01       	movw	r26, r24
    2afa:	cb 01       	movw	r24, r22
    2afc:	98 ab       	std	Y+48, r25	; 0x30
    2afe:	8f a7       	std	Y+47, r24	; 0x2f
    2b00:	8f a5       	ldd	r24, Y+47	; 0x2f
    2b02:	98 a9       	ldd	r25, Y+48	; 0x30
    2b04:	9c a7       	std	Y+44, r25	; 0x2c
    2b06:	8b a7       	std	Y+43, r24	; 0x2b
    2b08:	8b a5       	ldd	r24, Y+43	; 0x2b
    2b0a:	9c a5       	ldd	r25, Y+44	; 0x2c
    2b0c:	01 97       	sbiw	r24, 0x01	; 1
    2b0e:	f1 f7       	brne	.-4      	; 0x2b0c <HCLCD_Vid8Bits_Init+0x10c>
    2b10:	9c a7       	std	Y+44, r25	; 0x2c
    2b12:	8b a7       	std	Y+43, r24	; 0x2b

	/*wait to 30ms*/
	_delay_ms(30);
	/*send function set command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_FUNCTION_SET);
    2b14:	88 e2       	ldi	r24, 0x28	; 40
    2b16:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <HCLCD_VidWriteCommand_8Bits>
    2b1a:	80 e0       	ldi	r24, 0x00	; 0
    2b1c:	90 e0       	ldi	r25, 0x00	; 0
    2b1e:	a0 e8       	ldi	r26, 0x80	; 128
    2b20:	bf e3       	ldi	r27, 0x3F	; 63
    2b22:	8f a3       	std	Y+39, r24	; 0x27
    2b24:	98 a7       	std	Y+40, r25	; 0x28
    2b26:	a9 a7       	std	Y+41, r26	; 0x29
    2b28:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2b2a:	6f a1       	ldd	r22, Y+39	; 0x27
    2b2c:	78 a5       	ldd	r23, Y+40	; 0x28
    2b2e:	89 a5       	ldd	r24, Y+41	; 0x29
    2b30:	9a a5       	ldd	r25, Y+42	; 0x2a
    2b32:	20 e0       	ldi	r18, 0x00	; 0
    2b34:	30 e0       	ldi	r19, 0x00	; 0
    2b36:	4a ef       	ldi	r20, 0xFA	; 250
    2b38:	54 e4       	ldi	r21, 0x44	; 68
    2b3a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2b3e:	dc 01       	movw	r26, r24
    2b40:	cb 01       	movw	r24, r22
    2b42:	8b a3       	std	Y+35, r24	; 0x23
    2b44:	9c a3       	std	Y+36, r25	; 0x24
    2b46:	ad a3       	std	Y+37, r26	; 0x25
    2b48:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2b4a:	6b a1       	ldd	r22, Y+35	; 0x23
    2b4c:	7c a1       	ldd	r23, Y+36	; 0x24
    2b4e:	8d a1       	ldd	r24, Y+37	; 0x25
    2b50:	9e a1       	ldd	r25, Y+38	; 0x26
    2b52:	20 e0       	ldi	r18, 0x00	; 0
    2b54:	30 e0       	ldi	r19, 0x00	; 0
    2b56:	40 e8       	ldi	r20, 0x80	; 128
    2b58:	5f e3       	ldi	r21, 0x3F	; 63
    2b5a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2b5e:	88 23       	and	r24, r24
    2b60:	2c f4       	brge	.+10     	; 0x2b6c <HCLCD_Vid8Bits_Init+0x16c>
		__ticks = 1;
    2b62:	81 e0       	ldi	r24, 0x01	; 1
    2b64:	90 e0       	ldi	r25, 0x00	; 0
    2b66:	9a a3       	std	Y+34, r25	; 0x22
    2b68:	89 a3       	std	Y+33, r24	; 0x21
    2b6a:	3f c0       	rjmp	.+126    	; 0x2bea <HCLCD_Vid8Bits_Init+0x1ea>
	else if (__tmp > 65535)
    2b6c:	6b a1       	ldd	r22, Y+35	; 0x23
    2b6e:	7c a1       	ldd	r23, Y+36	; 0x24
    2b70:	8d a1       	ldd	r24, Y+37	; 0x25
    2b72:	9e a1       	ldd	r25, Y+38	; 0x26
    2b74:	20 e0       	ldi	r18, 0x00	; 0
    2b76:	3f ef       	ldi	r19, 0xFF	; 255
    2b78:	4f e7       	ldi	r20, 0x7F	; 127
    2b7a:	57 e4       	ldi	r21, 0x47	; 71
    2b7c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2b80:	18 16       	cp	r1, r24
    2b82:	4c f5       	brge	.+82     	; 0x2bd6 <HCLCD_Vid8Bits_Init+0x1d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2b84:	6f a1       	ldd	r22, Y+39	; 0x27
    2b86:	78 a5       	ldd	r23, Y+40	; 0x28
    2b88:	89 a5       	ldd	r24, Y+41	; 0x29
    2b8a:	9a a5       	ldd	r25, Y+42	; 0x2a
    2b8c:	20 e0       	ldi	r18, 0x00	; 0
    2b8e:	30 e0       	ldi	r19, 0x00	; 0
    2b90:	40 e2       	ldi	r20, 0x20	; 32
    2b92:	51 e4       	ldi	r21, 0x41	; 65
    2b94:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2b98:	dc 01       	movw	r26, r24
    2b9a:	cb 01       	movw	r24, r22
    2b9c:	bc 01       	movw	r22, r24
    2b9e:	cd 01       	movw	r24, r26
    2ba0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2ba4:	dc 01       	movw	r26, r24
    2ba6:	cb 01       	movw	r24, r22
    2ba8:	9a a3       	std	Y+34, r25	; 0x22
    2baa:	89 a3       	std	Y+33, r24	; 0x21
    2bac:	0f c0       	rjmp	.+30     	; 0x2bcc <HCLCD_Vid8Bits_Init+0x1cc>
    2bae:	88 ec       	ldi	r24, 0xC8	; 200
    2bb0:	90 e0       	ldi	r25, 0x00	; 0
    2bb2:	98 a3       	std	Y+32, r25	; 0x20
    2bb4:	8f 8f       	std	Y+31, r24	; 0x1f
    2bb6:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2bb8:	98 a1       	ldd	r25, Y+32	; 0x20
    2bba:	01 97       	sbiw	r24, 0x01	; 1
    2bbc:	f1 f7       	brne	.-4      	; 0x2bba <HCLCD_Vid8Bits_Init+0x1ba>
    2bbe:	98 a3       	std	Y+32, r25	; 0x20
    2bc0:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2bc2:	89 a1       	ldd	r24, Y+33	; 0x21
    2bc4:	9a a1       	ldd	r25, Y+34	; 0x22
    2bc6:	01 97       	sbiw	r24, 0x01	; 1
    2bc8:	9a a3       	std	Y+34, r25	; 0x22
    2bca:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2bcc:	89 a1       	ldd	r24, Y+33	; 0x21
    2bce:	9a a1       	ldd	r25, Y+34	; 0x22
    2bd0:	00 97       	sbiw	r24, 0x00	; 0
    2bd2:	69 f7       	brne	.-38     	; 0x2bae <HCLCD_Vid8Bits_Init+0x1ae>
    2bd4:	14 c0       	rjmp	.+40     	; 0x2bfe <HCLCD_Vid8Bits_Init+0x1fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2bd6:	6b a1       	ldd	r22, Y+35	; 0x23
    2bd8:	7c a1       	ldd	r23, Y+36	; 0x24
    2bda:	8d a1       	ldd	r24, Y+37	; 0x25
    2bdc:	9e a1       	ldd	r25, Y+38	; 0x26
    2bde:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2be2:	dc 01       	movw	r26, r24
    2be4:	cb 01       	movw	r24, r22
    2be6:	9a a3       	std	Y+34, r25	; 0x22
    2be8:	89 a3       	std	Y+33, r24	; 0x21
    2bea:	89 a1       	ldd	r24, Y+33	; 0x21
    2bec:	9a a1       	ldd	r25, Y+34	; 0x22
    2bee:	9e 8f       	std	Y+30, r25	; 0x1e
    2bf0:	8d 8f       	std	Y+29, r24	; 0x1d
    2bf2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2bf4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2bf6:	01 97       	sbiw	r24, 0x01	; 1
    2bf8:	f1 f7       	brne	.-4      	; 0x2bf6 <HCLCD_Vid8Bits_Init+0x1f6>
    2bfa:	9e 8f       	std	Y+30, r25	; 0x1e
    2bfc:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
	/*send Display on/off  command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_DISPLAY_ON_OFF);
    2bfe:	8f e0       	ldi	r24, 0x0F	; 15
    2c00:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <HCLCD_VidWriteCommand_8Bits>
    2c04:	80 e0       	ldi	r24, 0x00	; 0
    2c06:	90 e0       	ldi	r25, 0x00	; 0
    2c08:	a0 e8       	ldi	r26, 0x80	; 128
    2c0a:	bf e3       	ldi	r27, 0x3F	; 63
    2c0c:	89 8f       	std	Y+25, r24	; 0x19
    2c0e:	9a 8f       	std	Y+26, r25	; 0x1a
    2c10:	ab 8f       	std	Y+27, r26	; 0x1b
    2c12:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2c14:	69 8d       	ldd	r22, Y+25	; 0x19
    2c16:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2c18:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2c1a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2c1c:	20 e0       	ldi	r18, 0x00	; 0
    2c1e:	30 e0       	ldi	r19, 0x00	; 0
    2c20:	4a ef       	ldi	r20, 0xFA	; 250
    2c22:	54 e4       	ldi	r21, 0x44	; 68
    2c24:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2c28:	dc 01       	movw	r26, r24
    2c2a:	cb 01       	movw	r24, r22
    2c2c:	8d 8b       	std	Y+21, r24	; 0x15
    2c2e:	9e 8b       	std	Y+22, r25	; 0x16
    2c30:	af 8b       	std	Y+23, r26	; 0x17
    2c32:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2c34:	6d 89       	ldd	r22, Y+21	; 0x15
    2c36:	7e 89       	ldd	r23, Y+22	; 0x16
    2c38:	8f 89       	ldd	r24, Y+23	; 0x17
    2c3a:	98 8d       	ldd	r25, Y+24	; 0x18
    2c3c:	20 e0       	ldi	r18, 0x00	; 0
    2c3e:	30 e0       	ldi	r19, 0x00	; 0
    2c40:	40 e8       	ldi	r20, 0x80	; 128
    2c42:	5f e3       	ldi	r21, 0x3F	; 63
    2c44:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2c48:	88 23       	and	r24, r24
    2c4a:	2c f4       	brge	.+10     	; 0x2c56 <HCLCD_Vid8Bits_Init+0x256>
		__ticks = 1;
    2c4c:	81 e0       	ldi	r24, 0x01	; 1
    2c4e:	90 e0       	ldi	r25, 0x00	; 0
    2c50:	9c 8b       	std	Y+20, r25	; 0x14
    2c52:	8b 8b       	std	Y+19, r24	; 0x13
    2c54:	3f c0       	rjmp	.+126    	; 0x2cd4 <HCLCD_Vid8Bits_Init+0x2d4>
	else if (__tmp > 65535)
    2c56:	6d 89       	ldd	r22, Y+21	; 0x15
    2c58:	7e 89       	ldd	r23, Y+22	; 0x16
    2c5a:	8f 89       	ldd	r24, Y+23	; 0x17
    2c5c:	98 8d       	ldd	r25, Y+24	; 0x18
    2c5e:	20 e0       	ldi	r18, 0x00	; 0
    2c60:	3f ef       	ldi	r19, 0xFF	; 255
    2c62:	4f e7       	ldi	r20, 0x7F	; 127
    2c64:	57 e4       	ldi	r21, 0x47	; 71
    2c66:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2c6a:	18 16       	cp	r1, r24
    2c6c:	4c f5       	brge	.+82     	; 0x2cc0 <HCLCD_Vid8Bits_Init+0x2c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2c6e:	69 8d       	ldd	r22, Y+25	; 0x19
    2c70:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2c72:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2c74:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2c76:	20 e0       	ldi	r18, 0x00	; 0
    2c78:	30 e0       	ldi	r19, 0x00	; 0
    2c7a:	40 e2       	ldi	r20, 0x20	; 32
    2c7c:	51 e4       	ldi	r21, 0x41	; 65
    2c7e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2c82:	dc 01       	movw	r26, r24
    2c84:	cb 01       	movw	r24, r22
    2c86:	bc 01       	movw	r22, r24
    2c88:	cd 01       	movw	r24, r26
    2c8a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2c8e:	dc 01       	movw	r26, r24
    2c90:	cb 01       	movw	r24, r22
    2c92:	9c 8b       	std	Y+20, r25	; 0x14
    2c94:	8b 8b       	std	Y+19, r24	; 0x13
    2c96:	0f c0       	rjmp	.+30     	; 0x2cb6 <HCLCD_Vid8Bits_Init+0x2b6>
    2c98:	88 ec       	ldi	r24, 0xC8	; 200
    2c9a:	90 e0       	ldi	r25, 0x00	; 0
    2c9c:	9a 8b       	std	Y+18, r25	; 0x12
    2c9e:	89 8b       	std	Y+17, r24	; 0x11
    2ca0:	89 89       	ldd	r24, Y+17	; 0x11
    2ca2:	9a 89       	ldd	r25, Y+18	; 0x12
    2ca4:	01 97       	sbiw	r24, 0x01	; 1
    2ca6:	f1 f7       	brne	.-4      	; 0x2ca4 <HCLCD_Vid8Bits_Init+0x2a4>
    2ca8:	9a 8b       	std	Y+18, r25	; 0x12
    2caa:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2cac:	8b 89       	ldd	r24, Y+19	; 0x13
    2cae:	9c 89       	ldd	r25, Y+20	; 0x14
    2cb0:	01 97       	sbiw	r24, 0x01	; 1
    2cb2:	9c 8b       	std	Y+20, r25	; 0x14
    2cb4:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2cb6:	8b 89       	ldd	r24, Y+19	; 0x13
    2cb8:	9c 89       	ldd	r25, Y+20	; 0x14
    2cba:	00 97       	sbiw	r24, 0x00	; 0
    2cbc:	69 f7       	brne	.-38     	; 0x2c98 <HCLCD_Vid8Bits_Init+0x298>
    2cbe:	14 c0       	rjmp	.+40     	; 0x2ce8 <HCLCD_Vid8Bits_Init+0x2e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2cc0:	6d 89       	ldd	r22, Y+21	; 0x15
    2cc2:	7e 89       	ldd	r23, Y+22	; 0x16
    2cc4:	8f 89       	ldd	r24, Y+23	; 0x17
    2cc6:	98 8d       	ldd	r25, Y+24	; 0x18
    2cc8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2ccc:	dc 01       	movw	r26, r24
    2cce:	cb 01       	movw	r24, r22
    2cd0:	9c 8b       	std	Y+20, r25	; 0x14
    2cd2:	8b 8b       	std	Y+19, r24	; 0x13
    2cd4:	8b 89       	ldd	r24, Y+19	; 0x13
    2cd6:	9c 89       	ldd	r25, Y+20	; 0x14
    2cd8:	98 8b       	std	Y+16, r25	; 0x10
    2cda:	8f 87       	std	Y+15, r24	; 0x0f
    2cdc:	8f 85       	ldd	r24, Y+15	; 0x0f
    2cde:	98 89       	ldd	r25, Y+16	; 0x10
    2ce0:	01 97       	sbiw	r24, 0x01	; 1
    2ce2:	f1 f7       	brne	.-4      	; 0x2ce0 <HCLCD_Vid8Bits_Init+0x2e0>
    2ce4:	98 8b       	std	Y+16, r25	; 0x10
    2ce6:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	/*send Display Clear  command*/
	HCLCD_VidWriteCommand_8Bits(DISPLAY_CLEAR);
    2ce8:	81 e0       	ldi	r24, 0x01	; 1
    2cea:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <HCLCD_VidWriteCommand_8Bits>
    2cee:	80 e0       	ldi	r24, 0x00	; 0
    2cf0:	90 e0       	ldi	r25, 0x00	; 0
    2cf2:	a0 e0       	ldi	r26, 0x00	; 0
    2cf4:	b0 e4       	ldi	r27, 0x40	; 64
    2cf6:	8b 87       	std	Y+11, r24	; 0x0b
    2cf8:	9c 87       	std	Y+12, r25	; 0x0c
    2cfa:	ad 87       	std	Y+13, r26	; 0x0d
    2cfc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2cfe:	6b 85       	ldd	r22, Y+11	; 0x0b
    2d00:	7c 85       	ldd	r23, Y+12	; 0x0c
    2d02:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d04:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d06:	20 e0       	ldi	r18, 0x00	; 0
    2d08:	30 e0       	ldi	r19, 0x00	; 0
    2d0a:	4a ef       	ldi	r20, 0xFA	; 250
    2d0c:	54 e4       	ldi	r21, 0x44	; 68
    2d0e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2d12:	dc 01       	movw	r26, r24
    2d14:	cb 01       	movw	r24, r22
    2d16:	8f 83       	std	Y+7, r24	; 0x07
    2d18:	98 87       	std	Y+8, r25	; 0x08
    2d1a:	a9 87       	std	Y+9, r26	; 0x09
    2d1c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2d1e:	6f 81       	ldd	r22, Y+7	; 0x07
    2d20:	78 85       	ldd	r23, Y+8	; 0x08
    2d22:	89 85       	ldd	r24, Y+9	; 0x09
    2d24:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d26:	20 e0       	ldi	r18, 0x00	; 0
    2d28:	30 e0       	ldi	r19, 0x00	; 0
    2d2a:	40 e8       	ldi	r20, 0x80	; 128
    2d2c:	5f e3       	ldi	r21, 0x3F	; 63
    2d2e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2d32:	88 23       	and	r24, r24
    2d34:	2c f4       	brge	.+10     	; 0x2d40 <HCLCD_Vid8Bits_Init+0x340>
		__ticks = 1;
    2d36:	81 e0       	ldi	r24, 0x01	; 1
    2d38:	90 e0       	ldi	r25, 0x00	; 0
    2d3a:	9e 83       	std	Y+6, r25	; 0x06
    2d3c:	8d 83       	std	Y+5, r24	; 0x05
    2d3e:	3f c0       	rjmp	.+126    	; 0x2dbe <HCLCD_Vid8Bits_Init+0x3be>
	else if (__tmp > 65535)
    2d40:	6f 81       	ldd	r22, Y+7	; 0x07
    2d42:	78 85       	ldd	r23, Y+8	; 0x08
    2d44:	89 85       	ldd	r24, Y+9	; 0x09
    2d46:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d48:	20 e0       	ldi	r18, 0x00	; 0
    2d4a:	3f ef       	ldi	r19, 0xFF	; 255
    2d4c:	4f e7       	ldi	r20, 0x7F	; 127
    2d4e:	57 e4       	ldi	r21, 0x47	; 71
    2d50:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2d54:	18 16       	cp	r1, r24
    2d56:	4c f5       	brge	.+82     	; 0x2daa <HCLCD_Vid8Bits_Init+0x3aa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2d58:	6b 85       	ldd	r22, Y+11	; 0x0b
    2d5a:	7c 85       	ldd	r23, Y+12	; 0x0c
    2d5c:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d5e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d60:	20 e0       	ldi	r18, 0x00	; 0
    2d62:	30 e0       	ldi	r19, 0x00	; 0
    2d64:	40 e2       	ldi	r20, 0x20	; 32
    2d66:	51 e4       	ldi	r21, 0x41	; 65
    2d68:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2d6c:	dc 01       	movw	r26, r24
    2d6e:	cb 01       	movw	r24, r22
    2d70:	bc 01       	movw	r22, r24
    2d72:	cd 01       	movw	r24, r26
    2d74:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2d78:	dc 01       	movw	r26, r24
    2d7a:	cb 01       	movw	r24, r22
    2d7c:	9e 83       	std	Y+6, r25	; 0x06
    2d7e:	8d 83       	std	Y+5, r24	; 0x05
    2d80:	0f c0       	rjmp	.+30     	; 0x2da0 <HCLCD_Vid8Bits_Init+0x3a0>
    2d82:	88 ec       	ldi	r24, 0xC8	; 200
    2d84:	90 e0       	ldi	r25, 0x00	; 0
    2d86:	9c 83       	std	Y+4, r25	; 0x04
    2d88:	8b 83       	std	Y+3, r24	; 0x03
    2d8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d8e:	01 97       	sbiw	r24, 0x01	; 1
    2d90:	f1 f7       	brne	.-4      	; 0x2d8e <HCLCD_Vid8Bits_Init+0x38e>
    2d92:	9c 83       	std	Y+4, r25	; 0x04
    2d94:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2d96:	8d 81       	ldd	r24, Y+5	; 0x05
    2d98:	9e 81       	ldd	r25, Y+6	; 0x06
    2d9a:	01 97       	sbiw	r24, 0x01	; 1
    2d9c:	9e 83       	std	Y+6, r25	; 0x06
    2d9e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2da0:	8d 81       	ldd	r24, Y+5	; 0x05
    2da2:	9e 81       	ldd	r25, Y+6	; 0x06
    2da4:	00 97       	sbiw	r24, 0x00	; 0
    2da6:	69 f7       	brne	.-38     	; 0x2d82 <HCLCD_Vid8Bits_Init+0x382>
    2da8:	14 c0       	rjmp	.+40     	; 0x2dd2 <HCLCD_Vid8Bits_Init+0x3d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2daa:	6f 81       	ldd	r22, Y+7	; 0x07
    2dac:	78 85       	ldd	r23, Y+8	; 0x08
    2dae:	89 85       	ldd	r24, Y+9	; 0x09
    2db0:	9a 85       	ldd	r25, Y+10	; 0x0a
    2db2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2db6:	dc 01       	movw	r26, r24
    2db8:	cb 01       	movw	r24, r22
    2dba:	9e 83       	std	Y+6, r25	; 0x06
    2dbc:	8d 83       	std	Y+5, r24	; 0x05
    2dbe:	8d 81       	ldd	r24, Y+5	; 0x05
    2dc0:	9e 81       	ldd	r25, Y+6	; 0x06
    2dc2:	9a 83       	std	Y+2, r25	; 0x02
    2dc4:	89 83       	std	Y+1, r24	; 0x01
    2dc6:	89 81       	ldd	r24, Y+1	; 0x01
    2dc8:	9a 81       	ldd	r25, Y+2	; 0x02
    2dca:	01 97       	sbiw	r24, 0x01	; 1
    2dcc:	f1 f7       	brne	.-4      	; 0x2dca <HCLCD_Vid8Bits_Init+0x3ca>
    2dce:	9a 83       	std	Y+2, r25	; 0x02
    2dd0:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	/*send Entry Mode  set command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_ENTRY_MODE_SET);
    2dd2:	86 e0       	ldi	r24, 0x06	; 6
    2dd4:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <HCLCD_VidWriteCommand_8Bits>
}
    2dd8:	e8 96       	adiw	r28, 0x38	; 56
    2dda:	0f b6       	in	r0, 0x3f	; 63
    2ddc:	f8 94       	cli
    2dde:	de bf       	out	0x3e, r29	; 62
    2de0:	0f be       	out	0x3f, r0	; 63
    2de2:	cd bf       	out	0x3d, r28	; 61
    2de4:	cf 91       	pop	r28
    2de6:	df 91       	pop	r29
    2de8:	08 95       	ret

00002dea <HCLCD_VidWriteChar_8Bits>:
void HCLCD_VidWriteChar_8Bits(u8 Copy_u8Data)
{
    2dea:	df 93       	push	r29
    2dec:	cf 93       	push	r28
    2dee:	cd b7       	in	r28, 0x3d	; 61
    2df0:	de b7       	in	r29, 0x3e	; 62
    2df2:	6d 97       	sbiw	r28, 0x1d	; 29
    2df4:	0f b6       	in	r0, 0x3f	; 63
    2df6:	f8 94       	cli
    2df8:	de bf       	out	0x3e, r29	; 62
    2dfa:	0f be       	out	0x3f, r0	; 63
    2dfc:	cd bf       	out	0x3d, r28	; 61
    2dfe:	8d 8f       	std	Y+29, r24	; 0x1d
	/*select Data register--> Write one on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_HIGH);
    2e00:	81 e0       	ldi	r24, 0x01	; 1
    2e02:	60 e0       	ldi	r22, 0x00	; 0
    2e04:	41 e0       	ldi	r20, 0x01	; 1
    2e06:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send Command ON port Data*/
	MDIO_Error_State_SetPortValue(DATA_PORT,Copy_u8Data);
    2e0a:	80 e0       	ldi	r24, 0x00	; 0
    2e0c:	6d 8d       	ldd	r22, Y+29	; 0x1d
    2e0e:	0e 94 8d 0a 	call	0x151a	; 0x151a <MDIO_Error_State_SetPortValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    2e12:	82 e0       	ldi	r24, 0x02	; 2
    2e14:	60 e0       	ldi	r22, 0x00	; 0
    2e16:	41 e0       	ldi	r20, 0x01	; 1
    2e18:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
    2e1c:	80 e0       	ldi	r24, 0x00	; 0
    2e1e:	90 e0       	ldi	r25, 0x00	; 0
    2e20:	a0 e0       	ldi	r26, 0x00	; 0
    2e22:	b0 e4       	ldi	r27, 0x40	; 64
    2e24:	89 8f       	std	Y+25, r24	; 0x19
    2e26:	9a 8f       	std	Y+26, r25	; 0x1a
    2e28:	ab 8f       	std	Y+27, r26	; 0x1b
    2e2a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2e2c:	69 8d       	ldd	r22, Y+25	; 0x19
    2e2e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2e30:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2e32:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2e34:	20 e0       	ldi	r18, 0x00	; 0
    2e36:	30 e0       	ldi	r19, 0x00	; 0
    2e38:	4a ef       	ldi	r20, 0xFA	; 250
    2e3a:	54 e4       	ldi	r21, 0x44	; 68
    2e3c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2e40:	dc 01       	movw	r26, r24
    2e42:	cb 01       	movw	r24, r22
    2e44:	8d 8b       	std	Y+21, r24	; 0x15
    2e46:	9e 8b       	std	Y+22, r25	; 0x16
    2e48:	af 8b       	std	Y+23, r26	; 0x17
    2e4a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2e4c:	6d 89       	ldd	r22, Y+21	; 0x15
    2e4e:	7e 89       	ldd	r23, Y+22	; 0x16
    2e50:	8f 89       	ldd	r24, Y+23	; 0x17
    2e52:	98 8d       	ldd	r25, Y+24	; 0x18
    2e54:	20 e0       	ldi	r18, 0x00	; 0
    2e56:	30 e0       	ldi	r19, 0x00	; 0
    2e58:	40 e8       	ldi	r20, 0x80	; 128
    2e5a:	5f e3       	ldi	r21, 0x3F	; 63
    2e5c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2e60:	88 23       	and	r24, r24
    2e62:	2c f4       	brge	.+10     	; 0x2e6e <HCLCD_VidWriteChar_8Bits+0x84>
		__ticks = 1;
    2e64:	81 e0       	ldi	r24, 0x01	; 1
    2e66:	90 e0       	ldi	r25, 0x00	; 0
    2e68:	9c 8b       	std	Y+20, r25	; 0x14
    2e6a:	8b 8b       	std	Y+19, r24	; 0x13
    2e6c:	3f c0       	rjmp	.+126    	; 0x2eec <HCLCD_VidWriteChar_8Bits+0x102>
	else if (__tmp > 65535)
    2e6e:	6d 89       	ldd	r22, Y+21	; 0x15
    2e70:	7e 89       	ldd	r23, Y+22	; 0x16
    2e72:	8f 89       	ldd	r24, Y+23	; 0x17
    2e74:	98 8d       	ldd	r25, Y+24	; 0x18
    2e76:	20 e0       	ldi	r18, 0x00	; 0
    2e78:	3f ef       	ldi	r19, 0xFF	; 255
    2e7a:	4f e7       	ldi	r20, 0x7F	; 127
    2e7c:	57 e4       	ldi	r21, 0x47	; 71
    2e7e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2e82:	18 16       	cp	r1, r24
    2e84:	4c f5       	brge	.+82     	; 0x2ed8 <HCLCD_VidWriteChar_8Bits+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2e86:	69 8d       	ldd	r22, Y+25	; 0x19
    2e88:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2e8a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2e8c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2e8e:	20 e0       	ldi	r18, 0x00	; 0
    2e90:	30 e0       	ldi	r19, 0x00	; 0
    2e92:	40 e2       	ldi	r20, 0x20	; 32
    2e94:	51 e4       	ldi	r21, 0x41	; 65
    2e96:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2e9a:	dc 01       	movw	r26, r24
    2e9c:	cb 01       	movw	r24, r22
    2e9e:	bc 01       	movw	r22, r24
    2ea0:	cd 01       	movw	r24, r26
    2ea2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2ea6:	dc 01       	movw	r26, r24
    2ea8:	cb 01       	movw	r24, r22
    2eaa:	9c 8b       	std	Y+20, r25	; 0x14
    2eac:	8b 8b       	std	Y+19, r24	; 0x13
    2eae:	0f c0       	rjmp	.+30     	; 0x2ece <HCLCD_VidWriteChar_8Bits+0xe4>
    2eb0:	88 ec       	ldi	r24, 0xC8	; 200
    2eb2:	90 e0       	ldi	r25, 0x00	; 0
    2eb4:	9a 8b       	std	Y+18, r25	; 0x12
    2eb6:	89 8b       	std	Y+17, r24	; 0x11
    2eb8:	89 89       	ldd	r24, Y+17	; 0x11
    2eba:	9a 89       	ldd	r25, Y+18	; 0x12
    2ebc:	01 97       	sbiw	r24, 0x01	; 1
    2ebe:	f1 f7       	brne	.-4      	; 0x2ebc <HCLCD_VidWriteChar_8Bits+0xd2>
    2ec0:	9a 8b       	std	Y+18, r25	; 0x12
    2ec2:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2ec4:	8b 89       	ldd	r24, Y+19	; 0x13
    2ec6:	9c 89       	ldd	r25, Y+20	; 0x14
    2ec8:	01 97       	sbiw	r24, 0x01	; 1
    2eca:	9c 8b       	std	Y+20, r25	; 0x14
    2ecc:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2ece:	8b 89       	ldd	r24, Y+19	; 0x13
    2ed0:	9c 89       	ldd	r25, Y+20	; 0x14
    2ed2:	00 97       	sbiw	r24, 0x00	; 0
    2ed4:	69 f7       	brne	.-38     	; 0x2eb0 <HCLCD_VidWriteChar_8Bits+0xc6>
    2ed6:	14 c0       	rjmp	.+40     	; 0x2f00 <HCLCD_VidWriteChar_8Bits+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2ed8:	6d 89       	ldd	r22, Y+21	; 0x15
    2eda:	7e 89       	ldd	r23, Y+22	; 0x16
    2edc:	8f 89       	ldd	r24, Y+23	; 0x17
    2ede:	98 8d       	ldd	r25, Y+24	; 0x18
    2ee0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2ee4:	dc 01       	movw	r26, r24
    2ee6:	cb 01       	movw	r24, r22
    2ee8:	9c 8b       	std	Y+20, r25	; 0x14
    2eea:	8b 8b       	std	Y+19, r24	; 0x13
    2eec:	8b 89       	ldd	r24, Y+19	; 0x13
    2eee:	9c 89       	ldd	r25, Y+20	; 0x14
    2ef0:	98 8b       	std	Y+16, r25	; 0x10
    2ef2:	8f 87       	std	Y+15, r24	; 0x0f
    2ef4:	8f 85       	ldd	r24, Y+15	; 0x0f
    2ef6:	98 89       	ldd	r25, Y+16	; 0x10
    2ef8:	01 97       	sbiw	r24, 0x01	; 1
    2efa:	f1 f7       	brne	.-4      	; 0x2ef8 <HCLCD_VidWriteChar_8Bits+0x10e>
    2efc:	98 8b       	std	Y+16, r25	; 0x10
    2efe:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    2f00:	82 e0       	ldi	r24, 0x02	; 2
    2f02:	60 e0       	ldi	r22, 0x00	; 0
    2f04:	40 e0       	ldi	r20, 0x00	; 0
    2f06:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
    2f0a:	80 e0       	ldi	r24, 0x00	; 0
    2f0c:	90 e0       	ldi	r25, 0x00	; 0
    2f0e:	a0 e0       	ldi	r26, 0x00	; 0
    2f10:	b0 e4       	ldi	r27, 0x40	; 64
    2f12:	8b 87       	std	Y+11, r24	; 0x0b
    2f14:	9c 87       	std	Y+12, r25	; 0x0c
    2f16:	ad 87       	std	Y+13, r26	; 0x0d
    2f18:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2f1a:	6b 85       	ldd	r22, Y+11	; 0x0b
    2f1c:	7c 85       	ldd	r23, Y+12	; 0x0c
    2f1e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f20:	9e 85       	ldd	r25, Y+14	; 0x0e
    2f22:	20 e0       	ldi	r18, 0x00	; 0
    2f24:	30 e0       	ldi	r19, 0x00	; 0
    2f26:	4a ef       	ldi	r20, 0xFA	; 250
    2f28:	54 e4       	ldi	r21, 0x44	; 68
    2f2a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2f2e:	dc 01       	movw	r26, r24
    2f30:	cb 01       	movw	r24, r22
    2f32:	8f 83       	std	Y+7, r24	; 0x07
    2f34:	98 87       	std	Y+8, r25	; 0x08
    2f36:	a9 87       	std	Y+9, r26	; 0x09
    2f38:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2f3a:	6f 81       	ldd	r22, Y+7	; 0x07
    2f3c:	78 85       	ldd	r23, Y+8	; 0x08
    2f3e:	89 85       	ldd	r24, Y+9	; 0x09
    2f40:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f42:	20 e0       	ldi	r18, 0x00	; 0
    2f44:	30 e0       	ldi	r19, 0x00	; 0
    2f46:	40 e8       	ldi	r20, 0x80	; 128
    2f48:	5f e3       	ldi	r21, 0x3F	; 63
    2f4a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2f4e:	88 23       	and	r24, r24
    2f50:	2c f4       	brge	.+10     	; 0x2f5c <HCLCD_VidWriteChar_8Bits+0x172>
		__ticks = 1;
    2f52:	81 e0       	ldi	r24, 0x01	; 1
    2f54:	90 e0       	ldi	r25, 0x00	; 0
    2f56:	9e 83       	std	Y+6, r25	; 0x06
    2f58:	8d 83       	std	Y+5, r24	; 0x05
    2f5a:	3f c0       	rjmp	.+126    	; 0x2fda <HCLCD_VidWriteChar_8Bits+0x1f0>
	else if (__tmp > 65535)
    2f5c:	6f 81       	ldd	r22, Y+7	; 0x07
    2f5e:	78 85       	ldd	r23, Y+8	; 0x08
    2f60:	89 85       	ldd	r24, Y+9	; 0x09
    2f62:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f64:	20 e0       	ldi	r18, 0x00	; 0
    2f66:	3f ef       	ldi	r19, 0xFF	; 255
    2f68:	4f e7       	ldi	r20, 0x7F	; 127
    2f6a:	57 e4       	ldi	r21, 0x47	; 71
    2f6c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2f70:	18 16       	cp	r1, r24
    2f72:	4c f5       	brge	.+82     	; 0x2fc6 <HCLCD_VidWriteChar_8Bits+0x1dc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2f74:	6b 85       	ldd	r22, Y+11	; 0x0b
    2f76:	7c 85       	ldd	r23, Y+12	; 0x0c
    2f78:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f7a:	9e 85       	ldd	r25, Y+14	; 0x0e
    2f7c:	20 e0       	ldi	r18, 0x00	; 0
    2f7e:	30 e0       	ldi	r19, 0x00	; 0
    2f80:	40 e2       	ldi	r20, 0x20	; 32
    2f82:	51 e4       	ldi	r21, 0x41	; 65
    2f84:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2f88:	dc 01       	movw	r26, r24
    2f8a:	cb 01       	movw	r24, r22
    2f8c:	bc 01       	movw	r22, r24
    2f8e:	cd 01       	movw	r24, r26
    2f90:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2f94:	dc 01       	movw	r26, r24
    2f96:	cb 01       	movw	r24, r22
    2f98:	9e 83       	std	Y+6, r25	; 0x06
    2f9a:	8d 83       	std	Y+5, r24	; 0x05
    2f9c:	0f c0       	rjmp	.+30     	; 0x2fbc <HCLCD_VidWriteChar_8Bits+0x1d2>
    2f9e:	88 ec       	ldi	r24, 0xC8	; 200
    2fa0:	90 e0       	ldi	r25, 0x00	; 0
    2fa2:	9c 83       	std	Y+4, r25	; 0x04
    2fa4:	8b 83       	std	Y+3, r24	; 0x03
    2fa6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa8:	9c 81       	ldd	r25, Y+4	; 0x04
    2faa:	01 97       	sbiw	r24, 0x01	; 1
    2fac:	f1 f7       	brne	.-4      	; 0x2faa <HCLCD_VidWriteChar_8Bits+0x1c0>
    2fae:	9c 83       	std	Y+4, r25	; 0x04
    2fb0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2fb2:	8d 81       	ldd	r24, Y+5	; 0x05
    2fb4:	9e 81       	ldd	r25, Y+6	; 0x06
    2fb6:	01 97       	sbiw	r24, 0x01	; 1
    2fb8:	9e 83       	std	Y+6, r25	; 0x06
    2fba:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2fbc:	8d 81       	ldd	r24, Y+5	; 0x05
    2fbe:	9e 81       	ldd	r25, Y+6	; 0x06
    2fc0:	00 97       	sbiw	r24, 0x00	; 0
    2fc2:	69 f7       	brne	.-38     	; 0x2f9e <HCLCD_VidWriteChar_8Bits+0x1b4>
    2fc4:	14 c0       	rjmp	.+40     	; 0x2fee <HCLCD_VidWriteChar_8Bits+0x204>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2fc6:	6f 81       	ldd	r22, Y+7	; 0x07
    2fc8:	78 85       	ldd	r23, Y+8	; 0x08
    2fca:	89 85       	ldd	r24, Y+9	; 0x09
    2fcc:	9a 85       	ldd	r25, Y+10	; 0x0a
    2fce:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2fd2:	dc 01       	movw	r26, r24
    2fd4:	cb 01       	movw	r24, r22
    2fd6:	9e 83       	std	Y+6, r25	; 0x06
    2fd8:	8d 83       	std	Y+5, r24	; 0x05
    2fda:	8d 81       	ldd	r24, Y+5	; 0x05
    2fdc:	9e 81       	ldd	r25, Y+6	; 0x06
    2fde:	9a 83       	std	Y+2, r25	; 0x02
    2fe0:	89 83       	std	Y+1, r24	; 0x01
    2fe2:	89 81       	ldd	r24, Y+1	; 0x01
    2fe4:	9a 81       	ldd	r25, Y+2	; 0x02
    2fe6:	01 97       	sbiw	r24, 0x01	; 1
    2fe8:	f1 f7       	brne	.-4      	; 0x2fe6 <HCLCD_VidWriteChar_8Bits+0x1fc>
    2fea:	9a 83       	std	Y+2, r25	; 0x02
    2fec:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);	
    2fee:	82 e0       	ldi	r24, 0x02	; 2
    2ff0:	60 e0       	ldi	r22, 0x00	; 0
    2ff2:	41 e0       	ldi	r20, 0x01	; 1
    2ff4:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
}
    2ff8:	6d 96       	adiw	r28, 0x1d	; 29
    2ffa:	0f b6       	in	r0, 0x3f	; 63
    2ffc:	f8 94       	cli
    2ffe:	de bf       	out	0x3e, r29	; 62
    3000:	0f be       	out	0x3f, r0	; 63
    3002:	cd bf       	out	0x3d, r28	; 61
    3004:	cf 91       	pop	r28
    3006:	df 91       	pop	r29
    3008:	08 95       	ret

0000300a <HCLCD_VidWriteString_8Bits>:

void HCLCD_VidWriteString_8Bits(u8* PCopy_u8String)
{
    300a:	df 93       	push	r29
    300c:	cf 93       	push	r28
    300e:	00 d0       	rcall	.+0      	; 0x3010 <HCLCD_VidWriteString_8Bits+0x6>
    3010:	0f 92       	push	r0
    3012:	cd b7       	in	r28, 0x3d	; 61
    3014:	de b7       	in	r29, 0x3e	; 62
    3016:	9b 83       	std	Y+3, r25	; 0x03
    3018:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Count=0;
    301a:	19 82       	std	Y+1, r1	; 0x01
    301c:	0e c0       	rjmp	.+28     	; 0x303a <HCLCD_VidWriteString_8Bits+0x30>
	while(PCopy_u8String[Loc_u8Count]!=NULL)
	{
		HCLCD_VidWriteChar_8Bits(PCopy_u8String[Loc_u8Count]);
    301e:	89 81       	ldd	r24, Y+1	; 0x01
    3020:	28 2f       	mov	r18, r24
    3022:	30 e0       	ldi	r19, 0x00	; 0
    3024:	8a 81       	ldd	r24, Y+2	; 0x02
    3026:	9b 81       	ldd	r25, Y+3	; 0x03
    3028:	fc 01       	movw	r30, r24
    302a:	e2 0f       	add	r30, r18
    302c:	f3 1f       	adc	r31, r19
    302e:	80 81       	ld	r24, Z
    3030:	0e 94 f5 16 	call	0x2dea	; 0x2dea <HCLCD_VidWriteChar_8Bits>
		Loc_u8Count++;
    3034:	89 81       	ldd	r24, Y+1	; 0x01
    3036:	8f 5f       	subi	r24, 0xFF	; 255
    3038:	89 83       	std	Y+1, r24	; 0x01
}

void HCLCD_VidWriteString_8Bits(u8* PCopy_u8String)
{
	u8 Loc_u8Count=0;
	while(PCopy_u8String[Loc_u8Count]!=NULL)
    303a:	89 81       	ldd	r24, Y+1	; 0x01
    303c:	28 2f       	mov	r18, r24
    303e:	30 e0       	ldi	r19, 0x00	; 0
    3040:	8a 81       	ldd	r24, Y+2	; 0x02
    3042:	9b 81       	ldd	r25, Y+3	; 0x03
    3044:	fc 01       	movw	r30, r24
    3046:	e2 0f       	add	r30, r18
    3048:	f3 1f       	adc	r31, r19
    304a:	80 81       	ld	r24, Z
    304c:	88 23       	and	r24, r24
    304e:	39 f7       	brne	.-50     	; 0x301e <HCLCD_VidWriteString_8Bits+0x14>
	{
		HCLCD_VidWriteChar_8Bits(PCopy_u8String[Loc_u8Count]);
		Loc_u8Count++;
	}
}
    3050:	0f 90       	pop	r0
    3052:	0f 90       	pop	r0
    3054:	0f 90       	pop	r0
    3056:	cf 91       	pop	r28
    3058:	df 91       	pop	r29
    305a:	08 95       	ret

0000305c <HCLCD_VidWriteNumber_8Bits>:
void HCLCD_VidWriteNumber_8Bits(u32 Copy_u8Number)
{
    305c:	0f 93       	push	r16
    305e:	1f 93       	push	r17
    3060:	df 93       	push	r29
    3062:	cf 93       	push	r28
    3064:	cd b7       	in	r28, 0x3d	; 61
    3066:	de b7       	in	r29, 0x3e	; 62
    3068:	60 97       	sbiw	r28, 0x10	; 16
    306a:	0f b6       	in	r0, 0x3f	; 63
    306c:	f8 94       	cli
    306e:	de bf       	out	0x3e, r29	; 62
    3070:	0f be       	out	0x3f, r0	; 63
    3072:	cd bf       	out	0x3d, r28	; 61
    3074:	6d 87       	std	Y+13, r22	; 0x0d
    3076:	7e 87       	std	Y+14, r23	; 0x0e
    3078:	8f 87       	std	Y+15, r24	; 0x0f
    307a:	98 8b       	std	Y+16, r25	; 0x10
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
    307c:	1a 82       	std	Y+2, r1	; 0x02
	if(Copy_u8Number>0)
    307e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3080:	9e 85       	ldd	r25, Y+14	; 0x0e
    3082:	af 85       	ldd	r26, Y+15	; 0x0f
    3084:	b8 89       	ldd	r27, Y+16	; 0x10
    3086:	00 97       	sbiw	r24, 0x00	; 0
    3088:	a1 05       	cpc	r26, r1
    308a:	b1 05       	cpc	r27, r1
    308c:	09 f4       	brne	.+2      	; 0x3090 <HCLCD_VidWriteNumber_8Bits+0x34>
    308e:	4f c0       	rjmp	.+158    	; 0x312e <HCLCD_VidWriteNumber_8Bits+0xd2>
    3090:	2d c0       	rjmp	.+90     	; 0x30ec <HCLCD_VidWriteNumber_8Bits+0x90>
	{
		while(Copy_u8Number!=0)
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
    3092:	8a 81       	ldd	r24, Y+2	; 0x02
    3094:	08 2f       	mov	r16, r24
    3096:	10 e0       	ldi	r17, 0x00	; 0
    3098:	8d 85       	ldd	r24, Y+13	; 0x0d
    309a:	9e 85       	ldd	r25, Y+14	; 0x0e
    309c:	af 85       	ldd	r26, Y+15	; 0x0f
    309e:	b8 89       	ldd	r27, Y+16	; 0x10
    30a0:	2a e0       	ldi	r18, 0x0A	; 10
    30a2:	30 e0       	ldi	r19, 0x00	; 0
    30a4:	40 e0       	ldi	r20, 0x00	; 0
    30a6:	50 e0       	ldi	r21, 0x00	; 0
    30a8:	bc 01       	movw	r22, r24
    30aa:	cd 01       	movw	r24, r26
    30ac:	0e 94 07 37 	call	0x6e0e	; 0x6e0e <__udivmodsi4>
    30b0:	dc 01       	movw	r26, r24
    30b2:	cb 01       	movw	r24, r22
    30b4:	28 2f       	mov	r18, r24
    30b6:	ce 01       	movw	r24, r28
    30b8:	03 96       	adiw	r24, 0x03	; 3
    30ba:	fc 01       	movw	r30, r24
    30bc:	e0 0f       	add	r30, r16
    30be:	f1 1f       	adc	r31, r17
    30c0:	20 83       	st	Z, r18
			Copy_u8Number/=10;
    30c2:	8d 85       	ldd	r24, Y+13	; 0x0d
    30c4:	9e 85       	ldd	r25, Y+14	; 0x0e
    30c6:	af 85       	ldd	r26, Y+15	; 0x0f
    30c8:	b8 89       	ldd	r27, Y+16	; 0x10
    30ca:	2a e0       	ldi	r18, 0x0A	; 10
    30cc:	30 e0       	ldi	r19, 0x00	; 0
    30ce:	40 e0       	ldi	r20, 0x00	; 0
    30d0:	50 e0       	ldi	r21, 0x00	; 0
    30d2:	bc 01       	movw	r22, r24
    30d4:	cd 01       	movw	r24, r26
    30d6:	0e 94 07 37 	call	0x6e0e	; 0x6e0e <__udivmodsi4>
    30da:	da 01       	movw	r26, r20
    30dc:	c9 01       	movw	r24, r18
    30de:	8d 87       	std	Y+13, r24	; 0x0d
    30e0:	9e 87       	std	Y+14, r25	; 0x0e
    30e2:	af 87       	std	Y+15, r26	; 0x0f
    30e4:	b8 8b       	std	Y+16, r27	; 0x10
			LOC_Count++;
    30e6:	8a 81       	ldd	r24, Y+2	; 0x02
    30e8:	8f 5f       	subi	r24, 0xFF	; 255
    30ea:	8a 83       	std	Y+2, r24	; 0x02
{
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
	if(Copy_u8Number>0)
	{
		while(Copy_u8Number!=0)
    30ec:	8d 85       	ldd	r24, Y+13	; 0x0d
    30ee:	9e 85       	ldd	r25, Y+14	; 0x0e
    30f0:	af 85       	ldd	r26, Y+15	; 0x0f
    30f2:	b8 89       	ldd	r27, Y+16	; 0x10
    30f4:	00 97       	sbiw	r24, 0x00	; 0
    30f6:	a1 05       	cpc	r26, r1
    30f8:	b1 05       	cpc	r27, r1
    30fa:	59 f6       	brne	.-106    	; 0x3092 <HCLCD_VidWriteNumber_8Bits+0x36>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    30fc:	8a 81       	ldd	r24, Y+2	; 0x02
    30fe:	81 50       	subi	r24, 0x01	; 1
    3100:	89 83       	std	Y+1, r24	; 0x01
    3102:	11 c0       	rjmp	.+34     	; 0x3126 <HCLCD_VidWriteNumber_8Bits+0xca>
		{
			HCLCD_VidWriteChar_8Bits(ARR_Digits[i]+'0');
    3104:	89 81       	ldd	r24, Y+1	; 0x01
    3106:	28 2f       	mov	r18, r24
    3108:	33 27       	eor	r19, r19
    310a:	27 fd       	sbrc	r18, 7
    310c:	30 95       	com	r19
    310e:	ce 01       	movw	r24, r28
    3110:	03 96       	adiw	r24, 0x03	; 3
    3112:	fc 01       	movw	r30, r24
    3114:	e2 0f       	add	r30, r18
    3116:	f3 1f       	adc	r31, r19
    3118:	80 81       	ld	r24, Z
    311a:	80 5d       	subi	r24, 0xD0	; 208
    311c:	0e 94 f5 16 	call	0x2dea	; 0x2dea <HCLCD_VidWriteChar_8Bits>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    3120:	89 81       	ldd	r24, Y+1	; 0x01
    3122:	81 50       	subi	r24, 0x01	; 1
    3124:	89 83       	std	Y+1, r24	; 0x01
    3126:	89 81       	ldd	r24, Y+1	; 0x01
    3128:	88 23       	and	r24, r24
    312a:	64 f7       	brge	.-40     	; 0x3104 <HCLCD_VidWriteNumber_8Bits+0xa8>
    312c:	03 c0       	rjmp	.+6      	; 0x3134 <HCLCD_VidWriteNumber_8Bits+0xd8>
			HCLCD_VidWriteChar_8Bits(ARR_Digits[i]+'0');
		}
	}
	else
	{
		HCLCD_VidWriteChar_8Bits('0');
    312e:	80 e3       	ldi	r24, 0x30	; 48
    3130:	0e 94 f5 16 	call	0x2dea	; 0x2dea <HCLCD_VidWriteChar_8Bits>
	}
}
    3134:	60 96       	adiw	r28, 0x10	; 16
    3136:	0f b6       	in	r0, 0x3f	; 63
    3138:	f8 94       	cli
    313a:	de bf       	out	0x3e, r29	; 62
    313c:	0f be       	out	0x3f, r0	; 63
    313e:	cd bf       	out	0x3d, r28	; 61
    3140:	cf 91       	pop	r28
    3142:	df 91       	pop	r29
    3144:	1f 91       	pop	r17
    3146:	0f 91       	pop	r16
    3148:	08 95       	ret

0000314a <HCLCD_VidSetPosition>:
void HCLCD_VidSetPosition(u8 Copy_u8LineNumber , u8 Copy_u8PositionNumber)
{
    314a:	df 93       	push	r29
    314c:	cf 93       	push	r28
    314e:	00 d0       	rcall	.+0      	; 0x3150 <HCLCD_VidSetPosition+0x6>
    3150:	cd b7       	in	r28, 0x3d	; 61
    3152:	de b7       	in	r29, 0x3e	; 62
    3154:	89 83       	std	Y+1, r24	; 0x01
    3156:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8LineNumber==HCLCD_LINE1)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    3158:	89 81       	ldd	r24, Y+1	; 0x01
    315a:	81 30       	cpi	r24, 0x01	; 1
    315c:	41 f4       	brne	.+16     	; 0x316e <HCLCD_VidSetPosition+0x24>
    315e:	8a 81       	ldd	r24, Y+2	; 0x02
    3160:	80 31       	cpi	r24, 0x10	; 16
    3162:	28 f4       	brcc	.+10     	; 0x316e <HCLCD_VidSetPosition+0x24>
	{
		HCLCD_VidWriteCommand_8Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber));
    3164:	8a 81       	ldd	r24, Y+2	; 0x02
    3166:	80 58       	subi	r24, 0x80	; 128
    3168:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <HCLCD_VidWriteCommand_8Bits>
    316c:	0a c0       	rjmp	.+20     	; 0x3182 <HCLCD_VidSetPosition+0x38>
	}
	else if((Copy_u8LineNumber==HCLCD_LINE2)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    316e:	89 81       	ldd	r24, Y+1	; 0x01
    3170:	82 30       	cpi	r24, 0x02	; 2
    3172:	39 f4       	brne	.+14     	; 0x3182 <HCLCD_VidSetPosition+0x38>
    3174:	8a 81       	ldd	r24, Y+2	; 0x02
    3176:	80 31       	cpi	r24, 0x10	; 16
    3178:	20 f4       	brcc	.+8      	; 0x3182 <HCLCD_VidSetPosition+0x38>
	{
		HCLCD_VidWriteCommand_8Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber));
    317a:	8a 81       	ldd	r24, Y+2	; 0x02
    317c:	80 54       	subi	r24, 0x40	; 64
    317e:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <HCLCD_VidWriteCommand_8Bits>
	}
	else
	{
		/*Do Nothing*/
	}
}
    3182:	0f 90       	pop	r0
    3184:	0f 90       	pop	r0
    3186:	cf 91       	pop	r28
    3188:	df 91       	pop	r29
    318a:	08 95       	ret

0000318c <HCLCD_VidWriteCommand_4Bits>:

void HCLCD_VidWriteCommand_4Bits(u8 Copy_u8Command)
{
    318c:	df 93       	push	r29
    318e:	cf 93       	push	r28
    3190:	cd b7       	in	r28, 0x3d	; 61
    3192:	de b7       	in	r29, 0x3e	; 62
    3194:	60 97       	sbiw	r28, 0x10	; 16
    3196:	0f b6       	in	r0, 0x3f	; 63
    3198:	f8 94       	cli
    319a:	de bf       	out	0x3e, r29	; 62
    319c:	0f be       	out	0x3f, r0	; 63
    319e:	cd bf       	out	0x3d, r28	; 61
    31a0:	88 8b       	std	Y+16, r24	; 0x10
	u8 LOC_u8CopyCommand;
	/*select Command register--> Write zero on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_LOW);
    31a2:	81 e0       	ldi	r24, 0x01	; 1
    31a4:	60 e0       	ldi	r22, 0x00	; 0
    31a6:	40 e0       	ldi	r20, 0x00	; 0
    31a8:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send  Command*/
	LOC_u8CopyCommand=(Copy_u8Command&0x0F)<<HCLCD_PINSTART;
    31ac:	88 89       	ldd	r24, Y+16	; 0x10
    31ae:	8f 70       	andi	r24, 0x0F	; 15
    31b0:	88 0f       	add	r24, r24
    31b2:	88 0f       	add	r24, r24
    31b4:	88 0f       	add	r24, r24
    31b6:	8f 87       	std	Y+15, r24	; 0x0f
	MDIO_Error_State_SetNippleValue(HCLCD_PINSTART,DATA_PORT,LOC_u8CopyCommand);
    31b8:	83 e0       	ldi	r24, 0x03	; 3
    31ba:	60 e0       	ldi	r22, 0x00	; 0
    31bc:	4f 85       	ldd	r20, Y+15	; 0x0f
    31be:	0e 94 6d 0b 	call	0x16da	; 0x16da <MDIO_Error_State_SetNippleValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    31c2:	82 e0       	ldi	r24, 0x02	; 2
    31c4:	60 e0       	ldi	r22, 0x00	; 0
    31c6:	41 e0       	ldi	r20, 0x01	; 1
    31c8:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
    31cc:	80 e0       	ldi	r24, 0x00	; 0
    31ce:	90 e0       	ldi	r25, 0x00	; 0
    31d0:	a0 e0       	ldi	r26, 0x00	; 0
    31d2:	b0 e4       	ldi	r27, 0x40	; 64
    31d4:	8b 87       	std	Y+11, r24	; 0x0b
    31d6:	9c 87       	std	Y+12, r25	; 0x0c
    31d8:	ad 87       	std	Y+13, r26	; 0x0d
    31da:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    31dc:	6b 85       	ldd	r22, Y+11	; 0x0b
    31de:	7c 85       	ldd	r23, Y+12	; 0x0c
    31e0:	8d 85       	ldd	r24, Y+13	; 0x0d
    31e2:	9e 85       	ldd	r25, Y+14	; 0x0e
    31e4:	20 e0       	ldi	r18, 0x00	; 0
    31e6:	30 e0       	ldi	r19, 0x00	; 0
    31e8:	4a ef       	ldi	r20, 0xFA	; 250
    31ea:	54 e4       	ldi	r21, 0x44	; 68
    31ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    31f0:	dc 01       	movw	r26, r24
    31f2:	cb 01       	movw	r24, r22
    31f4:	8f 83       	std	Y+7, r24	; 0x07
    31f6:	98 87       	std	Y+8, r25	; 0x08
    31f8:	a9 87       	std	Y+9, r26	; 0x09
    31fa:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    31fc:	6f 81       	ldd	r22, Y+7	; 0x07
    31fe:	78 85       	ldd	r23, Y+8	; 0x08
    3200:	89 85       	ldd	r24, Y+9	; 0x09
    3202:	9a 85       	ldd	r25, Y+10	; 0x0a
    3204:	20 e0       	ldi	r18, 0x00	; 0
    3206:	30 e0       	ldi	r19, 0x00	; 0
    3208:	40 e8       	ldi	r20, 0x80	; 128
    320a:	5f e3       	ldi	r21, 0x3F	; 63
    320c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3210:	88 23       	and	r24, r24
    3212:	2c f4       	brge	.+10     	; 0x321e <HCLCD_VidWriteCommand_4Bits+0x92>
		__ticks = 1;
    3214:	81 e0       	ldi	r24, 0x01	; 1
    3216:	90 e0       	ldi	r25, 0x00	; 0
    3218:	9e 83       	std	Y+6, r25	; 0x06
    321a:	8d 83       	std	Y+5, r24	; 0x05
    321c:	3f c0       	rjmp	.+126    	; 0x329c <HCLCD_VidWriteCommand_4Bits+0x110>
	else if (__tmp > 65535)
    321e:	6f 81       	ldd	r22, Y+7	; 0x07
    3220:	78 85       	ldd	r23, Y+8	; 0x08
    3222:	89 85       	ldd	r24, Y+9	; 0x09
    3224:	9a 85       	ldd	r25, Y+10	; 0x0a
    3226:	20 e0       	ldi	r18, 0x00	; 0
    3228:	3f ef       	ldi	r19, 0xFF	; 255
    322a:	4f e7       	ldi	r20, 0x7F	; 127
    322c:	57 e4       	ldi	r21, 0x47	; 71
    322e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3232:	18 16       	cp	r1, r24
    3234:	4c f5       	brge	.+82     	; 0x3288 <HCLCD_VidWriteCommand_4Bits+0xfc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3236:	6b 85       	ldd	r22, Y+11	; 0x0b
    3238:	7c 85       	ldd	r23, Y+12	; 0x0c
    323a:	8d 85       	ldd	r24, Y+13	; 0x0d
    323c:	9e 85       	ldd	r25, Y+14	; 0x0e
    323e:	20 e0       	ldi	r18, 0x00	; 0
    3240:	30 e0       	ldi	r19, 0x00	; 0
    3242:	40 e2       	ldi	r20, 0x20	; 32
    3244:	51 e4       	ldi	r21, 0x41	; 65
    3246:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    324a:	dc 01       	movw	r26, r24
    324c:	cb 01       	movw	r24, r22
    324e:	bc 01       	movw	r22, r24
    3250:	cd 01       	movw	r24, r26
    3252:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3256:	dc 01       	movw	r26, r24
    3258:	cb 01       	movw	r24, r22
    325a:	9e 83       	std	Y+6, r25	; 0x06
    325c:	8d 83       	std	Y+5, r24	; 0x05
    325e:	0f c0       	rjmp	.+30     	; 0x327e <HCLCD_VidWriteCommand_4Bits+0xf2>
    3260:	88 ec       	ldi	r24, 0xC8	; 200
    3262:	90 e0       	ldi	r25, 0x00	; 0
    3264:	9c 83       	std	Y+4, r25	; 0x04
    3266:	8b 83       	std	Y+3, r24	; 0x03
    3268:	8b 81       	ldd	r24, Y+3	; 0x03
    326a:	9c 81       	ldd	r25, Y+4	; 0x04
    326c:	01 97       	sbiw	r24, 0x01	; 1
    326e:	f1 f7       	brne	.-4      	; 0x326c <HCLCD_VidWriteCommand_4Bits+0xe0>
    3270:	9c 83       	std	Y+4, r25	; 0x04
    3272:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3274:	8d 81       	ldd	r24, Y+5	; 0x05
    3276:	9e 81       	ldd	r25, Y+6	; 0x06
    3278:	01 97       	sbiw	r24, 0x01	; 1
    327a:	9e 83       	std	Y+6, r25	; 0x06
    327c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    327e:	8d 81       	ldd	r24, Y+5	; 0x05
    3280:	9e 81       	ldd	r25, Y+6	; 0x06
    3282:	00 97       	sbiw	r24, 0x00	; 0
    3284:	69 f7       	brne	.-38     	; 0x3260 <HCLCD_VidWriteCommand_4Bits+0xd4>
    3286:	14 c0       	rjmp	.+40     	; 0x32b0 <HCLCD_VidWriteCommand_4Bits+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3288:	6f 81       	ldd	r22, Y+7	; 0x07
    328a:	78 85       	ldd	r23, Y+8	; 0x08
    328c:	89 85       	ldd	r24, Y+9	; 0x09
    328e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3290:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3294:	dc 01       	movw	r26, r24
    3296:	cb 01       	movw	r24, r22
    3298:	9e 83       	std	Y+6, r25	; 0x06
    329a:	8d 83       	std	Y+5, r24	; 0x05
    329c:	8d 81       	ldd	r24, Y+5	; 0x05
    329e:	9e 81       	ldd	r25, Y+6	; 0x06
    32a0:	9a 83       	std	Y+2, r25	; 0x02
    32a2:	89 83       	std	Y+1, r24	; 0x01
    32a4:	89 81       	ldd	r24, Y+1	; 0x01
    32a6:	9a 81       	ldd	r25, Y+2	; 0x02
    32a8:	01 97       	sbiw	r24, 0x01	; 1
    32aa:	f1 f7       	brne	.-4      	; 0x32a8 <HCLCD_VidWriteCommand_4Bits+0x11c>
    32ac:	9a 83       	std	Y+2, r25	; 0x02
    32ae:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    32b0:	82 e0       	ldi	r24, 0x02	; 2
    32b2:	60 e0       	ldi	r22, 0x00	; 0
    32b4:	40 e0       	ldi	r20, 0x00	; 0
    32b6:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
}
    32ba:	60 96       	adiw	r28, 0x10	; 16
    32bc:	0f b6       	in	r0, 0x3f	; 63
    32be:	f8 94       	cli
    32c0:	de bf       	out	0x3e, r29	; 62
    32c2:	0f be       	out	0x3f, r0	; 63
    32c4:	cd bf       	out	0x3d, r28	; 61
    32c6:	cf 91       	pop	r28
    32c8:	df 91       	pop	r29
    32ca:	08 95       	ret

000032cc <HCLCD_Vid4Bits_Init>:
void HCLCD_Vid4Bits_Init(void)
{
    32cc:	df 93       	push	r29
    32ce:	cf 93       	push	r28
    32d0:	cd b7       	in	r28, 0x3d	; 61
    32d2:	de b7       	in	r29, 0x3e	; 62
    32d4:	e9 97       	sbiw	r28, 0x39	; 57
    32d6:	0f b6       	in	r0, 0x3f	; 63
    32d8:	f8 94       	cli
    32da:	de bf       	out	0x3e, r29	; 62
    32dc:	0f be       	out	0x3f, r0	; 63
    32de:	cd bf       	out	0x3d, r28	; 61
	s8 LOC_u8PinCount;
	/*LCD Data and control port initialization*/
	for(LOC_u8PinCount=HCLCD_PINEND;LOC_u8PinCount>=HCLCD_PINSTART;LOC_u8PinCount--)
    32e0:	86 e0       	ldi	r24, 0x06	; 6
    32e2:	89 af       	std	Y+57, r24	; 0x39
    32e4:	08 c0       	rjmp	.+16     	; 0x32f6 <HCLCD_Vid4Bits_Init+0x2a>
	{
	MDIO_Error_State_SetPinDirection(LOC_u8PinCount,DATA_PORT,PIN_OUTPUT);
    32e6:	89 ad       	ldd	r24, Y+57	; 0x39
    32e8:	60 e0       	ldi	r22, 0x00	; 0
    32ea:	41 e0       	ldi	r20, 0x01	; 1
    32ec:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
}
void HCLCD_Vid4Bits_Init(void)
{
	s8 LOC_u8PinCount;
	/*LCD Data and control port initialization*/
	for(LOC_u8PinCount=HCLCD_PINEND;LOC_u8PinCount>=HCLCD_PINSTART;LOC_u8PinCount--)
    32f0:	89 ad       	ldd	r24, Y+57	; 0x39
    32f2:	81 50       	subi	r24, 0x01	; 1
    32f4:	89 af       	std	Y+57, r24	; 0x39
    32f6:	89 ad       	ldd	r24, Y+57	; 0x39
    32f8:	83 30       	cpi	r24, 0x03	; 3
    32fa:	ac f7       	brge	.-22     	; 0x32e6 <HCLCD_Vid4Bits_Init+0x1a>
	{
	MDIO_Error_State_SetPinDirection(LOC_u8PinCount,DATA_PORT,PIN_OUTPUT);
	}
	MDIO_Error_State_SetPinDirection(RS,CONTROL_PORT,PIN_OUTPUT);
    32fc:	81 e0       	ldi	r24, 0x01	; 1
    32fe:	60 e0       	ldi	r22, 0x00	; 0
    3300:	41 e0       	ldi	r20, 0x01	; 1
    3302:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	//MDIO_Error_State_SetPinDirection(RW,CONTROL_PORT,PIN_OUTPUT);
	MDIO_Error_State_SetPinDirection(E,CONTROL_PORT,PIN_OUTPUT);
    3306:	82 e0       	ldi	r24, 0x02	; 2
    3308:	60 e0       	ldi	r22, 0x00	; 0
    330a:	41 e0       	ldi	r20, 0x01	; 1
    330c:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
    3310:	80 e0       	ldi	r24, 0x00	; 0
    3312:	90 e0       	ldi	r25, 0x00	; 0
    3314:	a0 ef       	ldi	r26, 0xF0	; 240
    3316:	b1 e4       	ldi	r27, 0x41	; 65
    3318:	8d ab       	std	Y+53, r24	; 0x35
    331a:	9e ab       	std	Y+54, r25	; 0x36
    331c:	af ab       	std	Y+55, r26	; 0x37
    331e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3320:	6d a9       	ldd	r22, Y+53	; 0x35
    3322:	7e a9       	ldd	r23, Y+54	; 0x36
    3324:	8f a9       	ldd	r24, Y+55	; 0x37
    3326:	98 ad       	ldd	r25, Y+56	; 0x38
    3328:	20 e0       	ldi	r18, 0x00	; 0
    332a:	30 e0       	ldi	r19, 0x00	; 0
    332c:	4a ef       	ldi	r20, 0xFA	; 250
    332e:	54 e4       	ldi	r21, 0x44	; 68
    3330:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3334:	dc 01       	movw	r26, r24
    3336:	cb 01       	movw	r24, r22
    3338:	89 ab       	std	Y+49, r24	; 0x31
    333a:	9a ab       	std	Y+50, r25	; 0x32
    333c:	ab ab       	std	Y+51, r26	; 0x33
    333e:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    3340:	69 a9       	ldd	r22, Y+49	; 0x31
    3342:	7a a9       	ldd	r23, Y+50	; 0x32
    3344:	8b a9       	ldd	r24, Y+51	; 0x33
    3346:	9c a9       	ldd	r25, Y+52	; 0x34
    3348:	20 e0       	ldi	r18, 0x00	; 0
    334a:	30 e0       	ldi	r19, 0x00	; 0
    334c:	40 e8       	ldi	r20, 0x80	; 128
    334e:	5f e3       	ldi	r21, 0x3F	; 63
    3350:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3354:	88 23       	and	r24, r24
    3356:	2c f4       	brge	.+10     	; 0x3362 <HCLCD_Vid4Bits_Init+0x96>
		__ticks = 1;
    3358:	81 e0       	ldi	r24, 0x01	; 1
    335a:	90 e0       	ldi	r25, 0x00	; 0
    335c:	98 ab       	std	Y+48, r25	; 0x30
    335e:	8f a7       	std	Y+47, r24	; 0x2f
    3360:	3f c0       	rjmp	.+126    	; 0x33e0 <HCLCD_Vid4Bits_Init+0x114>
	else if (__tmp > 65535)
    3362:	69 a9       	ldd	r22, Y+49	; 0x31
    3364:	7a a9       	ldd	r23, Y+50	; 0x32
    3366:	8b a9       	ldd	r24, Y+51	; 0x33
    3368:	9c a9       	ldd	r25, Y+52	; 0x34
    336a:	20 e0       	ldi	r18, 0x00	; 0
    336c:	3f ef       	ldi	r19, 0xFF	; 255
    336e:	4f e7       	ldi	r20, 0x7F	; 127
    3370:	57 e4       	ldi	r21, 0x47	; 71
    3372:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3376:	18 16       	cp	r1, r24
    3378:	4c f5       	brge	.+82     	; 0x33cc <HCLCD_Vid4Bits_Init+0x100>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    337a:	6d a9       	ldd	r22, Y+53	; 0x35
    337c:	7e a9       	ldd	r23, Y+54	; 0x36
    337e:	8f a9       	ldd	r24, Y+55	; 0x37
    3380:	98 ad       	ldd	r25, Y+56	; 0x38
    3382:	20 e0       	ldi	r18, 0x00	; 0
    3384:	30 e0       	ldi	r19, 0x00	; 0
    3386:	40 e2       	ldi	r20, 0x20	; 32
    3388:	51 e4       	ldi	r21, 0x41	; 65
    338a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    338e:	dc 01       	movw	r26, r24
    3390:	cb 01       	movw	r24, r22
    3392:	bc 01       	movw	r22, r24
    3394:	cd 01       	movw	r24, r26
    3396:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    339a:	dc 01       	movw	r26, r24
    339c:	cb 01       	movw	r24, r22
    339e:	98 ab       	std	Y+48, r25	; 0x30
    33a0:	8f a7       	std	Y+47, r24	; 0x2f
    33a2:	0f c0       	rjmp	.+30     	; 0x33c2 <HCLCD_Vid4Bits_Init+0xf6>
    33a4:	88 ec       	ldi	r24, 0xC8	; 200
    33a6:	90 e0       	ldi	r25, 0x00	; 0
    33a8:	9e a7       	std	Y+46, r25	; 0x2e
    33aa:	8d a7       	std	Y+45, r24	; 0x2d
    33ac:	8d a5       	ldd	r24, Y+45	; 0x2d
    33ae:	9e a5       	ldd	r25, Y+46	; 0x2e
    33b0:	01 97       	sbiw	r24, 0x01	; 1
    33b2:	f1 f7       	brne	.-4      	; 0x33b0 <HCLCD_Vid4Bits_Init+0xe4>
    33b4:	9e a7       	std	Y+46, r25	; 0x2e
    33b6:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    33b8:	8f a5       	ldd	r24, Y+47	; 0x2f
    33ba:	98 a9       	ldd	r25, Y+48	; 0x30
    33bc:	01 97       	sbiw	r24, 0x01	; 1
    33be:	98 ab       	std	Y+48, r25	; 0x30
    33c0:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    33c2:	8f a5       	ldd	r24, Y+47	; 0x2f
    33c4:	98 a9       	ldd	r25, Y+48	; 0x30
    33c6:	00 97       	sbiw	r24, 0x00	; 0
    33c8:	69 f7       	brne	.-38     	; 0x33a4 <HCLCD_Vid4Bits_Init+0xd8>
    33ca:	14 c0       	rjmp	.+40     	; 0x33f4 <HCLCD_Vid4Bits_Init+0x128>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    33cc:	69 a9       	ldd	r22, Y+49	; 0x31
    33ce:	7a a9       	ldd	r23, Y+50	; 0x32
    33d0:	8b a9       	ldd	r24, Y+51	; 0x33
    33d2:	9c a9       	ldd	r25, Y+52	; 0x34
    33d4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    33d8:	dc 01       	movw	r26, r24
    33da:	cb 01       	movw	r24, r22
    33dc:	98 ab       	std	Y+48, r25	; 0x30
    33de:	8f a7       	std	Y+47, r24	; 0x2f
    33e0:	8f a5       	ldd	r24, Y+47	; 0x2f
    33e2:	98 a9       	ldd	r25, Y+48	; 0x30
    33e4:	9c a7       	std	Y+44, r25	; 0x2c
    33e6:	8b a7       	std	Y+43, r24	; 0x2b
    33e8:	8b a5       	ldd	r24, Y+43	; 0x2b
    33ea:	9c a5       	ldd	r25, Y+44	; 0x2c
    33ec:	01 97       	sbiw	r24, 0x01	; 1
    33ee:	f1 f7       	brne	.-4      	; 0x33ec <HCLCD_Vid4Bits_Init+0x120>
    33f0:	9c a7       	std	Y+44, r25	; 0x2c
    33f2:	8b a7       	std	Y+43, r24	; 0x2b
	/*wait to 30ms*/
	_delay_ms(30);
	/*send function set command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET>>4);
    33f4:	82 e0       	ldi	r24, 0x02	; 2
    33f6:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET>>4);
    33fa:	82 e0       	ldi	r24, 0x02	; 2
    33fc:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET);
    3400:	88 e2       	ldi	r24, 0x28	; 40
    3402:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
    3406:	80 e0       	ldi	r24, 0x00	; 0
    3408:	90 e0       	ldi	r25, 0x00	; 0
    340a:	a0 e8       	ldi	r26, 0x80	; 128
    340c:	bf e3       	ldi	r27, 0x3F	; 63
    340e:	8f a3       	std	Y+39, r24	; 0x27
    3410:	98 a7       	std	Y+40, r25	; 0x28
    3412:	a9 a7       	std	Y+41, r26	; 0x29
    3414:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3416:	6f a1       	ldd	r22, Y+39	; 0x27
    3418:	78 a5       	ldd	r23, Y+40	; 0x28
    341a:	89 a5       	ldd	r24, Y+41	; 0x29
    341c:	9a a5       	ldd	r25, Y+42	; 0x2a
    341e:	20 e0       	ldi	r18, 0x00	; 0
    3420:	30 e0       	ldi	r19, 0x00	; 0
    3422:	4a ef       	ldi	r20, 0xFA	; 250
    3424:	54 e4       	ldi	r21, 0x44	; 68
    3426:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    342a:	dc 01       	movw	r26, r24
    342c:	cb 01       	movw	r24, r22
    342e:	8b a3       	std	Y+35, r24	; 0x23
    3430:	9c a3       	std	Y+36, r25	; 0x24
    3432:	ad a3       	std	Y+37, r26	; 0x25
    3434:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    3436:	6b a1       	ldd	r22, Y+35	; 0x23
    3438:	7c a1       	ldd	r23, Y+36	; 0x24
    343a:	8d a1       	ldd	r24, Y+37	; 0x25
    343c:	9e a1       	ldd	r25, Y+38	; 0x26
    343e:	20 e0       	ldi	r18, 0x00	; 0
    3440:	30 e0       	ldi	r19, 0x00	; 0
    3442:	40 e8       	ldi	r20, 0x80	; 128
    3444:	5f e3       	ldi	r21, 0x3F	; 63
    3446:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    344a:	88 23       	and	r24, r24
    344c:	2c f4       	brge	.+10     	; 0x3458 <HCLCD_Vid4Bits_Init+0x18c>
		__ticks = 1;
    344e:	81 e0       	ldi	r24, 0x01	; 1
    3450:	90 e0       	ldi	r25, 0x00	; 0
    3452:	9a a3       	std	Y+34, r25	; 0x22
    3454:	89 a3       	std	Y+33, r24	; 0x21
    3456:	3f c0       	rjmp	.+126    	; 0x34d6 <HCLCD_Vid4Bits_Init+0x20a>
	else if (__tmp > 65535)
    3458:	6b a1       	ldd	r22, Y+35	; 0x23
    345a:	7c a1       	ldd	r23, Y+36	; 0x24
    345c:	8d a1       	ldd	r24, Y+37	; 0x25
    345e:	9e a1       	ldd	r25, Y+38	; 0x26
    3460:	20 e0       	ldi	r18, 0x00	; 0
    3462:	3f ef       	ldi	r19, 0xFF	; 255
    3464:	4f e7       	ldi	r20, 0x7F	; 127
    3466:	57 e4       	ldi	r21, 0x47	; 71
    3468:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    346c:	18 16       	cp	r1, r24
    346e:	4c f5       	brge	.+82     	; 0x34c2 <HCLCD_Vid4Bits_Init+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3470:	6f a1       	ldd	r22, Y+39	; 0x27
    3472:	78 a5       	ldd	r23, Y+40	; 0x28
    3474:	89 a5       	ldd	r24, Y+41	; 0x29
    3476:	9a a5       	ldd	r25, Y+42	; 0x2a
    3478:	20 e0       	ldi	r18, 0x00	; 0
    347a:	30 e0       	ldi	r19, 0x00	; 0
    347c:	40 e2       	ldi	r20, 0x20	; 32
    347e:	51 e4       	ldi	r21, 0x41	; 65
    3480:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3484:	dc 01       	movw	r26, r24
    3486:	cb 01       	movw	r24, r22
    3488:	bc 01       	movw	r22, r24
    348a:	cd 01       	movw	r24, r26
    348c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3490:	dc 01       	movw	r26, r24
    3492:	cb 01       	movw	r24, r22
    3494:	9a a3       	std	Y+34, r25	; 0x22
    3496:	89 a3       	std	Y+33, r24	; 0x21
    3498:	0f c0       	rjmp	.+30     	; 0x34b8 <HCLCD_Vid4Bits_Init+0x1ec>
    349a:	88 ec       	ldi	r24, 0xC8	; 200
    349c:	90 e0       	ldi	r25, 0x00	; 0
    349e:	98 a3       	std	Y+32, r25	; 0x20
    34a0:	8f 8f       	std	Y+31, r24	; 0x1f
    34a2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    34a4:	98 a1       	ldd	r25, Y+32	; 0x20
    34a6:	01 97       	sbiw	r24, 0x01	; 1
    34a8:	f1 f7       	brne	.-4      	; 0x34a6 <HCLCD_Vid4Bits_Init+0x1da>
    34aa:	98 a3       	std	Y+32, r25	; 0x20
    34ac:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    34ae:	89 a1       	ldd	r24, Y+33	; 0x21
    34b0:	9a a1       	ldd	r25, Y+34	; 0x22
    34b2:	01 97       	sbiw	r24, 0x01	; 1
    34b4:	9a a3       	std	Y+34, r25	; 0x22
    34b6:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    34b8:	89 a1       	ldd	r24, Y+33	; 0x21
    34ba:	9a a1       	ldd	r25, Y+34	; 0x22
    34bc:	00 97       	sbiw	r24, 0x00	; 0
    34be:	69 f7       	brne	.-38     	; 0x349a <HCLCD_Vid4Bits_Init+0x1ce>
    34c0:	14 c0       	rjmp	.+40     	; 0x34ea <HCLCD_Vid4Bits_Init+0x21e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    34c2:	6b a1       	ldd	r22, Y+35	; 0x23
    34c4:	7c a1       	ldd	r23, Y+36	; 0x24
    34c6:	8d a1       	ldd	r24, Y+37	; 0x25
    34c8:	9e a1       	ldd	r25, Y+38	; 0x26
    34ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    34ce:	dc 01       	movw	r26, r24
    34d0:	cb 01       	movw	r24, r22
    34d2:	9a a3       	std	Y+34, r25	; 0x22
    34d4:	89 a3       	std	Y+33, r24	; 0x21
    34d6:	89 a1       	ldd	r24, Y+33	; 0x21
    34d8:	9a a1       	ldd	r25, Y+34	; 0x22
    34da:	9e 8f       	std	Y+30, r25	; 0x1e
    34dc:	8d 8f       	std	Y+29, r24	; 0x1d
    34de:	8d 8d       	ldd	r24, Y+29	; 0x1d
    34e0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    34e2:	01 97       	sbiw	r24, 0x01	; 1
    34e4:	f1 f7       	brne	.-4      	; 0x34e2 <HCLCD_Vid4Bits_Init+0x216>
    34e6:	9e 8f       	std	Y+30, r25	; 0x1e
    34e8:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
	/*send Display on/off  command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_DISPLAY_ON_OFF>>4);
    34ea:	80 e0       	ldi	r24, 0x00	; 0
    34ec:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_DISPLAY_ON_OFF);
    34f0:	8f e0       	ldi	r24, 0x0F	; 15
    34f2:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
    34f6:	80 e0       	ldi	r24, 0x00	; 0
    34f8:	90 e0       	ldi	r25, 0x00	; 0
    34fa:	a0 e8       	ldi	r26, 0x80	; 128
    34fc:	bf e3       	ldi	r27, 0x3F	; 63
    34fe:	89 8f       	std	Y+25, r24	; 0x19
    3500:	9a 8f       	std	Y+26, r25	; 0x1a
    3502:	ab 8f       	std	Y+27, r26	; 0x1b
    3504:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3506:	69 8d       	ldd	r22, Y+25	; 0x19
    3508:	7a 8d       	ldd	r23, Y+26	; 0x1a
    350a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    350c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    350e:	20 e0       	ldi	r18, 0x00	; 0
    3510:	30 e0       	ldi	r19, 0x00	; 0
    3512:	4a ef       	ldi	r20, 0xFA	; 250
    3514:	54 e4       	ldi	r21, 0x44	; 68
    3516:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    351a:	dc 01       	movw	r26, r24
    351c:	cb 01       	movw	r24, r22
    351e:	8d 8b       	std	Y+21, r24	; 0x15
    3520:	9e 8b       	std	Y+22, r25	; 0x16
    3522:	af 8b       	std	Y+23, r26	; 0x17
    3524:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3526:	6d 89       	ldd	r22, Y+21	; 0x15
    3528:	7e 89       	ldd	r23, Y+22	; 0x16
    352a:	8f 89       	ldd	r24, Y+23	; 0x17
    352c:	98 8d       	ldd	r25, Y+24	; 0x18
    352e:	20 e0       	ldi	r18, 0x00	; 0
    3530:	30 e0       	ldi	r19, 0x00	; 0
    3532:	40 e8       	ldi	r20, 0x80	; 128
    3534:	5f e3       	ldi	r21, 0x3F	; 63
    3536:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    353a:	88 23       	and	r24, r24
    353c:	2c f4       	brge	.+10     	; 0x3548 <HCLCD_Vid4Bits_Init+0x27c>
		__ticks = 1;
    353e:	81 e0       	ldi	r24, 0x01	; 1
    3540:	90 e0       	ldi	r25, 0x00	; 0
    3542:	9c 8b       	std	Y+20, r25	; 0x14
    3544:	8b 8b       	std	Y+19, r24	; 0x13
    3546:	3f c0       	rjmp	.+126    	; 0x35c6 <HCLCD_Vid4Bits_Init+0x2fa>
	else if (__tmp > 65535)
    3548:	6d 89       	ldd	r22, Y+21	; 0x15
    354a:	7e 89       	ldd	r23, Y+22	; 0x16
    354c:	8f 89       	ldd	r24, Y+23	; 0x17
    354e:	98 8d       	ldd	r25, Y+24	; 0x18
    3550:	20 e0       	ldi	r18, 0x00	; 0
    3552:	3f ef       	ldi	r19, 0xFF	; 255
    3554:	4f e7       	ldi	r20, 0x7F	; 127
    3556:	57 e4       	ldi	r21, 0x47	; 71
    3558:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    355c:	18 16       	cp	r1, r24
    355e:	4c f5       	brge	.+82     	; 0x35b2 <HCLCD_Vid4Bits_Init+0x2e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3560:	69 8d       	ldd	r22, Y+25	; 0x19
    3562:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3564:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3566:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3568:	20 e0       	ldi	r18, 0x00	; 0
    356a:	30 e0       	ldi	r19, 0x00	; 0
    356c:	40 e2       	ldi	r20, 0x20	; 32
    356e:	51 e4       	ldi	r21, 0x41	; 65
    3570:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3574:	dc 01       	movw	r26, r24
    3576:	cb 01       	movw	r24, r22
    3578:	bc 01       	movw	r22, r24
    357a:	cd 01       	movw	r24, r26
    357c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3580:	dc 01       	movw	r26, r24
    3582:	cb 01       	movw	r24, r22
    3584:	9c 8b       	std	Y+20, r25	; 0x14
    3586:	8b 8b       	std	Y+19, r24	; 0x13
    3588:	0f c0       	rjmp	.+30     	; 0x35a8 <HCLCD_Vid4Bits_Init+0x2dc>
    358a:	88 ec       	ldi	r24, 0xC8	; 200
    358c:	90 e0       	ldi	r25, 0x00	; 0
    358e:	9a 8b       	std	Y+18, r25	; 0x12
    3590:	89 8b       	std	Y+17, r24	; 0x11
    3592:	89 89       	ldd	r24, Y+17	; 0x11
    3594:	9a 89       	ldd	r25, Y+18	; 0x12
    3596:	01 97       	sbiw	r24, 0x01	; 1
    3598:	f1 f7       	brne	.-4      	; 0x3596 <HCLCD_Vid4Bits_Init+0x2ca>
    359a:	9a 8b       	std	Y+18, r25	; 0x12
    359c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    359e:	8b 89       	ldd	r24, Y+19	; 0x13
    35a0:	9c 89       	ldd	r25, Y+20	; 0x14
    35a2:	01 97       	sbiw	r24, 0x01	; 1
    35a4:	9c 8b       	std	Y+20, r25	; 0x14
    35a6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    35a8:	8b 89       	ldd	r24, Y+19	; 0x13
    35aa:	9c 89       	ldd	r25, Y+20	; 0x14
    35ac:	00 97       	sbiw	r24, 0x00	; 0
    35ae:	69 f7       	brne	.-38     	; 0x358a <HCLCD_Vid4Bits_Init+0x2be>
    35b0:	14 c0       	rjmp	.+40     	; 0x35da <HCLCD_Vid4Bits_Init+0x30e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    35b2:	6d 89       	ldd	r22, Y+21	; 0x15
    35b4:	7e 89       	ldd	r23, Y+22	; 0x16
    35b6:	8f 89       	ldd	r24, Y+23	; 0x17
    35b8:	98 8d       	ldd	r25, Y+24	; 0x18
    35ba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    35be:	dc 01       	movw	r26, r24
    35c0:	cb 01       	movw	r24, r22
    35c2:	9c 8b       	std	Y+20, r25	; 0x14
    35c4:	8b 8b       	std	Y+19, r24	; 0x13
    35c6:	8b 89       	ldd	r24, Y+19	; 0x13
    35c8:	9c 89       	ldd	r25, Y+20	; 0x14
    35ca:	98 8b       	std	Y+16, r25	; 0x10
    35cc:	8f 87       	std	Y+15, r24	; 0x0f
    35ce:	8f 85       	ldd	r24, Y+15	; 0x0f
    35d0:	98 89       	ldd	r25, Y+16	; 0x10
    35d2:	01 97       	sbiw	r24, 0x01	; 1
    35d4:	f1 f7       	brne	.-4      	; 0x35d2 <HCLCD_Vid4Bits_Init+0x306>
    35d6:	98 8b       	std	Y+16, r25	; 0x10
    35d8:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	/*send Display Clear  command*/
	HCLCD_VidWriteCommand_4Bits(DISPLAY_CLEAR>>4);
    35da:	80 e0       	ldi	r24, 0x00	; 0
    35dc:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(DISPLAY_CLEAR);
    35e0:	81 e0       	ldi	r24, 0x01	; 1
    35e2:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
    35e6:	80 e0       	ldi	r24, 0x00	; 0
    35e8:	90 e0       	ldi	r25, 0x00	; 0
    35ea:	a0 e0       	ldi	r26, 0x00	; 0
    35ec:	b0 e4       	ldi	r27, 0x40	; 64
    35ee:	8b 87       	std	Y+11, r24	; 0x0b
    35f0:	9c 87       	std	Y+12, r25	; 0x0c
    35f2:	ad 87       	std	Y+13, r26	; 0x0d
    35f4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    35f6:	6b 85       	ldd	r22, Y+11	; 0x0b
    35f8:	7c 85       	ldd	r23, Y+12	; 0x0c
    35fa:	8d 85       	ldd	r24, Y+13	; 0x0d
    35fc:	9e 85       	ldd	r25, Y+14	; 0x0e
    35fe:	20 e0       	ldi	r18, 0x00	; 0
    3600:	30 e0       	ldi	r19, 0x00	; 0
    3602:	4a ef       	ldi	r20, 0xFA	; 250
    3604:	54 e4       	ldi	r21, 0x44	; 68
    3606:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    360a:	dc 01       	movw	r26, r24
    360c:	cb 01       	movw	r24, r22
    360e:	8f 83       	std	Y+7, r24	; 0x07
    3610:	98 87       	std	Y+8, r25	; 0x08
    3612:	a9 87       	std	Y+9, r26	; 0x09
    3614:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3616:	6f 81       	ldd	r22, Y+7	; 0x07
    3618:	78 85       	ldd	r23, Y+8	; 0x08
    361a:	89 85       	ldd	r24, Y+9	; 0x09
    361c:	9a 85       	ldd	r25, Y+10	; 0x0a
    361e:	20 e0       	ldi	r18, 0x00	; 0
    3620:	30 e0       	ldi	r19, 0x00	; 0
    3622:	40 e8       	ldi	r20, 0x80	; 128
    3624:	5f e3       	ldi	r21, 0x3F	; 63
    3626:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    362a:	88 23       	and	r24, r24
    362c:	2c f4       	brge	.+10     	; 0x3638 <HCLCD_Vid4Bits_Init+0x36c>
		__ticks = 1;
    362e:	81 e0       	ldi	r24, 0x01	; 1
    3630:	90 e0       	ldi	r25, 0x00	; 0
    3632:	9e 83       	std	Y+6, r25	; 0x06
    3634:	8d 83       	std	Y+5, r24	; 0x05
    3636:	3f c0       	rjmp	.+126    	; 0x36b6 <HCLCD_Vid4Bits_Init+0x3ea>
	else if (__tmp > 65535)
    3638:	6f 81       	ldd	r22, Y+7	; 0x07
    363a:	78 85       	ldd	r23, Y+8	; 0x08
    363c:	89 85       	ldd	r24, Y+9	; 0x09
    363e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3640:	20 e0       	ldi	r18, 0x00	; 0
    3642:	3f ef       	ldi	r19, 0xFF	; 255
    3644:	4f e7       	ldi	r20, 0x7F	; 127
    3646:	57 e4       	ldi	r21, 0x47	; 71
    3648:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    364c:	18 16       	cp	r1, r24
    364e:	4c f5       	brge	.+82     	; 0x36a2 <HCLCD_Vid4Bits_Init+0x3d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3650:	6b 85       	ldd	r22, Y+11	; 0x0b
    3652:	7c 85       	ldd	r23, Y+12	; 0x0c
    3654:	8d 85       	ldd	r24, Y+13	; 0x0d
    3656:	9e 85       	ldd	r25, Y+14	; 0x0e
    3658:	20 e0       	ldi	r18, 0x00	; 0
    365a:	30 e0       	ldi	r19, 0x00	; 0
    365c:	40 e2       	ldi	r20, 0x20	; 32
    365e:	51 e4       	ldi	r21, 0x41	; 65
    3660:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3664:	dc 01       	movw	r26, r24
    3666:	cb 01       	movw	r24, r22
    3668:	bc 01       	movw	r22, r24
    366a:	cd 01       	movw	r24, r26
    366c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3670:	dc 01       	movw	r26, r24
    3672:	cb 01       	movw	r24, r22
    3674:	9e 83       	std	Y+6, r25	; 0x06
    3676:	8d 83       	std	Y+5, r24	; 0x05
    3678:	0f c0       	rjmp	.+30     	; 0x3698 <HCLCD_Vid4Bits_Init+0x3cc>
    367a:	88 ec       	ldi	r24, 0xC8	; 200
    367c:	90 e0       	ldi	r25, 0x00	; 0
    367e:	9c 83       	std	Y+4, r25	; 0x04
    3680:	8b 83       	std	Y+3, r24	; 0x03
    3682:	8b 81       	ldd	r24, Y+3	; 0x03
    3684:	9c 81       	ldd	r25, Y+4	; 0x04
    3686:	01 97       	sbiw	r24, 0x01	; 1
    3688:	f1 f7       	brne	.-4      	; 0x3686 <HCLCD_Vid4Bits_Init+0x3ba>
    368a:	9c 83       	std	Y+4, r25	; 0x04
    368c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    368e:	8d 81       	ldd	r24, Y+5	; 0x05
    3690:	9e 81       	ldd	r25, Y+6	; 0x06
    3692:	01 97       	sbiw	r24, 0x01	; 1
    3694:	9e 83       	std	Y+6, r25	; 0x06
    3696:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3698:	8d 81       	ldd	r24, Y+5	; 0x05
    369a:	9e 81       	ldd	r25, Y+6	; 0x06
    369c:	00 97       	sbiw	r24, 0x00	; 0
    369e:	69 f7       	brne	.-38     	; 0x367a <HCLCD_Vid4Bits_Init+0x3ae>
    36a0:	14 c0       	rjmp	.+40     	; 0x36ca <HCLCD_Vid4Bits_Init+0x3fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    36a2:	6f 81       	ldd	r22, Y+7	; 0x07
    36a4:	78 85       	ldd	r23, Y+8	; 0x08
    36a6:	89 85       	ldd	r24, Y+9	; 0x09
    36a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    36aa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    36ae:	dc 01       	movw	r26, r24
    36b0:	cb 01       	movw	r24, r22
    36b2:	9e 83       	std	Y+6, r25	; 0x06
    36b4:	8d 83       	std	Y+5, r24	; 0x05
    36b6:	8d 81       	ldd	r24, Y+5	; 0x05
    36b8:	9e 81       	ldd	r25, Y+6	; 0x06
    36ba:	9a 83       	std	Y+2, r25	; 0x02
    36bc:	89 83       	std	Y+1, r24	; 0x01
    36be:	89 81       	ldd	r24, Y+1	; 0x01
    36c0:	9a 81       	ldd	r25, Y+2	; 0x02
    36c2:	01 97       	sbiw	r24, 0x01	; 1
    36c4:	f1 f7       	brne	.-4      	; 0x36c2 <HCLCD_Vid4Bits_Init+0x3f6>
    36c6:	9a 83       	std	Y+2, r25	; 0x02
    36c8:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	/*send Entry Mode  set command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_ENTRY_MODE_SET>>4);
    36ca:	80 e0       	ldi	r24, 0x00	; 0
    36cc:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_ENTRY_MODE_SET);
    36d0:	86 e0       	ldi	r24, 0x06	; 6
    36d2:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
}
    36d6:	e9 96       	adiw	r28, 0x39	; 57
    36d8:	0f b6       	in	r0, 0x3f	; 63
    36da:	f8 94       	cli
    36dc:	de bf       	out	0x3e, r29	; 62
    36de:	0f be       	out	0x3f, r0	; 63
    36e0:	cd bf       	out	0x3d, r28	; 61
    36e2:	cf 91       	pop	r28
    36e4:	df 91       	pop	r29
    36e6:	08 95       	ret

000036e8 <HCLCD_VidWriteChar_4Bits>:
void HCLCD_VidWriteChar_4Bits(u8 Copy_u8Data)
{
    36e8:	df 93       	push	r29
    36ea:	cf 93       	push	r28
    36ec:	cd b7       	in	r28, 0x3d	; 61
    36ee:	de b7       	in	r29, 0x3e	; 62
    36f0:	60 97       	sbiw	r28, 0x10	; 16
    36f2:	0f b6       	in	r0, 0x3f	; 63
    36f4:	f8 94       	cli
    36f6:	de bf       	out	0x3e, r29	; 62
    36f8:	0f be       	out	0x3f, r0	; 63
    36fa:	cd bf       	out	0x3d, r28	; 61
    36fc:	88 8b       	std	Y+16, r24	; 0x10
	u8 LOC_u8CopyData;
	/*select Data register--> Write One on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_HIGH);
    36fe:	81 e0       	ldi	r24, 0x01	; 1
    3700:	60 e0       	ldi	r22, 0x00	; 0
    3702:	41 e0       	ldi	r20, 0x01	; 1
    3704:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send Data*/
	LOC_u8CopyData=(Copy_u8Data&0x0F)<<HCLCD_PINSTART;
    3708:	88 89       	ldd	r24, Y+16	; 0x10
    370a:	8f 70       	andi	r24, 0x0F	; 15
    370c:	88 0f       	add	r24, r24
    370e:	88 0f       	add	r24, r24
    3710:	88 0f       	add	r24, r24
    3712:	8f 87       	std	Y+15, r24	; 0x0f
	MDIO_Error_State_SetNippleValue(HCLCD_PINSTART,DATA_PORT,LOC_u8CopyData);
    3714:	83 e0       	ldi	r24, 0x03	; 3
    3716:	60 e0       	ldi	r22, 0x00	; 0
    3718:	4f 85       	ldd	r20, Y+15	; 0x0f
    371a:	0e 94 6d 0b 	call	0x16da	; 0x16da <MDIO_Error_State_SetNippleValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    371e:	82 e0       	ldi	r24, 0x02	; 2
    3720:	60 e0       	ldi	r22, 0x00	; 0
    3722:	41 e0       	ldi	r20, 0x01	; 1
    3724:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
    3728:	80 e0       	ldi	r24, 0x00	; 0
    372a:	90 e0       	ldi	r25, 0x00	; 0
    372c:	a0 e0       	ldi	r26, 0x00	; 0
    372e:	b0 e4       	ldi	r27, 0x40	; 64
    3730:	8b 87       	std	Y+11, r24	; 0x0b
    3732:	9c 87       	std	Y+12, r25	; 0x0c
    3734:	ad 87       	std	Y+13, r26	; 0x0d
    3736:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3738:	6b 85       	ldd	r22, Y+11	; 0x0b
    373a:	7c 85       	ldd	r23, Y+12	; 0x0c
    373c:	8d 85       	ldd	r24, Y+13	; 0x0d
    373e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3740:	20 e0       	ldi	r18, 0x00	; 0
    3742:	30 e0       	ldi	r19, 0x00	; 0
    3744:	4a ef       	ldi	r20, 0xFA	; 250
    3746:	54 e4       	ldi	r21, 0x44	; 68
    3748:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    374c:	dc 01       	movw	r26, r24
    374e:	cb 01       	movw	r24, r22
    3750:	8f 83       	std	Y+7, r24	; 0x07
    3752:	98 87       	std	Y+8, r25	; 0x08
    3754:	a9 87       	std	Y+9, r26	; 0x09
    3756:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3758:	6f 81       	ldd	r22, Y+7	; 0x07
    375a:	78 85       	ldd	r23, Y+8	; 0x08
    375c:	89 85       	ldd	r24, Y+9	; 0x09
    375e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3760:	20 e0       	ldi	r18, 0x00	; 0
    3762:	30 e0       	ldi	r19, 0x00	; 0
    3764:	40 e8       	ldi	r20, 0x80	; 128
    3766:	5f e3       	ldi	r21, 0x3F	; 63
    3768:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    376c:	88 23       	and	r24, r24
    376e:	2c f4       	brge	.+10     	; 0x377a <HCLCD_VidWriteChar_4Bits+0x92>
		__ticks = 1;
    3770:	81 e0       	ldi	r24, 0x01	; 1
    3772:	90 e0       	ldi	r25, 0x00	; 0
    3774:	9e 83       	std	Y+6, r25	; 0x06
    3776:	8d 83       	std	Y+5, r24	; 0x05
    3778:	3f c0       	rjmp	.+126    	; 0x37f8 <HCLCD_VidWriteChar_4Bits+0x110>
	else if (__tmp > 65535)
    377a:	6f 81       	ldd	r22, Y+7	; 0x07
    377c:	78 85       	ldd	r23, Y+8	; 0x08
    377e:	89 85       	ldd	r24, Y+9	; 0x09
    3780:	9a 85       	ldd	r25, Y+10	; 0x0a
    3782:	20 e0       	ldi	r18, 0x00	; 0
    3784:	3f ef       	ldi	r19, 0xFF	; 255
    3786:	4f e7       	ldi	r20, 0x7F	; 127
    3788:	57 e4       	ldi	r21, 0x47	; 71
    378a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    378e:	18 16       	cp	r1, r24
    3790:	4c f5       	brge	.+82     	; 0x37e4 <HCLCD_VidWriteChar_4Bits+0xfc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3792:	6b 85       	ldd	r22, Y+11	; 0x0b
    3794:	7c 85       	ldd	r23, Y+12	; 0x0c
    3796:	8d 85       	ldd	r24, Y+13	; 0x0d
    3798:	9e 85       	ldd	r25, Y+14	; 0x0e
    379a:	20 e0       	ldi	r18, 0x00	; 0
    379c:	30 e0       	ldi	r19, 0x00	; 0
    379e:	40 e2       	ldi	r20, 0x20	; 32
    37a0:	51 e4       	ldi	r21, 0x41	; 65
    37a2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    37a6:	dc 01       	movw	r26, r24
    37a8:	cb 01       	movw	r24, r22
    37aa:	bc 01       	movw	r22, r24
    37ac:	cd 01       	movw	r24, r26
    37ae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    37b2:	dc 01       	movw	r26, r24
    37b4:	cb 01       	movw	r24, r22
    37b6:	9e 83       	std	Y+6, r25	; 0x06
    37b8:	8d 83       	std	Y+5, r24	; 0x05
    37ba:	0f c0       	rjmp	.+30     	; 0x37da <HCLCD_VidWriteChar_4Bits+0xf2>
    37bc:	88 ec       	ldi	r24, 0xC8	; 200
    37be:	90 e0       	ldi	r25, 0x00	; 0
    37c0:	9c 83       	std	Y+4, r25	; 0x04
    37c2:	8b 83       	std	Y+3, r24	; 0x03
    37c4:	8b 81       	ldd	r24, Y+3	; 0x03
    37c6:	9c 81       	ldd	r25, Y+4	; 0x04
    37c8:	01 97       	sbiw	r24, 0x01	; 1
    37ca:	f1 f7       	brne	.-4      	; 0x37c8 <HCLCD_VidWriteChar_4Bits+0xe0>
    37cc:	9c 83       	std	Y+4, r25	; 0x04
    37ce:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    37d0:	8d 81       	ldd	r24, Y+5	; 0x05
    37d2:	9e 81       	ldd	r25, Y+6	; 0x06
    37d4:	01 97       	sbiw	r24, 0x01	; 1
    37d6:	9e 83       	std	Y+6, r25	; 0x06
    37d8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    37da:	8d 81       	ldd	r24, Y+5	; 0x05
    37dc:	9e 81       	ldd	r25, Y+6	; 0x06
    37de:	00 97       	sbiw	r24, 0x00	; 0
    37e0:	69 f7       	brne	.-38     	; 0x37bc <HCLCD_VidWriteChar_4Bits+0xd4>
    37e2:	14 c0       	rjmp	.+40     	; 0x380c <HCLCD_VidWriteChar_4Bits+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    37e4:	6f 81       	ldd	r22, Y+7	; 0x07
    37e6:	78 85       	ldd	r23, Y+8	; 0x08
    37e8:	89 85       	ldd	r24, Y+9	; 0x09
    37ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    37ec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    37f0:	dc 01       	movw	r26, r24
    37f2:	cb 01       	movw	r24, r22
    37f4:	9e 83       	std	Y+6, r25	; 0x06
    37f6:	8d 83       	std	Y+5, r24	; 0x05
    37f8:	8d 81       	ldd	r24, Y+5	; 0x05
    37fa:	9e 81       	ldd	r25, Y+6	; 0x06
    37fc:	9a 83       	std	Y+2, r25	; 0x02
    37fe:	89 83       	std	Y+1, r24	; 0x01
    3800:	89 81       	ldd	r24, Y+1	; 0x01
    3802:	9a 81       	ldd	r25, Y+2	; 0x02
    3804:	01 97       	sbiw	r24, 0x01	; 1
    3806:	f1 f7       	brne	.-4      	; 0x3804 <HCLCD_VidWriteChar_4Bits+0x11c>
    3808:	9a 83       	std	Y+2, r25	; 0x02
    380a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    380c:	82 e0       	ldi	r24, 0x02	; 2
    380e:	60 e0       	ldi	r22, 0x00	; 0
    3810:	40 e0       	ldi	r20, 0x00	; 0
    3812:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
}
    3816:	60 96       	adiw	r28, 0x10	; 16
    3818:	0f b6       	in	r0, 0x3f	; 63
    381a:	f8 94       	cli
    381c:	de bf       	out	0x3e, r29	; 62
    381e:	0f be       	out	0x3f, r0	; 63
    3820:	cd bf       	out	0x3d, r28	; 61
    3822:	cf 91       	pop	r28
    3824:	df 91       	pop	r29
    3826:	08 95       	ret

00003828 <HCLCD_VidSendChar_4Bits>:
void HCLCD_VidSendChar_4Bits(u8 Copy_u8Data)
{
    3828:	df 93       	push	r29
    382a:	cf 93       	push	r28
    382c:	0f 92       	push	r0
    382e:	cd b7       	in	r28, 0x3d	; 61
    3830:	de b7       	in	r29, 0x3e	; 62
    3832:	89 83       	std	Y+1, r24	; 0x01
	HCLCD_VidWriteChar_4Bits(Copy_u8Data>>4);
    3834:	89 81       	ldd	r24, Y+1	; 0x01
    3836:	82 95       	swap	r24
    3838:	8f 70       	andi	r24, 0x0F	; 15
    383a:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <HCLCD_VidWriteChar_4Bits>
	HCLCD_VidWriteChar_4Bits(Copy_u8Data);
    383e:	89 81       	ldd	r24, Y+1	; 0x01
    3840:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <HCLCD_VidWriteChar_4Bits>
}
    3844:	0f 90       	pop	r0
    3846:	cf 91       	pop	r28
    3848:	df 91       	pop	r29
    384a:	08 95       	ret

0000384c <HCLCD_VidWriteString_4Bits>:
void HCLCD_VidWriteString_4Bits(u8* PCopy_u8String)
{
    384c:	df 93       	push	r29
    384e:	cf 93       	push	r28
    3850:	00 d0       	rcall	.+0      	; 0x3852 <HCLCD_VidWriteString_4Bits+0x6>
    3852:	0f 92       	push	r0
    3854:	cd b7       	in	r28, 0x3d	; 61
    3856:	de b7       	in	r29, 0x3e	; 62
    3858:	9b 83       	std	Y+3, r25	; 0x03
    385a:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Count=0;
    385c:	19 82       	std	Y+1, r1	; 0x01
    385e:	0e c0       	rjmp	.+28     	; 0x387c <HCLCD_VidWriteString_4Bits+0x30>
	while(PCopy_u8String[Loc_u8Count]!=NULL)
	{
		HCLCD_VidSendChar_4Bits(PCopy_u8String[Loc_u8Count]);
    3860:	89 81       	ldd	r24, Y+1	; 0x01
    3862:	28 2f       	mov	r18, r24
    3864:	30 e0       	ldi	r19, 0x00	; 0
    3866:	8a 81       	ldd	r24, Y+2	; 0x02
    3868:	9b 81       	ldd	r25, Y+3	; 0x03
    386a:	fc 01       	movw	r30, r24
    386c:	e2 0f       	add	r30, r18
    386e:	f3 1f       	adc	r31, r19
    3870:	80 81       	ld	r24, Z
    3872:	0e 94 14 1c 	call	0x3828	; 0x3828 <HCLCD_VidSendChar_4Bits>
		Loc_u8Count++;
    3876:	89 81       	ldd	r24, Y+1	; 0x01
    3878:	8f 5f       	subi	r24, 0xFF	; 255
    387a:	89 83       	std	Y+1, r24	; 0x01
	HCLCD_VidWriteChar_4Bits(Copy_u8Data);
}
void HCLCD_VidWriteString_4Bits(u8* PCopy_u8String)
{
	u8 Loc_u8Count=0;
	while(PCopy_u8String[Loc_u8Count]!=NULL)
    387c:	89 81       	ldd	r24, Y+1	; 0x01
    387e:	28 2f       	mov	r18, r24
    3880:	30 e0       	ldi	r19, 0x00	; 0
    3882:	8a 81       	ldd	r24, Y+2	; 0x02
    3884:	9b 81       	ldd	r25, Y+3	; 0x03
    3886:	fc 01       	movw	r30, r24
    3888:	e2 0f       	add	r30, r18
    388a:	f3 1f       	adc	r31, r19
    388c:	80 81       	ld	r24, Z
    388e:	88 23       	and	r24, r24
    3890:	39 f7       	brne	.-50     	; 0x3860 <HCLCD_VidWriteString_4Bits+0x14>
	{
		HCLCD_VidSendChar_4Bits(PCopy_u8String[Loc_u8Count]);
		Loc_u8Count++;
	}
}
    3892:	0f 90       	pop	r0
    3894:	0f 90       	pop	r0
    3896:	0f 90       	pop	r0
    3898:	cf 91       	pop	r28
    389a:	df 91       	pop	r29
    389c:	08 95       	ret

0000389e <HCLCD_VidWriteNumber_4Bits>:
void HCLCD_VidWriteNumber_4Bits(u32 Copy_u8Number)
{
    389e:	0f 93       	push	r16
    38a0:	1f 93       	push	r17
    38a2:	df 93       	push	r29
    38a4:	cf 93       	push	r28
    38a6:	cd b7       	in	r28, 0x3d	; 61
    38a8:	de b7       	in	r29, 0x3e	; 62
    38aa:	60 97       	sbiw	r28, 0x10	; 16
    38ac:	0f b6       	in	r0, 0x3f	; 63
    38ae:	f8 94       	cli
    38b0:	de bf       	out	0x3e, r29	; 62
    38b2:	0f be       	out	0x3f, r0	; 63
    38b4:	cd bf       	out	0x3d, r28	; 61
    38b6:	6d 87       	std	Y+13, r22	; 0x0d
    38b8:	7e 87       	std	Y+14, r23	; 0x0e
    38ba:	8f 87       	std	Y+15, r24	; 0x0f
    38bc:	98 8b       	std	Y+16, r25	; 0x10
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
    38be:	1a 82       	std	Y+2, r1	; 0x02
	if(Copy_u8Number>0)
    38c0:	8d 85       	ldd	r24, Y+13	; 0x0d
    38c2:	9e 85       	ldd	r25, Y+14	; 0x0e
    38c4:	af 85       	ldd	r26, Y+15	; 0x0f
    38c6:	b8 89       	ldd	r27, Y+16	; 0x10
    38c8:	00 97       	sbiw	r24, 0x00	; 0
    38ca:	a1 05       	cpc	r26, r1
    38cc:	b1 05       	cpc	r27, r1
    38ce:	09 f4       	brne	.+2      	; 0x38d2 <HCLCD_VidWriteNumber_4Bits+0x34>
    38d0:	4f c0       	rjmp	.+158    	; 0x3970 <HCLCD_VidWriteNumber_4Bits+0xd2>
    38d2:	2d c0       	rjmp	.+90     	; 0x392e <HCLCD_VidWriteNumber_4Bits+0x90>
	{
		while(Copy_u8Number!=0)
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
    38d4:	8a 81       	ldd	r24, Y+2	; 0x02
    38d6:	08 2f       	mov	r16, r24
    38d8:	10 e0       	ldi	r17, 0x00	; 0
    38da:	8d 85       	ldd	r24, Y+13	; 0x0d
    38dc:	9e 85       	ldd	r25, Y+14	; 0x0e
    38de:	af 85       	ldd	r26, Y+15	; 0x0f
    38e0:	b8 89       	ldd	r27, Y+16	; 0x10
    38e2:	2a e0       	ldi	r18, 0x0A	; 10
    38e4:	30 e0       	ldi	r19, 0x00	; 0
    38e6:	40 e0       	ldi	r20, 0x00	; 0
    38e8:	50 e0       	ldi	r21, 0x00	; 0
    38ea:	bc 01       	movw	r22, r24
    38ec:	cd 01       	movw	r24, r26
    38ee:	0e 94 07 37 	call	0x6e0e	; 0x6e0e <__udivmodsi4>
    38f2:	dc 01       	movw	r26, r24
    38f4:	cb 01       	movw	r24, r22
    38f6:	28 2f       	mov	r18, r24
    38f8:	ce 01       	movw	r24, r28
    38fa:	03 96       	adiw	r24, 0x03	; 3
    38fc:	fc 01       	movw	r30, r24
    38fe:	e0 0f       	add	r30, r16
    3900:	f1 1f       	adc	r31, r17
    3902:	20 83       	st	Z, r18
			Copy_u8Number/=10;
    3904:	8d 85       	ldd	r24, Y+13	; 0x0d
    3906:	9e 85       	ldd	r25, Y+14	; 0x0e
    3908:	af 85       	ldd	r26, Y+15	; 0x0f
    390a:	b8 89       	ldd	r27, Y+16	; 0x10
    390c:	2a e0       	ldi	r18, 0x0A	; 10
    390e:	30 e0       	ldi	r19, 0x00	; 0
    3910:	40 e0       	ldi	r20, 0x00	; 0
    3912:	50 e0       	ldi	r21, 0x00	; 0
    3914:	bc 01       	movw	r22, r24
    3916:	cd 01       	movw	r24, r26
    3918:	0e 94 07 37 	call	0x6e0e	; 0x6e0e <__udivmodsi4>
    391c:	da 01       	movw	r26, r20
    391e:	c9 01       	movw	r24, r18
    3920:	8d 87       	std	Y+13, r24	; 0x0d
    3922:	9e 87       	std	Y+14, r25	; 0x0e
    3924:	af 87       	std	Y+15, r26	; 0x0f
    3926:	b8 8b       	std	Y+16, r27	; 0x10
			LOC_Count++;
    3928:	8a 81       	ldd	r24, Y+2	; 0x02
    392a:	8f 5f       	subi	r24, 0xFF	; 255
    392c:	8a 83       	std	Y+2, r24	; 0x02
{
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
	if(Copy_u8Number>0)
	{
		while(Copy_u8Number!=0)
    392e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3930:	9e 85       	ldd	r25, Y+14	; 0x0e
    3932:	af 85       	ldd	r26, Y+15	; 0x0f
    3934:	b8 89       	ldd	r27, Y+16	; 0x10
    3936:	00 97       	sbiw	r24, 0x00	; 0
    3938:	a1 05       	cpc	r26, r1
    393a:	b1 05       	cpc	r27, r1
    393c:	59 f6       	brne	.-106    	; 0x38d4 <HCLCD_VidWriteNumber_4Bits+0x36>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    393e:	8a 81       	ldd	r24, Y+2	; 0x02
    3940:	81 50       	subi	r24, 0x01	; 1
    3942:	89 83       	std	Y+1, r24	; 0x01
    3944:	11 c0       	rjmp	.+34     	; 0x3968 <HCLCD_VidWriteNumber_4Bits+0xca>
		{
			HCLCD_VidSendChar_4Bits(ARR_Digits[i]+'0');
    3946:	89 81       	ldd	r24, Y+1	; 0x01
    3948:	28 2f       	mov	r18, r24
    394a:	33 27       	eor	r19, r19
    394c:	27 fd       	sbrc	r18, 7
    394e:	30 95       	com	r19
    3950:	ce 01       	movw	r24, r28
    3952:	03 96       	adiw	r24, 0x03	; 3
    3954:	fc 01       	movw	r30, r24
    3956:	e2 0f       	add	r30, r18
    3958:	f3 1f       	adc	r31, r19
    395a:	80 81       	ld	r24, Z
    395c:	80 5d       	subi	r24, 0xD0	; 208
    395e:	0e 94 14 1c 	call	0x3828	; 0x3828 <HCLCD_VidSendChar_4Bits>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    3962:	89 81       	ldd	r24, Y+1	; 0x01
    3964:	81 50       	subi	r24, 0x01	; 1
    3966:	89 83       	std	Y+1, r24	; 0x01
    3968:	89 81       	ldd	r24, Y+1	; 0x01
    396a:	88 23       	and	r24, r24
    396c:	64 f7       	brge	.-40     	; 0x3946 <HCLCD_VidWriteNumber_4Bits+0xa8>
    396e:	03 c0       	rjmp	.+6      	; 0x3976 <HCLCD_VidWriteNumber_4Bits+0xd8>
			HCLCD_VidSendChar_4Bits(ARR_Digits[i]+'0');
		}
	}
	else
	{
		HCLCD_VidWriteChar_8Bits('0');
    3970:	80 e3       	ldi	r24, 0x30	; 48
    3972:	0e 94 f5 16 	call	0x2dea	; 0x2dea <HCLCD_VidWriteChar_8Bits>
	}
}
    3976:	60 96       	adiw	r28, 0x10	; 16
    3978:	0f b6       	in	r0, 0x3f	; 63
    397a:	f8 94       	cli
    397c:	de bf       	out	0x3e, r29	; 62
    397e:	0f be       	out	0x3f, r0	; 63
    3980:	cd bf       	out	0x3d, r28	; 61
    3982:	cf 91       	pop	r28
    3984:	df 91       	pop	r29
    3986:	1f 91       	pop	r17
    3988:	0f 91       	pop	r16
    398a:	08 95       	ret

0000398c <HCLCD_VidSetPosition_4BitsMode>:
void HCLCD_VidSetPosition_4BitsMode(u8 Copy_u8LineNumber , u8 Copy_u8PositionNumber)
{
    398c:	df 93       	push	r29
    398e:	cf 93       	push	r28
    3990:	00 d0       	rcall	.+0      	; 0x3992 <HCLCD_VidSetPosition_4BitsMode+0x6>
    3992:	cd b7       	in	r28, 0x3d	; 61
    3994:	de b7       	in	r29, 0x3e	; 62
    3996:	89 83       	std	Y+1, r24	; 0x01
    3998:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8LineNumber==HCLCD_LINE1)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    399a:	89 81       	ldd	r24, Y+1	; 0x01
    399c:	81 30       	cpi	r24, 0x01	; 1
    399e:	b9 f4       	brne	.+46     	; 0x39ce <HCLCD_VidSetPosition_4BitsMode+0x42>
    39a0:	8a 81       	ldd	r24, Y+2	; 0x02
    39a2:	80 31       	cpi	r24, 0x10	; 16
    39a4:	a0 f4       	brcc	.+40     	; 0x39ce <HCLCD_VidSetPosition_4BitsMode+0x42>
	{
		HCLCD_VidWriteCommand_4Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber)>>4);
    39a6:	8a 81       	ldd	r24, Y+2	; 0x02
    39a8:	88 2f       	mov	r24, r24
    39aa:	90 e0       	ldi	r25, 0x00	; 0
    39ac:	80 58       	subi	r24, 0x80	; 128
    39ae:	9f 4f       	sbci	r25, 0xFF	; 255
    39b0:	95 95       	asr	r25
    39b2:	87 95       	ror	r24
    39b4:	95 95       	asr	r25
    39b6:	87 95       	ror	r24
    39b8:	95 95       	asr	r25
    39ba:	87 95       	ror	r24
    39bc:	95 95       	asr	r25
    39be:	87 95       	ror	r24
    39c0:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
		HCLCD_VidWriteCommand_4Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber));
    39c4:	8a 81       	ldd	r24, Y+2	; 0x02
    39c6:	80 58       	subi	r24, 0x80	; 128
    39c8:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
    39cc:	19 c0       	rjmp	.+50     	; 0x3a00 <HCLCD_VidSetPosition_4BitsMode+0x74>
	}
	else if((Copy_u8LineNumber==HCLCD_LINE2)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    39ce:	89 81       	ldd	r24, Y+1	; 0x01
    39d0:	82 30       	cpi	r24, 0x02	; 2
    39d2:	b1 f4       	brne	.+44     	; 0x3a00 <HCLCD_VidSetPosition_4BitsMode+0x74>
    39d4:	8a 81       	ldd	r24, Y+2	; 0x02
    39d6:	80 31       	cpi	r24, 0x10	; 16
    39d8:	98 f4       	brcc	.+38     	; 0x3a00 <HCLCD_VidSetPosition_4BitsMode+0x74>
	{
		HCLCD_VidWriteCommand_4Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber)>>4);
    39da:	8a 81       	ldd	r24, Y+2	; 0x02
    39dc:	88 2f       	mov	r24, r24
    39de:	90 e0       	ldi	r25, 0x00	; 0
    39e0:	80 54       	subi	r24, 0x40	; 64
    39e2:	9f 4f       	sbci	r25, 0xFF	; 255
    39e4:	95 95       	asr	r25
    39e6:	87 95       	ror	r24
    39e8:	95 95       	asr	r25
    39ea:	87 95       	ror	r24
    39ec:	95 95       	asr	r25
    39ee:	87 95       	ror	r24
    39f0:	95 95       	asr	r25
    39f2:	87 95       	ror	r24
    39f4:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
		HCLCD_VidWriteCommand_4Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber));
    39f8:	8a 81       	ldd	r24, Y+2	; 0x02
    39fa:	80 54       	subi	r24, 0x40	; 64
    39fc:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
	}
	else
	{
		/*Do Nothing*/
	}
}
    3a00:	0f 90       	pop	r0
    3a02:	0f 90       	pop	r0
    3a04:	cf 91       	pop	r28
    3a06:	df 91       	pop	r29
    3a08:	08 95       	ret

00003a0a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    3a0a:	df 93       	push	r29
    3a0c:	cf 93       	push	r28
    3a0e:	cd b7       	in	r28, 0x3d	; 61
    3a10:	de b7       	in	r29, 0x3e	; 62
    3a12:	27 97       	sbiw	r28, 0x07	; 7
    3a14:	0f b6       	in	r0, 0x3f	; 63
    3a16:	f8 94       	cli
    3a18:	de bf       	out	0x3e, r29	; 62
    3a1a:	0f be       	out	0x3f, r0	; 63
    3a1c:	cd bf       	out	0x3d, r28	; 61
    3a1e:	9d 83       	std	Y+5, r25	; 0x05
    3a20:	8c 83       	std	Y+4, r24	; 0x04
    3a22:	6e 83       	std	Y+6, r22	; 0x06
    3a24:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    3a26:	8a e1       	ldi	r24, 0x1A	; 26
    3a28:	90 e0       	ldi	r25, 0x00	; 0
    3a2a:	0e 94 dd 1f 	call	0x3fba	; 0x3fba <pvPortMalloc>
    3a2e:	9a 83       	std	Y+2, r25	; 0x02
    3a30:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    3a32:	89 81       	ldd	r24, Y+1	; 0x01
    3a34:	9a 81       	ldd	r25, Y+2	; 0x02
    3a36:	00 97       	sbiw	r24, 0x00	; 0
    3a38:	09 f4       	brne	.+2      	; 0x3a3c <xCoRoutineCreate+0x32>
    3a3a:	6f c0       	rjmp	.+222    	; 0x3b1a <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    3a3c:	80 91 fc 01 	lds	r24, 0x01FC
    3a40:	90 91 fd 01 	lds	r25, 0x01FD
    3a44:	00 97       	sbiw	r24, 0x00	; 0
    3a46:	41 f4       	brne	.+16     	; 0x3a58 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    3a48:	89 81       	ldd	r24, Y+1	; 0x01
    3a4a:	9a 81       	ldd	r25, Y+2	; 0x02
    3a4c:	90 93 fd 01 	sts	0x01FD, r25
    3a50:	80 93 fc 01 	sts	0x01FC, r24
			prvInitialiseCoRoutineLists();
    3a54:	0e 94 6c 1f 	call	0x3ed8	; 0x3ed8 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    3a58:	8e 81       	ldd	r24, Y+6	; 0x06
    3a5a:	82 30       	cpi	r24, 0x02	; 2
    3a5c:	10 f0       	brcs	.+4      	; 0x3a62 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    3a5e:	81 e0       	ldi	r24, 0x01	; 1
    3a60:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    3a62:	e9 81       	ldd	r30, Y+1	; 0x01
    3a64:	fa 81       	ldd	r31, Y+2	; 0x02
    3a66:	11 8e       	std	Z+25, r1	; 0x19
    3a68:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    3a6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3a6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3a6e:	8e 81       	ldd	r24, Y+6	; 0x06
    3a70:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    3a72:	e9 81       	ldd	r30, Y+1	; 0x01
    3a74:	fa 81       	ldd	r31, Y+2	; 0x02
    3a76:	8f 81       	ldd	r24, Y+7	; 0x07
    3a78:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    3a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    3a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    3a7e:	8c 81       	ldd	r24, Y+4	; 0x04
    3a80:	9d 81       	ldd	r25, Y+5	; 0x05
    3a82:	91 83       	std	Z+1, r25	; 0x01
    3a84:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    3a86:	89 81       	ldd	r24, Y+1	; 0x01
    3a88:	9a 81       	ldd	r25, Y+2	; 0x02
    3a8a:	02 96       	adiw	r24, 0x02	; 2
    3a8c:	0e 94 73 20 	call	0x40e6	; 0x40e6 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    3a90:	89 81       	ldd	r24, Y+1	; 0x01
    3a92:	9a 81       	ldd	r25, Y+2	; 0x02
    3a94:	0c 96       	adiw	r24, 0x0c	; 12
    3a96:	0e 94 73 20 	call	0x40e6	; 0x40e6 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    3a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3a9e:	89 81       	ldd	r24, Y+1	; 0x01
    3aa0:	9a 81       	ldd	r25, Y+2	; 0x02
    3aa2:	91 87       	std	Z+9, r25	; 0x09
    3aa4:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    3aa6:	e9 81       	ldd	r30, Y+1	; 0x01
    3aa8:	fa 81       	ldd	r31, Y+2	; 0x02
    3aaa:	89 81       	ldd	r24, Y+1	; 0x01
    3aac:	9a 81       	ldd	r25, Y+2	; 0x02
    3aae:	93 8b       	std	Z+19, r25	; 0x13
    3ab0:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    3ab2:	8e 81       	ldd	r24, Y+6	; 0x06
    3ab4:	28 2f       	mov	r18, r24
    3ab6:	30 e0       	ldi	r19, 0x00	; 0
    3ab8:	88 e0       	ldi	r24, 0x08	; 8
    3aba:	90 e0       	ldi	r25, 0x00	; 0
    3abc:	82 1b       	sub	r24, r18
    3abe:	93 0b       	sbc	r25, r19
    3ac0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ac2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ac4:	95 87       	std	Z+13, r25	; 0x0d
    3ac6:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    3ac8:	e9 81       	ldd	r30, Y+1	; 0x01
    3aca:	fa 81       	ldd	r31, Y+2	; 0x02
    3acc:	96 89       	ldd	r25, Z+22	; 0x16
    3ace:	80 91 fe 01 	lds	r24, 0x01FE
    3ad2:	89 17       	cp	r24, r25
    3ad4:	28 f4       	brcc	.+10     	; 0x3ae0 <xCoRoutineCreate+0xd6>
    3ad6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ad8:	fa 81       	ldd	r31, Y+2	; 0x02
    3ada:	86 89       	ldd	r24, Z+22	; 0x16
    3adc:	80 93 fe 01 	sts	0x01FE, r24
    3ae0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ae2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ae4:	86 89       	ldd	r24, Z+22	; 0x16
    3ae6:	28 2f       	mov	r18, r24
    3ae8:	30 e0       	ldi	r19, 0x00	; 0
    3aea:	c9 01       	movw	r24, r18
    3aec:	88 0f       	add	r24, r24
    3aee:	99 1f       	adc	r25, r25
    3af0:	88 0f       	add	r24, r24
    3af2:	99 1f       	adc	r25, r25
    3af4:	88 0f       	add	r24, r24
    3af6:	99 1f       	adc	r25, r25
    3af8:	82 0f       	add	r24, r18
    3afa:	93 1f       	adc	r25, r19
    3afc:	ac 01       	movw	r20, r24
    3afe:	4b 5f       	subi	r20, 0xFB	; 251
    3b00:	5d 4f       	sbci	r21, 0xFD	; 253
    3b02:	89 81       	ldd	r24, Y+1	; 0x01
    3b04:	9a 81       	ldd	r25, Y+2	; 0x02
    3b06:	9c 01       	movw	r18, r24
    3b08:	2e 5f       	subi	r18, 0xFE	; 254
    3b0a:	3f 4f       	sbci	r19, 0xFF	; 255
    3b0c:	ca 01       	movw	r24, r20
    3b0e:	b9 01       	movw	r22, r18
    3b10:	0e 94 83 20 	call	0x4106	; 0x4106 <vListInsertEnd>

		xReturn = pdPASS;
    3b14:	81 e0       	ldi	r24, 0x01	; 1
    3b16:	8b 83       	std	Y+3, r24	; 0x03
    3b18:	02 c0       	rjmp	.+4      	; 0x3b1e <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3b1a:	8f ef       	ldi	r24, 0xFF	; 255
    3b1c:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    3b1e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3b20:	27 96       	adiw	r28, 0x07	; 7
    3b22:	0f b6       	in	r0, 0x3f	; 63
    3b24:	f8 94       	cli
    3b26:	de bf       	out	0x3e, r29	; 62
    3b28:	0f be       	out	0x3f, r0	; 63
    3b2a:	cd bf       	out	0x3d, r28	; 61
    3b2c:	cf 91       	pop	r28
    3b2e:	df 91       	pop	r29
    3b30:	08 95       	ret

00003b32 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    3b32:	df 93       	push	r29
    3b34:	cf 93       	push	r28
    3b36:	00 d0       	rcall	.+0      	; 0x3b38 <vCoRoutineAddToDelayedList+0x6>
    3b38:	00 d0       	rcall	.+0      	; 0x3b3a <vCoRoutineAddToDelayedList+0x8>
    3b3a:	00 d0       	rcall	.+0      	; 0x3b3c <vCoRoutineAddToDelayedList+0xa>
    3b3c:	cd b7       	in	r28, 0x3d	; 61
    3b3e:	de b7       	in	r29, 0x3e	; 62
    3b40:	9c 83       	std	Y+4, r25	; 0x04
    3b42:	8b 83       	std	Y+3, r24	; 0x03
    3b44:	7e 83       	std	Y+6, r23	; 0x06
    3b46:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    3b48:	20 91 ff 01 	lds	r18, 0x01FF
    3b4c:	30 91 00 02 	lds	r19, 0x0200
    3b50:	8b 81       	ldd	r24, Y+3	; 0x03
    3b52:	9c 81       	ldd	r25, Y+4	; 0x04
    3b54:	82 0f       	add	r24, r18
    3b56:	93 1f       	adc	r25, r19
    3b58:	9a 83       	std	Y+2, r25	; 0x02
    3b5a:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3b5c:	80 91 fc 01 	lds	r24, 0x01FC
    3b60:	90 91 fd 01 	lds	r25, 0x01FD
    3b64:	02 96       	adiw	r24, 0x02	; 2
    3b66:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    3b6a:	e0 91 fc 01 	lds	r30, 0x01FC
    3b6e:	f0 91 fd 01 	lds	r31, 0x01FD
    3b72:	89 81       	ldd	r24, Y+1	; 0x01
    3b74:	9a 81       	ldd	r25, Y+2	; 0x02
    3b76:	93 83       	std	Z+3, r25	; 0x03
    3b78:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    3b7a:	20 91 ff 01 	lds	r18, 0x01FF
    3b7e:	30 91 00 02 	lds	r19, 0x0200
    3b82:	89 81       	ldd	r24, Y+1	; 0x01
    3b84:	9a 81       	ldd	r25, Y+2	; 0x02
    3b86:	82 17       	cp	r24, r18
    3b88:	93 07       	cpc	r25, r19
    3b8a:	70 f4       	brcc	.+28     	; 0x3ba8 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3b8c:	80 91 2b 02 	lds	r24, 0x022B
    3b90:	90 91 2c 02 	lds	r25, 0x022C
    3b94:	20 91 fc 01 	lds	r18, 0x01FC
    3b98:	30 91 fd 01 	lds	r19, 0x01FD
    3b9c:	2e 5f       	subi	r18, 0xFE	; 254
    3b9e:	3f 4f       	sbci	r19, 0xFF	; 255
    3ba0:	b9 01       	movw	r22, r18
    3ba2:	0e 94 cf 20 	call	0x419e	; 0x419e <vListInsert>
    3ba6:	0d c0       	rjmp	.+26     	; 0x3bc2 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3ba8:	80 91 29 02 	lds	r24, 0x0229
    3bac:	90 91 2a 02 	lds	r25, 0x022A
    3bb0:	20 91 fc 01 	lds	r18, 0x01FC
    3bb4:	30 91 fd 01 	lds	r19, 0x01FD
    3bb8:	2e 5f       	subi	r18, 0xFE	; 254
    3bba:	3f 4f       	sbci	r19, 0xFF	; 255
    3bbc:	b9 01       	movw	r22, r18
    3bbe:	0e 94 cf 20 	call	0x419e	; 0x419e <vListInsert>
	}

	if( pxEventList )
    3bc2:	8d 81       	ldd	r24, Y+5	; 0x05
    3bc4:	9e 81       	ldd	r25, Y+6	; 0x06
    3bc6:	00 97       	sbiw	r24, 0x00	; 0
    3bc8:	61 f0       	breq	.+24     	; 0x3be2 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    3bca:	80 91 fc 01 	lds	r24, 0x01FC
    3bce:	90 91 fd 01 	lds	r25, 0x01FD
    3bd2:	9c 01       	movw	r18, r24
    3bd4:	24 5f       	subi	r18, 0xF4	; 244
    3bd6:	3f 4f       	sbci	r19, 0xFF	; 255
    3bd8:	8d 81       	ldd	r24, Y+5	; 0x05
    3bda:	9e 81       	ldd	r25, Y+6	; 0x06
    3bdc:	b9 01       	movw	r22, r18
    3bde:	0e 94 cf 20 	call	0x419e	; 0x419e <vListInsert>
	}
}
    3be2:	26 96       	adiw	r28, 0x06	; 6
    3be4:	0f b6       	in	r0, 0x3f	; 63
    3be6:	f8 94       	cli
    3be8:	de bf       	out	0x3e, r29	; 62
    3bea:	0f be       	out	0x3f, r0	; 63
    3bec:	cd bf       	out	0x3d, r28	; 61
    3bee:	cf 91       	pop	r28
    3bf0:	df 91       	pop	r29
    3bf2:	08 95       	ret

00003bf4 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    3bf4:	df 93       	push	r29
    3bf6:	cf 93       	push	r28
    3bf8:	00 d0       	rcall	.+0      	; 0x3bfa <prvCheckPendingReadyList+0x6>
    3bfa:	cd b7       	in	r28, 0x3d	; 61
    3bfc:	de b7       	in	r29, 0x3e	; 62
    3bfe:	3a c0       	rjmp	.+116    	; 0x3c74 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    3c00:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    3c02:	e0 91 32 02 	lds	r30, 0x0232
    3c06:	f0 91 33 02 	lds	r31, 0x0233
    3c0a:	86 81       	ldd	r24, Z+6	; 0x06
    3c0c:	97 81       	ldd	r25, Z+7	; 0x07
    3c0e:	9a 83       	std	Y+2, r25	; 0x02
    3c10:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    3c12:	89 81       	ldd	r24, Y+1	; 0x01
    3c14:	9a 81       	ldd	r25, Y+2	; 0x02
    3c16:	0c 96       	adiw	r24, 0x0c	; 12
    3c18:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    3c1c:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    3c1e:	89 81       	ldd	r24, Y+1	; 0x01
    3c20:	9a 81       	ldd	r25, Y+2	; 0x02
    3c22:	02 96       	adiw	r24, 0x02	; 2
    3c24:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    3c28:	e9 81       	ldd	r30, Y+1	; 0x01
    3c2a:	fa 81       	ldd	r31, Y+2	; 0x02
    3c2c:	96 89       	ldd	r25, Z+22	; 0x16
    3c2e:	80 91 fe 01 	lds	r24, 0x01FE
    3c32:	89 17       	cp	r24, r25
    3c34:	28 f4       	brcc	.+10     	; 0x3c40 <prvCheckPendingReadyList+0x4c>
    3c36:	e9 81       	ldd	r30, Y+1	; 0x01
    3c38:	fa 81       	ldd	r31, Y+2	; 0x02
    3c3a:	86 89       	ldd	r24, Z+22	; 0x16
    3c3c:	80 93 fe 01 	sts	0x01FE, r24
    3c40:	e9 81       	ldd	r30, Y+1	; 0x01
    3c42:	fa 81       	ldd	r31, Y+2	; 0x02
    3c44:	86 89       	ldd	r24, Z+22	; 0x16
    3c46:	28 2f       	mov	r18, r24
    3c48:	30 e0       	ldi	r19, 0x00	; 0
    3c4a:	c9 01       	movw	r24, r18
    3c4c:	88 0f       	add	r24, r24
    3c4e:	99 1f       	adc	r25, r25
    3c50:	88 0f       	add	r24, r24
    3c52:	99 1f       	adc	r25, r25
    3c54:	88 0f       	add	r24, r24
    3c56:	99 1f       	adc	r25, r25
    3c58:	82 0f       	add	r24, r18
    3c5a:	93 1f       	adc	r25, r19
    3c5c:	ac 01       	movw	r20, r24
    3c5e:	4b 5f       	subi	r20, 0xFB	; 251
    3c60:	5d 4f       	sbci	r21, 0xFD	; 253
    3c62:	89 81       	ldd	r24, Y+1	; 0x01
    3c64:	9a 81       	ldd	r25, Y+2	; 0x02
    3c66:	9c 01       	movw	r18, r24
    3c68:	2e 5f       	subi	r18, 0xFE	; 254
    3c6a:	3f 4f       	sbci	r19, 0xFF	; 255
    3c6c:	ca 01       	movw	r24, r20
    3c6e:	b9 01       	movw	r22, r18
    3c70:	0e 94 83 20 	call	0x4106	; 0x4106 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    3c74:	80 91 2d 02 	lds	r24, 0x022D
    3c78:	88 23       	and	r24, r24
    3c7a:	09 f0       	breq	.+2      	; 0x3c7e <prvCheckPendingReadyList+0x8a>
    3c7c:	c1 cf       	rjmp	.-126    	; 0x3c00 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    3c7e:	0f 90       	pop	r0
    3c80:	0f 90       	pop	r0
    3c82:	cf 91       	pop	r28
    3c84:	df 91       	pop	r29
    3c86:	08 95       	ret

00003c88 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    3c88:	df 93       	push	r29
    3c8a:	cf 93       	push	r28
    3c8c:	00 d0       	rcall	.+0      	; 0x3c8e <prvCheckDelayedList+0x6>
    3c8e:	00 d0       	rcall	.+0      	; 0x3c90 <prvCheckDelayedList+0x8>
    3c90:	cd b7       	in	r28, 0x3d	; 61
    3c92:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    3c94:	0e 94 41 2c 	call	0x5882	; 0x5882 <xTaskGetTickCount>
    3c98:	20 91 01 02 	lds	r18, 0x0201
    3c9c:	30 91 02 02 	lds	r19, 0x0202
    3ca0:	82 1b       	sub	r24, r18
    3ca2:	93 0b       	sbc	r25, r19
    3ca4:	90 93 04 02 	sts	0x0204, r25
    3ca8:	80 93 03 02 	sts	0x0203, r24
    3cac:	85 c0       	rjmp	.+266    	; 0x3db8 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    3cae:	80 91 ff 01 	lds	r24, 0x01FF
    3cb2:	90 91 00 02 	lds	r25, 0x0200
    3cb6:	01 96       	adiw	r24, 0x01	; 1
    3cb8:	90 93 00 02 	sts	0x0200, r25
    3cbc:	80 93 ff 01 	sts	0x01FF, r24
		xPassedTicks--;
    3cc0:	80 91 03 02 	lds	r24, 0x0203
    3cc4:	90 91 04 02 	lds	r25, 0x0204
    3cc8:	01 97       	sbiw	r24, 0x01	; 1
    3cca:	90 93 04 02 	sts	0x0204, r25
    3cce:	80 93 03 02 	sts	0x0203, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    3cd2:	80 91 ff 01 	lds	r24, 0x01FF
    3cd6:	90 91 00 02 	lds	r25, 0x0200
    3cda:	00 97       	sbiw	r24, 0x00	; 0
    3cdc:	09 f0       	breq	.+2      	; 0x3ce0 <prvCheckDelayedList+0x58>
    3cde:	64 c0       	rjmp	.+200    	; 0x3da8 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    3ce0:	80 91 29 02 	lds	r24, 0x0229
    3ce4:	90 91 2a 02 	lds	r25, 0x022A
    3ce8:	9a 83       	std	Y+2, r25	; 0x02
    3cea:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    3cec:	80 91 2b 02 	lds	r24, 0x022B
    3cf0:	90 91 2c 02 	lds	r25, 0x022C
    3cf4:	90 93 2a 02 	sts	0x022A, r25
    3cf8:	80 93 29 02 	sts	0x0229, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    3cfc:	89 81       	ldd	r24, Y+1	; 0x01
    3cfe:	9a 81       	ldd	r25, Y+2	; 0x02
    3d00:	90 93 2c 02 	sts	0x022C, r25
    3d04:	80 93 2b 02 	sts	0x022B, r24
    3d08:	4f c0       	rjmp	.+158    	; 0x3da8 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    3d0a:	e0 91 29 02 	lds	r30, 0x0229
    3d0e:	f0 91 2a 02 	lds	r31, 0x022A
    3d12:	05 80       	ldd	r0, Z+5	; 0x05
    3d14:	f6 81       	ldd	r31, Z+6	; 0x06
    3d16:	e0 2d       	mov	r30, r0
    3d18:	86 81       	ldd	r24, Z+6	; 0x06
    3d1a:	97 81       	ldd	r25, Z+7	; 0x07
    3d1c:	9c 83       	std	Y+4, r25	; 0x04
    3d1e:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    3d20:	eb 81       	ldd	r30, Y+3	; 0x03
    3d22:	fc 81       	ldd	r31, Y+4	; 0x04
    3d24:	22 81       	ldd	r18, Z+2	; 0x02
    3d26:	33 81       	ldd	r19, Z+3	; 0x03
    3d28:	80 91 ff 01 	lds	r24, 0x01FF
    3d2c:	90 91 00 02 	lds	r25, 0x0200
    3d30:	82 17       	cp	r24, r18
    3d32:	93 07       	cpc	r25, r19
    3d34:	08 f4       	brcc	.+2      	; 0x3d38 <prvCheckDelayedList+0xb0>
    3d36:	40 c0       	rjmp	.+128    	; 0x3db8 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    3d38:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    3d3a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d3c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d3e:	02 96       	adiw	r24, 0x02	; 2
    3d40:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    3d44:	eb 81       	ldd	r30, Y+3	; 0x03
    3d46:	fc 81       	ldd	r31, Y+4	; 0x04
    3d48:	84 89       	ldd	r24, Z+20	; 0x14
    3d4a:	95 89       	ldd	r25, Z+21	; 0x15
    3d4c:	00 97       	sbiw	r24, 0x00	; 0
    3d4e:	29 f0       	breq	.+10     	; 0x3d5a <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    3d50:	8b 81       	ldd	r24, Y+3	; 0x03
    3d52:	9c 81       	ldd	r25, Y+4	; 0x04
    3d54:	0c 96       	adiw	r24, 0x0c	; 12
    3d56:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    3d5a:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    3d5c:	eb 81       	ldd	r30, Y+3	; 0x03
    3d5e:	fc 81       	ldd	r31, Y+4	; 0x04
    3d60:	96 89       	ldd	r25, Z+22	; 0x16
    3d62:	80 91 fe 01 	lds	r24, 0x01FE
    3d66:	89 17       	cp	r24, r25
    3d68:	28 f4       	brcc	.+10     	; 0x3d74 <prvCheckDelayedList+0xec>
    3d6a:	eb 81       	ldd	r30, Y+3	; 0x03
    3d6c:	fc 81       	ldd	r31, Y+4	; 0x04
    3d6e:	86 89       	ldd	r24, Z+22	; 0x16
    3d70:	80 93 fe 01 	sts	0x01FE, r24
    3d74:	eb 81       	ldd	r30, Y+3	; 0x03
    3d76:	fc 81       	ldd	r31, Y+4	; 0x04
    3d78:	86 89       	ldd	r24, Z+22	; 0x16
    3d7a:	28 2f       	mov	r18, r24
    3d7c:	30 e0       	ldi	r19, 0x00	; 0
    3d7e:	c9 01       	movw	r24, r18
    3d80:	88 0f       	add	r24, r24
    3d82:	99 1f       	adc	r25, r25
    3d84:	88 0f       	add	r24, r24
    3d86:	99 1f       	adc	r25, r25
    3d88:	88 0f       	add	r24, r24
    3d8a:	99 1f       	adc	r25, r25
    3d8c:	82 0f       	add	r24, r18
    3d8e:	93 1f       	adc	r25, r19
    3d90:	ac 01       	movw	r20, r24
    3d92:	4b 5f       	subi	r20, 0xFB	; 251
    3d94:	5d 4f       	sbci	r21, 0xFD	; 253
    3d96:	8b 81       	ldd	r24, Y+3	; 0x03
    3d98:	9c 81       	ldd	r25, Y+4	; 0x04
    3d9a:	9c 01       	movw	r18, r24
    3d9c:	2e 5f       	subi	r18, 0xFE	; 254
    3d9e:	3f 4f       	sbci	r19, 0xFF	; 255
    3da0:	ca 01       	movw	r24, r20
    3da2:	b9 01       	movw	r22, r18
    3da4:	0e 94 83 20 	call	0x4106	; 0x4106 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    3da8:	e0 91 29 02 	lds	r30, 0x0229
    3dac:	f0 91 2a 02 	lds	r31, 0x022A
    3db0:	80 81       	ld	r24, Z
    3db2:	88 23       	and	r24, r24
    3db4:	09 f0       	breq	.+2      	; 0x3db8 <prvCheckDelayedList+0x130>
    3db6:	a9 cf       	rjmp	.-174    	; 0x3d0a <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    3db8:	80 91 03 02 	lds	r24, 0x0203
    3dbc:	90 91 04 02 	lds	r25, 0x0204
    3dc0:	00 97       	sbiw	r24, 0x00	; 0
    3dc2:	09 f0       	breq	.+2      	; 0x3dc6 <prvCheckDelayedList+0x13e>
    3dc4:	74 cf       	rjmp	.-280    	; 0x3cae <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    3dc6:	80 91 ff 01 	lds	r24, 0x01FF
    3dca:	90 91 00 02 	lds	r25, 0x0200
    3dce:	90 93 02 02 	sts	0x0202, r25
    3dd2:	80 93 01 02 	sts	0x0201, r24
}
    3dd6:	0f 90       	pop	r0
    3dd8:	0f 90       	pop	r0
    3dda:	0f 90       	pop	r0
    3ddc:	0f 90       	pop	r0
    3dde:	cf 91       	pop	r28
    3de0:	df 91       	pop	r29
    3de2:	08 95       	ret

00003de4 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    3de4:	df 93       	push	r29
    3de6:	cf 93       	push	r28
    3de8:	00 d0       	rcall	.+0      	; 0x3dea <vCoRoutineSchedule+0x6>
    3dea:	cd b7       	in	r28, 0x3d	; 61
    3dec:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    3dee:	0e 94 fa 1d 	call	0x3bf4	; 0x3bf4 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    3df2:	0e 94 44 1e 	call	0x3c88	; 0x3c88 <prvCheckDelayedList>
    3df6:	0a c0       	rjmp	.+20     	; 0x3e0c <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    3df8:	80 91 fe 01 	lds	r24, 0x01FE
    3dfc:	88 23       	and	r24, r24
    3dfe:	09 f4       	brne	.+2      	; 0x3e02 <vCoRoutineSchedule+0x1e>
    3e00:	66 c0       	rjmp	.+204    	; 0x3ece <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    3e02:	80 91 fe 01 	lds	r24, 0x01FE
    3e06:	81 50       	subi	r24, 0x01	; 1
    3e08:	80 93 fe 01 	sts	0x01FE, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    3e0c:	80 91 fe 01 	lds	r24, 0x01FE
    3e10:	28 2f       	mov	r18, r24
    3e12:	30 e0       	ldi	r19, 0x00	; 0
    3e14:	c9 01       	movw	r24, r18
    3e16:	88 0f       	add	r24, r24
    3e18:	99 1f       	adc	r25, r25
    3e1a:	88 0f       	add	r24, r24
    3e1c:	99 1f       	adc	r25, r25
    3e1e:	88 0f       	add	r24, r24
    3e20:	99 1f       	adc	r25, r25
    3e22:	82 0f       	add	r24, r18
    3e24:	93 1f       	adc	r25, r19
    3e26:	fc 01       	movw	r30, r24
    3e28:	eb 5f       	subi	r30, 0xFB	; 251
    3e2a:	fd 4f       	sbci	r31, 0xFD	; 253
    3e2c:	80 81       	ld	r24, Z
    3e2e:	88 23       	and	r24, r24
    3e30:	19 f3       	breq	.-58     	; 0x3df8 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    3e32:	80 91 fe 01 	lds	r24, 0x01FE
    3e36:	28 2f       	mov	r18, r24
    3e38:	30 e0       	ldi	r19, 0x00	; 0
    3e3a:	c9 01       	movw	r24, r18
    3e3c:	88 0f       	add	r24, r24
    3e3e:	99 1f       	adc	r25, r25
    3e40:	88 0f       	add	r24, r24
    3e42:	99 1f       	adc	r25, r25
    3e44:	88 0f       	add	r24, r24
    3e46:	99 1f       	adc	r25, r25
    3e48:	82 0f       	add	r24, r18
    3e4a:	93 1f       	adc	r25, r19
    3e4c:	8b 5f       	subi	r24, 0xFB	; 251
    3e4e:	9d 4f       	sbci	r25, 0xFD	; 253
    3e50:	9a 83       	std	Y+2, r25	; 0x02
    3e52:	89 83       	std	Y+1, r24	; 0x01
    3e54:	e9 81       	ldd	r30, Y+1	; 0x01
    3e56:	fa 81       	ldd	r31, Y+2	; 0x02
    3e58:	01 80       	ldd	r0, Z+1	; 0x01
    3e5a:	f2 81       	ldd	r31, Z+2	; 0x02
    3e5c:	e0 2d       	mov	r30, r0
    3e5e:	82 81       	ldd	r24, Z+2	; 0x02
    3e60:	93 81       	ldd	r25, Z+3	; 0x03
    3e62:	e9 81       	ldd	r30, Y+1	; 0x01
    3e64:	fa 81       	ldd	r31, Y+2	; 0x02
    3e66:	92 83       	std	Z+2, r25	; 0x02
    3e68:	81 83       	std	Z+1, r24	; 0x01
    3e6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e6e:	21 81       	ldd	r18, Z+1	; 0x01
    3e70:	32 81       	ldd	r19, Z+2	; 0x02
    3e72:	89 81       	ldd	r24, Y+1	; 0x01
    3e74:	9a 81       	ldd	r25, Y+2	; 0x02
    3e76:	03 96       	adiw	r24, 0x03	; 3
    3e78:	28 17       	cp	r18, r24
    3e7a:	39 07       	cpc	r19, r25
    3e7c:	59 f4       	brne	.+22     	; 0x3e94 <vCoRoutineSchedule+0xb0>
    3e7e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e80:	fa 81       	ldd	r31, Y+2	; 0x02
    3e82:	01 80       	ldd	r0, Z+1	; 0x01
    3e84:	f2 81       	ldd	r31, Z+2	; 0x02
    3e86:	e0 2d       	mov	r30, r0
    3e88:	82 81       	ldd	r24, Z+2	; 0x02
    3e8a:	93 81       	ldd	r25, Z+3	; 0x03
    3e8c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e8e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e90:	92 83       	std	Z+2, r25	; 0x02
    3e92:	81 83       	std	Z+1, r24	; 0x01
    3e94:	e9 81       	ldd	r30, Y+1	; 0x01
    3e96:	fa 81       	ldd	r31, Y+2	; 0x02
    3e98:	01 80       	ldd	r0, Z+1	; 0x01
    3e9a:	f2 81       	ldd	r31, Z+2	; 0x02
    3e9c:	e0 2d       	mov	r30, r0
    3e9e:	86 81       	ldd	r24, Z+6	; 0x06
    3ea0:	97 81       	ldd	r25, Z+7	; 0x07
    3ea2:	90 93 fd 01 	sts	0x01FD, r25
    3ea6:	80 93 fc 01 	sts	0x01FC, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    3eaa:	e0 91 fc 01 	lds	r30, 0x01FC
    3eae:	f0 91 fd 01 	lds	r31, 0x01FD
    3eb2:	40 81       	ld	r20, Z
    3eb4:	51 81       	ldd	r21, Z+1	; 0x01
    3eb6:	80 91 fc 01 	lds	r24, 0x01FC
    3eba:	90 91 fd 01 	lds	r25, 0x01FD
    3ebe:	e0 91 fc 01 	lds	r30, 0x01FC
    3ec2:	f0 91 fd 01 	lds	r31, 0x01FD
    3ec6:	27 89       	ldd	r18, Z+23	; 0x17
    3ec8:	62 2f       	mov	r22, r18
    3eca:	fa 01       	movw	r30, r20
    3ecc:	09 95       	icall

	return;
}
    3ece:	0f 90       	pop	r0
    3ed0:	0f 90       	pop	r0
    3ed2:	cf 91       	pop	r28
    3ed4:	df 91       	pop	r29
    3ed6:	08 95       	ret

00003ed8 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    3ed8:	df 93       	push	r29
    3eda:	cf 93       	push	r28
    3edc:	0f 92       	push	r0
    3ede:	cd b7       	in	r28, 0x3d	; 61
    3ee0:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    3ee2:	19 82       	std	Y+1, r1	; 0x01
    3ee4:	13 c0       	rjmp	.+38     	; 0x3f0c <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    3ee6:	89 81       	ldd	r24, Y+1	; 0x01
    3ee8:	28 2f       	mov	r18, r24
    3eea:	30 e0       	ldi	r19, 0x00	; 0
    3eec:	c9 01       	movw	r24, r18
    3eee:	88 0f       	add	r24, r24
    3ef0:	99 1f       	adc	r25, r25
    3ef2:	88 0f       	add	r24, r24
    3ef4:	99 1f       	adc	r25, r25
    3ef6:	88 0f       	add	r24, r24
    3ef8:	99 1f       	adc	r25, r25
    3efa:	82 0f       	add	r24, r18
    3efc:	93 1f       	adc	r25, r19
    3efe:	8b 5f       	subi	r24, 0xFB	; 251
    3f00:	9d 4f       	sbci	r25, 0xFD	; 253
    3f02:	0e 94 49 20 	call	0x4092	; 0x4092 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    3f06:	89 81       	ldd	r24, Y+1	; 0x01
    3f08:	8f 5f       	subi	r24, 0xFF	; 255
    3f0a:	89 83       	std	Y+1, r24	; 0x01
    3f0c:	89 81       	ldd	r24, Y+1	; 0x01
    3f0e:	82 30       	cpi	r24, 0x02	; 2
    3f10:	50 f3       	brcs	.-44     	; 0x3ee6 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    3f12:	87 e1       	ldi	r24, 0x17	; 23
    3f14:	92 e0       	ldi	r25, 0x02	; 2
    3f16:	0e 94 49 20 	call	0x4092	; 0x4092 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    3f1a:	80 e2       	ldi	r24, 0x20	; 32
    3f1c:	92 e0       	ldi	r25, 0x02	; 2
    3f1e:	0e 94 49 20 	call	0x4092	; 0x4092 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    3f22:	8d e2       	ldi	r24, 0x2D	; 45
    3f24:	92 e0       	ldi	r25, 0x02	; 2
    3f26:	0e 94 49 20 	call	0x4092	; 0x4092 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    3f2a:	87 e1       	ldi	r24, 0x17	; 23
    3f2c:	92 e0       	ldi	r25, 0x02	; 2
    3f2e:	90 93 2a 02 	sts	0x022A, r25
    3f32:	80 93 29 02 	sts	0x0229, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    3f36:	80 e2       	ldi	r24, 0x20	; 32
    3f38:	92 e0       	ldi	r25, 0x02	; 2
    3f3a:	90 93 2c 02 	sts	0x022C, r25
    3f3e:	80 93 2b 02 	sts	0x022B, r24
}
    3f42:	0f 90       	pop	r0
    3f44:	cf 91       	pop	r28
    3f46:	df 91       	pop	r29
    3f48:	08 95       	ret

00003f4a <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    3f4a:	df 93       	push	r29
    3f4c:	cf 93       	push	r28
    3f4e:	00 d0       	rcall	.+0      	; 0x3f50 <xCoRoutineRemoveFromEventList+0x6>
    3f50:	00 d0       	rcall	.+0      	; 0x3f52 <xCoRoutineRemoveFromEventList+0x8>
    3f52:	0f 92       	push	r0
    3f54:	cd b7       	in	r28, 0x3d	; 61
    3f56:	de b7       	in	r29, 0x3e	; 62
    3f58:	9d 83       	std	Y+5, r25	; 0x05
    3f5a:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3f5c:	ec 81       	ldd	r30, Y+4	; 0x04
    3f5e:	fd 81       	ldd	r31, Y+5	; 0x05
    3f60:	05 80       	ldd	r0, Z+5	; 0x05
    3f62:	f6 81       	ldd	r31, Z+6	; 0x06
    3f64:	e0 2d       	mov	r30, r0
    3f66:	86 81       	ldd	r24, Z+6	; 0x06
    3f68:	97 81       	ldd	r25, Z+7	; 0x07
    3f6a:	9b 83       	std	Y+3, r25	; 0x03
    3f6c:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    3f6e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f70:	9b 81       	ldd	r25, Y+3	; 0x03
    3f72:	0c 96       	adiw	r24, 0x0c	; 12
    3f74:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    3f78:	8a 81       	ldd	r24, Y+2	; 0x02
    3f7a:	9b 81       	ldd	r25, Y+3	; 0x03
    3f7c:	9c 01       	movw	r18, r24
    3f7e:	24 5f       	subi	r18, 0xF4	; 244
    3f80:	3f 4f       	sbci	r19, 0xFF	; 255
    3f82:	8d e2       	ldi	r24, 0x2D	; 45
    3f84:	92 e0       	ldi	r25, 0x02	; 2
    3f86:	b9 01       	movw	r22, r18
    3f88:	0e 94 83 20 	call	0x4106	; 0x4106 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    3f8c:	ea 81       	ldd	r30, Y+2	; 0x02
    3f8e:	fb 81       	ldd	r31, Y+3	; 0x03
    3f90:	96 89       	ldd	r25, Z+22	; 0x16
    3f92:	e0 91 fc 01 	lds	r30, 0x01FC
    3f96:	f0 91 fd 01 	lds	r31, 0x01FD
    3f9a:	86 89       	ldd	r24, Z+22	; 0x16
    3f9c:	98 17       	cp	r25, r24
    3f9e:	18 f0       	brcs	.+6      	; 0x3fa6 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    3fa0:	81 e0       	ldi	r24, 0x01	; 1
    3fa2:	89 83       	std	Y+1, r24	; 0x01
    3fa4:	01 c0       	rjmp	.+2      	; 0x3fa8 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    3fa6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3fa8:	89 81       	ldd	r24, Y+1	; 0x01
}
    3faa:	0f 90       	pop	r0
    3fac:	0f 90       	pop	r0
    3fae:	0f 90       	pop	r0
    3fb0:	0f 90       	pop	r0
    3fb2:	0f 90       	pop	r0
    3fb4:	cf 91       	pop	r28
    3fb6:	df 91       	pop	r29
    3fb8:	08 95       	ret

00003fba <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3fba:	df 93       	push	r29
    3fbc:	cf 93       	push	r28
    3fbe:	00 d0       	rcall	.+0      	; 0x3fc0 <pvPortMalloc+0x6>
    3fc0:	00 d0       	rcall	.+0      	; 0x3fc2 <pvPortMalloc+0x8>
    3fc2:	cd b7       	in	r28, 0x3d	; 61
    3fc4:	de b7       	in	r29, 0x3e	; 62
    3fc6:	9c 83       	std	Y+4, r25	; 0x04
    3fc8:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    3fca:	1a 82       	std	Y+2, r1	; 0x02
    3fcc:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    3fce:	0e 94 ab 2b 	call	0x5756	; 0x5756 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    3fd2:	80 91 36 02 	lds	r24, 0x0236
    3fd6:	90 91 37 02 	lds	r25, 0x0237
    3fda:	2b 81       	ldd	r18, Y+3	; 0x03
    3fdc:	3c 81       	ldd	r19, Y+4	; 0x04
    3fde:	82 0f       	add	r24, r18
    3fe0:	93 1f       	adc	r25, r19
    3fe2:	25 e0       	ldi	r18, 0x05	; 5
    3fe4:	84 31       	cpi	r24, 0x14	; 20
    3fe6:	92 07       	cpc	r25, r18
    3fe8:	18 f5       	brcc	.+70     	; 0x4030 <pvPortMalloc+0x76>
    3fea:	20 91 36 02 	lds	r18, 0x0236
    3fee:	30 91 37 02 	lds	r19, 0x0237
    3ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ff4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ff6:	28 0f       	add	r18, r24
    3ff8:	39 1f       	adc	r19, r25
    3ffa:	80 91 36 02 	lds	r24, 0x0236
    3ffe:	90 91 37 02 	lds	r25, 0x0237
    4002:	82 17       	cp	r24, r18
    4004:	93 07       	cpc	r25, r19
    4006:	a0 f4       	brcc	.+40     	; 0x4030 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    4008:	80 91 36 02 	lds	r24, 0x0236
    400c:	90 91 37 02 	lds	r25, 0x0237
    4010:	88 5c       	subi	r24, 0xC8	; 200
    4012:	9d 4f       	sbci	r25, 0xFD	; 253
    4014:	9a 83       	std	Y+2, r25	; 0x02
    4016:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    4018:	20 91 36 02 	lds	r18, 0x0236
    401c:	30 91 37 02 	lds	r19, 0x0237
    4020:	8b 81       	ldd	r24, Y+3	; 0x03
    4022:	9c 81       	ldd	r25, Y+4	; 0x04
    4024:	82 0f       	add	r24, r18
    4026:	93 1f       	adc	r25, r19
    4028:	90 93 37 02 	sts	0x0237, r25
    402c:	80 93 36 02 	sts	0x0236, r24
		}	
	}
	xTaskResumeAll();
    4030:	0e 94 b7 2b 	call	0x576e	; 0x576e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    4034:	89 81       	ldd	r24, Y+1	; 0x01
    4036:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4038:	0f 90       	pop	r0
    403a:	0f 90       	pop	r0
    403c:	0f 90       	pop	r0
    403e:	0f 90       	pop	r0
    4040:	cf 91       	pop	r28
    4042:	df 91       	pop	r29
    4044:	08 95       	ret

00004046 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    4046:	df 93       	push	r29
    4048:	cf 93       	push	r28
    404a:	00 d0       	rcall	.+0      	; 0x404c <vPortFree+0x6>
    404c:	cd b7       	in	r28, 0x3d	; 61
    404e:	de b7       	in	r29, 0x3e	; 62
    4050:	9a 83       	std	Y+2, r25	; 0x02
    4052:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    4054:	0f 90       	pop	r0
    4056:	0f 90       	pop	r0
    4058:	cf 91       	pop	r28
    405a:	df 91       	pop	r29
    405c:	08 95       	ret

0000405e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    405e:	df 93       	push	r29
    4060:	cf 93       	push	r28
    4062:	cd b7       	in	r28, 0x3d	; 61
    4064:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    4066:	10 92 37 02 	sts	0x0237, r1
    406a:	10 92 36 02 	sts	0x0236, r1
}
    406e:	cf 91       	pop	r28
    4070:	df 91       	pop	r29
    4072:	08 95       	ret

00004074 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    4074:	df 93       	push	r29
    4076:	cf 93       	push	r28
    4078:	cd b7       	in	r28, 0x3d	; 61
    407a:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    407c:	20 91 36 02 	lds	r18, 0x0236
    4080:	30 91 37 02 	lds	r19, 0x0237
    4084:	84 e1       	ldi	r24, 0x14	; 20
    4086:	95 e0       	ldi	r25, 0x05	; 5
    4088:	82 1b       	sub	r24, r18
    408a:	93 0b       	sbc	r25, r19
}
    408c:	cf 91       	pop	r28
    408e:	df 91       	pop	r29
    4090:	08 95       	ret

00004092 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    4092:	df 93       	push	r29
    4094:	cf 93       	push	r28
    4096:	00 d0       	rcall	.+0      	; 0x4098 <vListInitialise+0x6>
    4098:	cd b7       	in	r28, 0x3d	; 61
    409a:	de b7       	in	r29, 0x3e	; 62
    409c:	9a 83       	std	Y+2, r25	; 0x02
    409e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    40a0:	89 81       	ldd	r24, Y+1	; 0x01
    40a2:	9a 81       	ldd	r25, Y+2	; 0x02
    40a4:	03 96       	adiw	r24, 0x03	; 3
    40a6:	e9 81       	ldd	r30, Y+1	; 0x01
    40a8:	fa 81       	ldd	r31, Y+2	; 0x02
    40aa:	92 83       	std	Z+2, r25	; 0x02
    40ac:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    40ae:	e9 81       	ldd	r30, Y+1	; 0x01
    40b0:	fa 81       	ldd	r31, Y+2	; 0x02
    40b2:	8f ef       	ldi	r24, 0xFF	; 255
    40b4:	9f ef       	ldi	r25, 0xFF	; 255
    40b6:	94 83       	std	Z+4, r25	; 0x04
    40b8:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    40ba:	89 81       	ldd	r24, Y+1	; 0x01
    40bc:	9a 81       	ldd	r25, Y+2	; 0x02
    40be:	03 96       	adiw	r24, 0x03	; 3
    40c0:	e9 81       	ldd	r30, Y+1	; 0x01
    40c2:	fa 81       	ldd	r31, Y+2	; 0x02
    40c4:	96 83       	std	Z+6, r25	; 0x06
    40c6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    40c8:	89 81       	ldd	r24, Y+1	; 0x01
    40ca:	9a 81       	ldd	r25, Y+2	; 0x02
    40cc:	03 96       	adiw	r24, 0x03	; 3
    40ce:	e9 81       	ldd	r30, Y+1	; 0x01
    40d0:	fa 81       	ldd	r31, Y+2	; 0x02
    40d2:	90 87       	std	Z+8, r25	; 0x08
    40d4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    40d6:	e9 81       	ldd	r30, Y+1	; 0x01
    40d8:	fa 81       	ldd	r31, Y+2	; 0x02
    40da:	10 82       	st	Z, r1
}
    40dc:	0f 90       	pop	r0
    40de:	0f 90       	pop	r0
    40e0:	cf 91       	pop	r28
    40e2:	df 91       	pop	r29
    40e4:	08 95       	ret

000040e6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    40e6:	df 93       	push	r29
    40e8:	cf 93       	push	r28
    40ea:	00 d0       	rcall	.+0      	; 0x40ec <vListInitialiseItem+0x6>
    40ec:	cd b7       	in	r28, 0x3d	; 61
    40ee:	de b7       	in	r29, 0x3e	; 62
    40f0:	9a 83       	std	Y+2, r25	; 0x02
    40f2:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    40f4:	e9 81       	ldd	r30, Y+1	; 0x01
    40f6:	fa 81       	ldd	r31, Y+2	; 0x02
    40f8:	11 86       	std	Z+9, r1	; 0x09
    40fa:	10 86       	std	Z+8, r1	; 0x08
}
    40fc:	0f 90       	pop	r0
    40fe:	0f 90       	pop	r0
    4100:	cf 91       	pop	r28
    4102:	df 91       	pop	r29
    4104:	08 95       	ret

00004106 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    4106:	df 93       	push	r29
    4108:	cf 93       	push	r28
    410a:	00 d0       	rcall	.+0      	; 0x410c <vListInsertEnd+0x6>
    410c:	00 d0       	rcall	.+0      	; 0x410e <vListInsertEnd+0x8>
    410e:	00 d0       	rcall	.+0      	; 0x4110 <vListInsertEnd+0xa>
    4110:	cd b7       	in	r28, 0x3d	; 61
    4112:	de b7       	in	r29, 0x3e	; 62
    4114:	9c 83       	std	Y+4, r25	; 0x04
    4116:	8b 83       	std	Y+3, r24	; 0x03
    4118:	7e 83       	std	Y+6, r23	; 0x06
    411a:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    411c:	eb 81       	ldd	r30, Y+3	; 0x03
    411e:	fc 81       	ldd	r31, Y+4	; 0x04
    4120:	81 81       	ldd	r24, Z+1	; 0x01
    4122:	92 81       	ldd	r25, Z+2	; 0x02
    4124:	9a 83       	std	Y+2, r25	; 0x02
    4126:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    4128:	e9 81       	ldd	r30, Y+1	; 0x01
    412a:	fa 81       	ldd	r31, Y+2	; 0x02
    412c:	82 81       	ldd	r24, Z+2	; 0x02
    412e:	93 81       	ldd	r25, Z+3	; 0x03
    4130:	ed 81       	ldd	r30, Y+5	; 0x05
    4132:	fe 81       	ldd	r31, Y+6	; 0x06
    4134:	93 83       	std	Z+3, r25	; 0x03
    4136:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    4138:	eb 81       	ldd	r30, Y+3	; 0x03
    413a:	fc 81       	ldd	r31, Y+4	; 0x04
    413c:	81 81       	ldd	r24, Z+1	; 0x01
    413e:	92 81       	ldd	r25, Z+2	; 0x02
    4140:	ed 81       	ldd	r30, Y+5	; 0x05
    4142:	fe 81       	ldd	r31, Y+6	; 0x06
    4144:	95 83       	std	Z+5, r25	; 0x05
    4146:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    4148:	e9 81       	ldd	r30, Y+1	; 0x01
    414a:	fa 81       	ldd	r31, Y+2	; 0x02
    414c:	02 80       	ldd	r0, Z+2	; 0x02
    414e:	f3 81       	ldd	r31, Z+3	; 0x03
    4150:	e0 2d       	mov	r30, r0
    4152:	8d 81       	ldd	r24, Y+5	; 0x05
    4154:	9e 81       	ldd	r25, Y+6	; 0x06
    4156:	95 83       	std	Z+5, r25	; 0x05
    4158:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    415a:	8d 81       	ldd	r24, Y+5	; 0x05
    415c:	9e 81       	ldd	r25, Y+6	; 0x06
    415e:	e9 81       	ldd	r30, Y+1	; 0x01
    4160:	fa 81       	ldd	r31, Y+2	; 0x02
    4162:	93 83       	std	Z+3, r25	; 0x03
    4164:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    4166:	8d 81       	ldd	r24, Y+5	; 0x05
    4168:	9e 81       	ldd	r25, Y+6	; 0x06
    416a:	eb 81       	ldd	r30, Y+3	; 0x03
    416c:	fc 81       	ldd	r31, Y+4	; 0x04
    416e:	92 83       	std	Z+2, r25	; 0x02
    4170:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    4172:	ed 81       	ldd	r30, Y+5	; 0x05
    4174:	fe 81       	ldd	r31, Y+6	; 0x06
    4176:	8b 81       	ldd	r24, Y+3	; 0x03
    4178:	9c 81       	ldd	r25, Y+4	; 0x04
    417a:	91 87       	std	Z+9, r25	; 0x09
    417c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    417e:	eb 81       	ldd	r30, Y+3	; 0x03
    4180:	fc 81       	ldd	r31, Y+4	; 0x04
    4182:	80 81       	ld	r24, Z
    4184:	8f 5f       	subi	r24, 0xFF	; 255
    4186:	eb 81       	ldd	r30, Y+3	; 0x03
    4188:	fc 81       	ldd	r31, Y+4	; 0x04
    418a:	80 83       	st	Z, r24
}
    418c:	26 96       	adiw	r28, 0x06	; 6
    418e:	0f b6       	in	r0, 0x3f	; 63
    4190:	f8 94       	cli
    4192:	de bf       	out	0x3e, r29	; 62
    4194:	0f be       	out	0x3f, r0	; 63
    4196:	cd bf       	out	0x3d, r28	; 61
    4198:	cf 91       	pop	r28
    419a:	df 91       	pop	r29
    419c:	08 95       	ret

0000419e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    419e:	df 93       	push	r29
    41a0:	cf 93       	push	r28
    41a2:	cd b7       	in	r28, 0x3d	; 61
    41a4:	de b7       	in	r29, 0x3e	; 62
    41a6:	28 97       	sbiw	r28, 0x08	; 8
    41a8:	0f b6       	in	r0, 0x3f	; 63
    41aa:	f8 94       	cli
    41ac:	de bf       	out	0x3e, r29	; 62
    41ae:	0f be       	out	0x3f, r0	; 63
    41b0:	cd bf       	out	0x3d, r28	; 61
    41b2:	9e 83       	std	Y+6, r25	; 0x06
    41b4:	8d 83       	std	Y+5, r24	; 0x05
    41b6:	78 87       	std	Y+8, r23	; 0x08
    41b8:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    41ba:	ef 81       	ldd	r30, Y+7	; 0x07
    41bc:	f8 85       	ldd	r31, Y+8	; 0x08
    41be:	80 81       	ld	r24, Z
    41c0:	91 81       	ldd	r25, Z+1	; 0x01
    41c2:	9a 83       	std	Y+2, r25	; 0x02
    41c4:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    41c6:	89 81       	ldd	r24, Y+1	; 0x01
    41c8:	9a 81       	ldd	r25, Y+2	; 0x02
    41ca:	2f ef       	ldi	r18, 0xFF	; 255
    41cc:	8f 3f       	cpi	r24, 0xFF	; 255
    41ce:	92 07       	cpc	r25, r18
    41d0:	39 f4       	brne	.+14     	; 0x41e0 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    41d2:	ed 81       	ldd	r30, Y+5	; 0x05
    41d4:	fe 81       	ldd	r31, Y+6	; 0x06
    41d6:	87 81       	ldd	r24, Z+7	; 0x07
    41d8:	90 85       	ldd	r25, Z+8	; 0x08
    41da:	9c 83       	std	Y+4, r25	; 0x04
    41dc:	8b 83       	std	Y+3, r24	; 0x03
    41de:	18 c0       	rjmp	.+48     	; 0x4210 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    41e0:	8d 81       	ldd	r24, Y+5	; 0x05
    41e2:	9e 81       	ldd	r25, Y+6	; 0x06
    41e4:	03 96       	adiw	r24, 0x03	; 3
    41e6:	9c 83       	std	Y+4, r25	; 0x04
    41e8:	8b 83       	std	Y+3, r24	; 0x03
    41ea:	06 c0       	rjmp	.+12     	; 0x41f8 <vListInsert+0x5a>
    41ec:	eb 81       	ldd	r30, Y+3	; 0x03
    41ee:	fc 81       	ldd	r31, Y+4	; 0x04
    41f0:	82 81       	ldd	r24, Z+2	; 0x02
    41f2:	93 81       	ldd	r25, Z+3	; 0x03
    41f4:	9c 83       	std	Y+4, r25	; 0x04
    41f6:	8b 83       	std	Y+3, r24	; 0x03
    41f8:	eb 81       	ldd	r30, Y+3	; 0x03
    41fa:	fc 81       	ldd	r31, Y+4	; 0x04
    41fc:	02 80       	ldd	r0, Z+2	; 0x02
    41fe:	f3 81       	ldd	r31, Z+3	; 0x03
    4200:	e0 2d       	mov	r30, r0
    4202:	20 81       	ld	r18, Z
    4204:	31 81       	ldd	r19, Z+1	; 0x01
    4206:	89 81       	ldd	r24, Y+1	; 0x01
    4208:	9a 81       	ldd	r25, Y+2	; 0x02
    420a:	82 17       	cp	r24, r18
    420c:	93 07       	cpc	r25, r19
    420e:	70 f7       	brcc	.-36     	; 0x41ec <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    4210:	eb 81       	ldd	r30, Y+3	; 0x03
    4212:	fc 81       	ldd	r31, Y+4	; 0x04
    4214:	82 81       	ldd	r24, Z+2	; 0x02
    4216:	93 81       	ldd	r25, Z+3	; 0x03
    4218:	ef 81       	ldd	r30, Y+7	; 0x07
    421a:	f8 85       	ldd	r31, Y+8	; 0x08
    421c:	93 83       	std	Z+3, r25	; 0x03
    421e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    4220:	ef 81       	ldd	r30, Y+7	; 0x07
    4222:	f8 85       	ldd	r31, Y+8	; 0x08
    4224:	02 80       	ldd	r0, Z+2	; 0x02
    4226:	f3 81       	ldd	r31, Z+3	; 0x03
    4228:	e0 2d       	mov	r30, r0
    422a:	8f 81       	ldd	r24, Y+7	; 0x07
    422c:	98 85       	ldd	r25, Y+8	; 0x08
    422e:	95 83       	std	Z+5, r25	; 0x05
    4230:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    4232:	ef 81       	ldd	r30, Y+7	; 0x07
    4234:	f8 85       	ldd	r31, Y+8	; 0x08
    4236:	8b 81       	ldd	r24, Y+3	; 0x03
    4238:	9c 81       	ldd	r25, Y+4	; 0x04
    423a:	95 83       	std	Z+5, r25	; 0x05
    423c:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    423e:	8f 81       	ldd	r24, Y+7	; 0x07
    4240:	98 85       	ldd	r25, Y+8	; 0x08
    4242:	eb 81       	ldd	r30, Y+3	; 0x03
    4244:	fc 81       	ldd	r31, Y+4	; 0x04
    4246:	93 83       	std	Z+3, r25	; 0x03
    4248:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    424a:	ef 81       	ldd	r30, Y+7	; 0x07
    424c:	f8 85       	ldd	r31, Y+8	; 0x08
    424e:	8d 81       	ldd	r24, Y+5	; 0x05
    4250:	9e 81       	ldd	r25, Y+6	; 0x06
    4252:	91 87       	std	Z+9, r25	; 0x09
    4254:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    4256:	ed 81       	ldd	r30, Y+5	; 0x05
    4258:	fe 81       	ldd	r31, Y+6	; 0x06
    425a:	80 81       	ld	r24, Z
    425c:	8f 5f       	subi	r24, 0xFF	; 255
    425e:	ed 81       	ldd	r30, Y+5	; 0x05
    4260:	fe 81       	ldd	r31, Y+6	; 0x06
    4262:	80 83       	st	Z, r24
}
    4264:	28 96       	adiw	r28, 0x08	; 8
    4266:	0f b6       	in	r0, 0x3f	; 63
    4268:	f8 94       	cli
    426a:	de bf       	out	0x3e, r29	; 62
    426c:	0f be       	out	0x3f, r0	; 63
    426e:	cd bf       	out	0x3d, r28	; 61
    4270:	cf 91       	pop	r28
    4272:	df 91       	pop	r29
    4274:	08 95       	ret

00004276 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    4276:	df 93       	push	r29
    4278:	cf 93       	push	r28
    427a:	00 d0       	rcall	.+0      	; 0x427c <vListRemove+0x6>
    427c:	00 d0       	rcall	.+0      	; 0x427e <vListRemove+0x8>
    427e:	cd b7       	in	r28, 0x3d	; 61
    4280:	de b7       	in	r29, 0x3e	; 62
    4282:	9c 83       	std	Y+4, r25	; 0x04
    4284:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    4286:	eb 81       	ldd	r30, Y+3	; 0x03
    4288:	fc 81       	ldd	r31, Y+4	; 0x04
    428a:	a2 81       	ldd	r26, Z+2	; 0x02
    428c:	b3 81       	ldd	r27, Z+3	; 0x03
    428e:	eb 81       	ldd	r30, Y+3	; 0x03
    4290:	fc 81       	ldd	r31, Y+4	; 0x04
    4292:	84 81       	ldd	r24, Z+4	; 0x04
    4294:	95 81       	ldd	r25, Z+5	; 0x05
    4296:	15 96       	adiw	r26, 0x05	; 5
    4298:	9c 93       	st	X, r25
    429a:	8e 93       	st	-X, r24
    429c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    429e:	eb 81       	ldd	r30, Y+3	; 0x03
    42a0:	fc 81       	ldd	r31, Y+4	; 0x04
    42a2:	a4 81       	ldd	r26, Z+4	; 0x04
    42a4:	b5 81       	ldd	r27, Z+5	; 0x05
    42a6:	eb 81       	ldd	r30, Y+3	; 0x03
    42a8:	fc 81       	ldd	r31, Y+4	; 0x04
    42aa:	82 81       	ldd	r24, Z+2	; 0x02
    42ac:	93 81       	ldd	r25, Z+3	; 0x03
    42ae:	13 96       	adiw	r26, 0x03	; 3
    42b0:	9c 93       	st	X, r25
    42b2:	8e 93       	st	-X, r24
    42b4:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    42b6:	eb 81       	ldd	r30, Y+3	; 0x03
    42b8:	fc 81       	ldd	r31, Y+4	; 0x04
    42ba:	80 85       	ldd	r24, Z+8	; 0x08
    42bc:	91 85       	ldd	r25, Z+9	; 0x09
    42be:	9a 83       	std	Y+2, r25	; 0x02
    42c0:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    42c2:	e9 81       	ldd	r30, Y+1	; 0x01
    42c4:	fa 81       	ldd	r31, Y+2	; 0x02
    42c6:	21 81       	ldd	r18, Z+1	; 0x01
    42c8:	32 81       	ldd	r19, Z+2	; 0x02
    42ca:	8b 81       	ldd	r24, Y+3	; 0x03
    42cc:	9c 81       	ldd	r25, Y+4	; 0x04
    42ce:	28 17       	cp	r18, r24
    42d0:	39 07       	cpc	r19, r25
    42d2:	41 f4       	brne	.+16     	; 0x42e4 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    42d4:	eb 81       	ldd	r30, Y+3	; 0x03
    42d6:	fc 81       	ldd	r31, Y+4	; 0x04
    42d8:	84 81       	ldd	r24, Z+4	; 0x04
    42da:	95 81       	ldd	r25, Z+5	; 0x05
    42dc:	e9 81       	ldd	r30, Y+1	; 0x01
    42de:	fa 81       	ldd	r31, Y+2	; 0x02
    42e0:	92 83       	std	Z+2, r25	; 0x02
    42e2:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    42e4:	eb 81       	ldd	r30, Y+3	; 0x03
    42e6:	fc 81       	ldd	r31, Y+4	; 0x04
    42e8:	11 86       	std	Z+9, r1	; 0x09
    42ea:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    42ec:	e9 81       	ldd	r30, Y+1	; 0x01
    42ee:	fa 81       	ldd	r31, Y+2	; 0x02
    42f0:	80 81       	ld	r24, Z
    42f2:	81 50       	subi	r24, 0x01	; 1
    42f4:	e9 81       	ldd	r30, Y+1	; 0x01
    42f6:	fa 81       	ldd	r31, Y+2	; 0x02
    42f8:	80 83       	st	Z, r24
}
    42fa:	0f 90       	pop	r0
    42fc:	0f 90       	pop	r0
    42fe:	0f 90       	pop	r0
    4300:	0f 90       	pop	r0
    4302:	cf 91       	pop	r28
    4304:	df 91       	pop	r29
    4306:	08 95       	ret

00004308 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    4308:	df 93       	push	r29
    430a:	cf 93       	push	r28
    430c:	cd b7       	in	r28, 0x3d	; 61
    430e:	de b7       	in	r29, 0x3e	; 62
    4310:	28 97       	sbiw	r28, 0x08	; 8
    4312:	0f b6       	in	r0, 0x3f	; 63
    4314:	f8 94       	cli
    4316:	de bf       	out	0x3e, r29	; 62
    4318:	0f be       	out	0x3f, r0	; 63
    431a:	cd bf       	out	0x3d, r28	; 61
    431c:	9c 83       	std	Y+4, r25	; 0x04
    431e:	8b 83       	std	Y+3, r24	; 0x03
    4320:	7e 83       	std	Y+6, r23	; 0x06
    4322:	6d 83       	std	Y+5, r22	; 0x05
    4324:	58 87       	std	Y+8, r21	; 0x08
    4326:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    4328:	eb 81       	ldd	r30, Y+3	; 0x03
    432a:	fc 81       	ldd	r31, Y+4	; 0x04
    432c:	81 e1       	ldi	r24, 0x11	; 17
    432e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4330:	8b 81       	ldd	r24, Y+3	; 0x03
    4332:	9c 81       	ldd	r25, Y+4	; 0x04
    4334:	01 97       	sbiw	r24, 0x01	; 1
    4336:	9c 83       	std	Y+4, r25	; 0x04
    4338:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    433a:	eb 81       	ldd	r30, Y+3	; 0x03
    433c:	fc 81       	ldd	r31, Y+4	; 0x04
    433e:	82 e2       	ldi	r24, 0x22	; 34
    4340:	80 83       	st	Z, r24
	pxTopOfStack--;
    4342:	8b 81       	ldd	r24, Y+3	; 0x03
    4344:	9c 81       	ldd	r25, Y+4	; 0x04
    4346:	01 97       	sbiw	r24, 0x01	; 1
    4348:	9c 83       	std	Y+4, r25	; 0x04
    434a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    434c:	eb 81       	ldd	r30, Y+3	; 0x03
    434e:	fc 81       	ldd	r31, Y+4	; 0x04
    4350:	83 e3       	ldi	r24, 0x33	; 51
    4352:	80 83       	st	Z, r24
	pxTopOfStack--;
    4354:	8b 81       	ldd	r24, Y+3	; 0x03
    4356:	9c 81       	ldd	r25, Y+4	; 0x04
    4358:	01 97       	sbiw	r24, 0x01	; 1
    435a:	9c 83       	std	Y+4, r25	; 0x04
    435c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    435e:	8d 81       	ldd	r24, Y+5	; 0x05
    4360:	9e 81       	ldd	r25, Y+6	; 0x06
    4362:	9a 83       	std	Y+2, r25	; 0x02
    4364:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    4366:	89 81       	ldd	r24, Y+1	; 0x01
    4368:	eb 81       	ldd	r30, Y+3	; 0x03
    436a:	fc 81       	ldd	r31, Y+4	; 0x04
    436c:	80 83       	st	Z, r24
	pxTopOfStack--;
    436e:	8b 81       	ldd	r24, Y+3	; 0x03
    4370:	9c 81       	ldd	r25, Y+4	; 0x04
    4372:	01 97       	sbiw	r24, 0x01	; 1
    4374:	9c 83       	std	Y+4, r25	; 0x04
    4376:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    4378:	89 81       	ldd	r24, Y+1	; 0x01
    437a:	9a 81       	ldd	r25, Y+2	; 0x02
    437c:	89 2f       	mov	r24, r25
    437e:	99 27       	eor	r25, r25
    4380:	9a 83       	std	Y+2, r25	; 0x02
    4382:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    4384:	89 81       	ldd	r24, Y+1	; 0x01
    4386:	eb 81       	ldd	r30, Y+3	; 0x03
    4388:	fc 81       	ldd	r31, Y+4	; 0x04
    438a:	80 83       	st	Z, r24
	pxTopOfStack--;
    438c:	8b 81       	ldd	r24, Y+3	; 0x03
    438e:	9c 81       	ldd	r25, Y+4	; 0x04
    4390:	01 97       	sbiw	r24, 0x01	; 1
    4392:	9c 83       	std	Y+4, r25	; 0x04
    4394:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    4396:	eb 81       	ldd	r30, Y+3	; 0x03
    4398:	fc 81       	ldd	r31, Y+4	; 0x04
    439a:	10 82       	st	Z, r1
	pxTopOfStack--;
    439c:	8b 81       	ldd	r24, Y+3	; 0x03
    439e:	9c 81       	ldd	r25, Y+4	; 0x04
    43a0:	01 97       	sbiw	r24, 0x01	; 1
    43a2:	9c 83       	std	Y+4, r25	; 0x04
    43a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    43a6:	eb 81       	ldd	r30, Y+3	; 0x03
    43a8:	fc 81       	ldd	r31, Y+4	; 0x04
    43aa:	80 e8       	ldi	r24, 0x80	; 128
    43ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    43ae:	8b 81       	ldd	r24, Y+3	; 0x03
    43b0:	9c 81       	ldd	r25, Y+4	; 0x04
    43b2:	01 97       	sbiw	r24, 0x01	; 1
    43b4:	9c 83       	std	Y+4, r25	; 0x04
    43b6:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    43b8:	eb 81       	ldd	r30, Y+3	; 0x03
    43ba:	fc 81       	ldd	r31, Y+4	; 0x04
    43bc:	10 82       	st	Z, r1
	pxTopOfStack--;
    43be:	8b 81       	ldd	r24, Y+3	; 0x03
    43c0:	9c 81       	ldd	r25, Y+4	; 0x04
    43c2:	01 97       	sbiw	r24, 0x01	; 1
    43c4:	9c 83       	std	Y+4, r25	; 0x04
    43c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    43c8:	eb 81       	ldd	r30, Y+3	; 0x03
    43ca:	fc 81       	ldd	r31, Y+4	; 0x04
    43cc:	82 e0       	ldi	r24, 0x02	; 2
    43ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    43d0:	8b 81       	ldd	r24, Y+3	; 0x03
    43d2:	9c 81       	ldd	r25, Y+4	; 0x04
    43d4:	01 97       	sbiw	r24, 0x01	; 1
    43d6:	9c 83       	std	Y+4, r25	; 0x04
    43d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    43da:	eb 81       	ldd	r30, Y+3	; 0x03
    43dc:	fc 81       	ldd	r31, Y+4	; 0x04
    43de:	83 e0       	ldi	r24, 0x03	; 3
    43e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    43e2:	8b 81       	ldd	r24, Y+3	; 0x03
    43e4:	9c 81       	ldd	r25, Y+4	; 0x04
    43e6:	01 97       	sbiw	r24, 0x01	; 1
    43e8:	9c 83       	std	Y+4, r25	; 0x04
    43ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    43ec:	eb 81       	ldd	r30, Y+3	; 0x03
    43ee:	fc 81       	ldd	r31, Y+4	; 0x04
    43f0:	84 e0       	ldi	r24, 0x04	; 4
    43f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    43f4:	8b 81       	ldd	r24, Y+3	; 0x03
    43f6:	9c 81       	ldd	r25, Y+4	; 0x04
    43f8:	01 97       	sbiw	r24, 0x01	; 1
    43fa:	9c 83       	std	Y+4, r25	; 0x04
    43fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    43fe:	eb 81       	ldd	r30, Y+3	; 0x03
    4400:	fc 81       	ldd	r31, Y+4	; 0x04
    4402:	85 e0       	ldi	r24, 0x05	; 5
    4404:	80 83       	st	Z, r24
	pxTopOfStack--;
    4406:	8b 81       	ldd	r24, Y+3	; 0x03
    4408:	9c 81       	ldd	r25, Y+4	; 0x04
    440a:	01 97       	sbiw	r24, 0x01	; 1
    440c:	9c 83       	std	Y+4, r25	; 0x04
    440e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    4410:	eb 81       	ldd	r30, Y+3	; 0x03
    4412:	fc 81       	ldd	r31, Y+4	; 0x04
    4414:	86 e0       	ldi	r24, 0x06	; 6
    4416:	80 83       	st	Z, r24
	pxTopOfStack--;
    4418:	8b 81       	ldd	r24, Y+3	; 0x03
    441a:	9c 81       	ldd	r25, Y+4	; 0x04
    441c:	01 97       	sbiw	r24, 0x01	; 1
    441e:	9c 83       	std	Y+4, r25	; 0x04
    4420:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    4422:	eb 81       	ldd	r30, Y+3	; 0x03
    4424:	fc 81       	ldd	r31, Y+4	; 0x04
    4426:	87 e0       	ldi	r24, 0x07	; 7
    4428:	80 83       	st	Z, r24
	pxTopOfStack--;
    442a:	8b 81       	ldd	r24, Y+3	; 0x03
    442c:	9c 81       	ldd	r25, Y+4	; 0x04
    442e:	01 97       	sbiw	r24, 0x01	; 1
    4430:	9c 83       	std	Y+4, r25	; 0x04
    4432:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    4434:	eb 81       	ldd	r30, Y+3	; 0x03
    4436:	fc 81       	ldd	r31, Y+4	; 0x04
    4438:	88 e0       	ldi	r24, 0x08	; 8
    443a:	80 83       	st	Z, r24
	pxTopOfStack--;
    443c:	8b 81       	ldd	r24, Y+3	; 0x03
    443e:	9c 81       	ldd	r25, Y+4	; 0x04
    4440:	01 97       	sbiw	r24, 0x01	; 1
    4442:	9c 83       	std	Y+4, r25	; 0x04
    4444:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    4446:	eb 81       	ldd	r30, Y+3	; 0x03
    4448:	fc 81       	ldd	r31, Y+4	; 0x04
    444a:	89 e0       	ldi	r24, 0x09	; 9
    444c:	80 83       	st	Z, r24
	pxTopOfStack--;
    444e:	8b 81       	ldd	r24, Y+3	; 0x03
    4450:	9c 81       	ldd	r25, Y+4	; 0x04
    4452:	01 97       	sbiw	r24, 0x01	; 1
    4454:	9c 83       	std	Y+4, r25	; 0x04
    4456:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    4458:	eb 81       	ldd	r30, Y+3	; 0x03
    445a:	fc 81       	ldd	r31, Y+4	; 0x04
    445c:	80 e1       	ldi	r24, 0x10	; 16
    445e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4460:	8b 81       	ldd	r24, Y+3	; 0x03
    4462:	9c 81       	ldd	r25, Y+4	; 0x04
    4464:	01 97       	sbiw	r24, 0x01	; 1
    4466:	9c 83       	std	Y+4, r25	; 0x04
    4468:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    446a:	eb 81       	ldd	r30, Y+3	; 0x03
    446c:	fc 81       	ldd	r31, Y+4	; 0x04
    446e:	81 e1       	ldi	r24, 0x11	; 17
    4470:	80 83       	st	Z, r24
	pxTopOfStack--;
    4472:	8b 81       	ldd	r24, Y+3	; 0x03
    4474:	9c 81       	ldd	r25, Y+4	; 0x04
    4476:	01 97       	sbiw	r24, 0x01	; 1
    4478:	9c 83       	std	Y+4, r25	; 0x04
    447a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    447c:	eb 81       	ldd	r30, Y+3	; 0x03
    447e:	fc 81       	ldd	r31, Y+4	; 0x04
    4480:	82 e1       	ldi	r24, 0x12	; 18
    4482:	80 83       	st	Z, r24
	pxTopOfStack--;
    4484:	8b 81       	ldd	r24, Y+3	; 0x03
    4486:	9c 81       	ldd	r25, Y+4	; 0x04
    4488:	01 97       	sbiw	r24, 0x01	; 1
    448a:	9c 83       	std	Y+4, r25	; 0x04
    448c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    448e:	eb 81       	ldd	r30, Y+3	; 0x03
    4490:	fc 81       	ldd	r31, Y+4	; 0x04
    4492:	83 e1       	ldi	r24, 0x13	; 19
    4494:	80 83       	st	Z, r24
	pxTopOfStack--;
    4496:	8b 81       	ldd	r24, Y+3	; 0x03
    4498:	9c 81       	ldd	r25, Y+4	; 0x04
    449a:	01 97       	sbiw	r24, 0x01	; 1
    449c:	9c 83       	std	Y+4, r25	; 0x04
    449e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    44a0:	eb 81       	ldd	r30, Y+3	; 0x03
    44a2:	fc 81       	ldd	r31, Y+4	; 0x04
    44a4:	84 e1       	ldi	r24, 0x14	; 20
    44a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    44a8:	8b 81       	ldd	r24, Y+3	; 0x03
    44aa:	9c 81       	ldd	r25, Y+4	; 0x04
    44ac:	01 97       	sbiw	r24, 0x01	; 1
    44ae:	9c 83       	std	Y+4, r25	; 0x04
    44b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    44b2:	eb 81       	ldd	r30, Y+3	; 0x03
    44b4:	fc 81       	ldd	r31, Y+4	; 0x04
    44b6:	85 e1       	ldi	r24, 0x15	; 21
    44b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    44ba:	8b 81       	ldd	r24, Y+3	; 0x03
    44bc:	9c 81       	ldd	r25, Y+4	; 0x04
    44be:	01 97       	sbiw	r24, 0x01	; 1
    44c0:	9c 83       	std	Y+4, r25	; 0x04
    44c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    44c4:	eb 81       	ldd	r30, Y+3	; 0x03
    44c6:	fc 81       	ldd	r31, Y+4	; 0x04
    44c8:	86 e1       	ldi	r24, 0x16	; 22
    44ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    44cc:	8b 81       	ldd	r24, Y+3	; 0x03
    44ce:	9c 81       	ldd	r25, Y+4	; 0x04
    44d0:	01 97       	sbiw	r24, 0x01	; 1
    44d2:	9c 83       	std	Y+4, r25	; 0x04
    44d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    44d6:	eb 81       	ldd	r30, Y+3	; 0x03
    44d8:	fc 81       	ldd	r31, Y+4	; 0x04
    44da:	87 e1       	ldi	r24, 0x17	; 23
    44dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    44de:	8b 81       	ldd	r24, Y+3	; 0x03
    44e0:	9c 81       	ldd	r25, Y+4	; 0x04
    44e2:	01 97       	sbiw	r24, 0x01	; 1
    44e4:	9c 83       	std	Y+4, r25	; 0x04
    44e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    44e8:	eb 81       	ldd	r30, Y+3	; 0x03
    44ea:	fc 81       	ldd	r31, Y+4	; 0x04
    44ec:	88 e1       	ldi	r24, 0x18	; 24
    44ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    44f0:	8b 81       	ldd	r24, Y+3	; 0x03
    44f2:	9c 81       	ldd	r25, Y+4	; 0x04
    44f4:	01 97       	sbiw	r24, 0x01	; 1
    44f6:	9c 83       	std	Y+4, r25	; 0x04
    44f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    44fa:	eb 81       	ldd	r30, Y+3	; 0x03
    44fc:	fc 81       	ldd	r31, Y+4	; 0x04
    44fe:	89 e1       	ldi	r24, 0x19	; 25
    4500:	80 83       	st	Z, r24
	pxTopOfStack--;
    4502:	8b 81       	ldd	r24, Y+3	; 0x03
    4504:	9c 81       	ldd	r25, Y+4	; 0x04
    4506:	01 97       	sbiw	r24, 0x01	; 1
    4508:	9c 83       	std	Y+4, r25	; 0x04
    450a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    450c:	eb 81       	ldd	r30, Y+3	; 0x03
    450e:	fc 81       	ldd	r31, Y+4	; 0x04
    4510:	80 e2       	ldi	r24, 0x20	; 32
    4512:	80 83       	st	Z, r24
	pxTopOfStack--;
    4514:	8b 81       	ldd	r24, Y+3	; 0x03
    4516:	9c 81       	ldd	r25, Y+4	; 0x04
    4518:	01 97       	sbiw	r24, 0x01	; 1
    451a:	9c 83       	std	Y+4, r25	; 0x04
    451c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    451e:	eb 81       	ldd	r30, Y+3	; 0x03
    4520:	fc 81       	ldd	r31, Y+4	; 0x04
    4522:	81 e2       	ldi	r24, 0x21	; 33
    4524:	80 83       	st	Z, r24
	pxTopOfStack--;
    4526:	8b 81       	ldd	r24, Y+3	; 0x03
    4528:	9c 81       	ldd	r25, Y+4	; 0x04
    452a:	01 97       	sbiw	r24, 0x01	; 1
    452c:	9c 83       	std	Y+4, r25	; 0x04
    452e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    4530:	eb 81       	ldd	r30, Y+3	; 0x03
    4532:	fc 81       	ldd	r31, Y+4	; 0x04
    4534:	82 e2       	ldi	r24, 0x22	; 34
    4536:	80 83       	st	Z, r24
	pxTopOfStack--;
    4538:	8b 81       	ldd	r24, Y+3	; 0x03
    453a:	9c 81       	ldd	r25, Y+4	; 0x04
    453c:	01 97       	sbiw	r24, 0x01	; 1
    453e:	9c 83       	std	Y+4, r25	; 0x04
    4540:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    4542:	eb 81       	ldd	r30, Y+3	; 0x03
    4544:	fc 81       	ldd	r31, Y+4	; 0x04
    4546:	83 e2       	ldi	r24, 0x23	; 35
    4548:	80 83       	st	Z, r24
	pxTopOfStack--;
    454a:	8b 81       	ldd	r24, Y+3	; 0x03
    454c:	9c 81       	ldd	r25, Y+4	; 0x04
    454e:	01 97       	sbiw	r24, 0x01	; 1
    4550:	9c 83       	std	Y+4, r25	; 0x04
    4552:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    4554:	8f 81       	ldd	r24, Y+7	; 0x07
    4556:	98 85       	ldd	r25, Y+8	; 0x08
    4558:	9a 83       	std	Y+2, r25	; 0x02
    455a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    455c:	89 81       	ldd	r24, Y+1	; 0x01
    455e:	eb 81       	ldd	r30, Y+3	; 0x03
    4560:	fc 81       	ldd	r31, Y+4	; 0x04
    4562:	80 83       	st	Z, r24
	pxTopOfStack--;
    4564:	8b 81       	ldd	r24, Y+3	; 0x03
    4566:	9c 81       	ldd	r25, Y+4	; 0x04
    4568:	01 97       	sbiw	r24, 0x01	; 1
    456a:	9c 83       	std	Y+4, r25	; 0x04
    456c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    456e:	89 81       	ldd	r24, Y+1	; 0x01
    4570:	9a 81       	ldd	r25, Y+2	; 0x02
    4572:	89 2f       	mov	r24, r25
    4574:	99 27       	eor	r25, r25
    4576:	9a 83       	std	Y+2, r25	; 0x02
    4578:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    457a:	89 81       	ldd	r24, Y+1	; 0x01
    457c:	eb 81       	ldd	r30, Y+3	; 0x03
    457e:	fc 81       	ldd	r31, Y+4	; 0x04
    4580:	80 83       	st	Z, r24
	pxTopOfStack--;
    4582:	8b 81       	ldd	r24, Y+3	; 0x03
    4584:	9c 81       	ldd	r25, Y+4	; 0x04
    4586:	01 97       	sbiw	r24, 0x01	; 1
    4588:	9c 83       	std	Y+4, r25	; 0x04
    458a:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    458c:	eb 81       	ldd	r30, Y+3	; 0x03
    458e:	fc 81       	ldd	r31, Y+4	; 0x04
    4590:	86 e2       	ldi	r24, 0x26	; 38
    4592:	80 83       	st	Z, r24
	pxTopOfStack--;
    4594:	8b 81       	ldd	r24, Y+3	; 0x03
    4596:	9c 81       	ldd	r25, Y+4	; 0x04
    4598:	01 97       	sbiw	r24, 0x01	; 1
    459a:	9c 83       	std	Y+4, r25	; 0x04
    459c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    459e:	eb 81       	ldd	r30, Y+3	; 0x03
    45a0:	fc 81       	ldd	r31, Y+4	; 0x04
    45a2:	87 e2       	ldi	r24, 0x27	; 39
    45a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    45a6:	8b 81       	ldd	r24, Y+3	; 0x03
    45a8:	9c 81       	ldd	r25, Y+4	; 0x04
    45aa:	01 97       	sbiw	r24, 0x01	; 1
    45ac:	9c 83       	std	Y+4, r25	; 0x04
    45ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    45b0:	eb 81       	ldd	r30, Y+3	; 0x03
    45b2:	fc 81       	ldd	r31, Y+4	; 0x04
    45b4:	88 e2       	ldi	r24, 0x28	; 40
    45b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    45b8:	8b 81       	ldd	r24, Y+3	; 0x03
    45ba:	9c 81       	ldd	r25, Y+4	; 0x04
    45bc:	01 97       	sbiw	r24, 0x01	; 1
    45be:	9c 83       	std	Y+4, r25	; 0x04
    45c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    45c2:	eb 81       	ldd	r30, Y+3	; 0x03
    45c4:	fc 81       	ldd	r31, Y+4	; 0x04
    45c6:	89 e2       	ldi	r24, 0x29	; 41
    45c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    45ca:	8b 81       	ldd	r24, Y+3	; 0x03
    45cc:	9c 81       	ldd	r25, Y+4	; 0x04
    45ce:	01 97       	sbiw	r24, 0x01	; 1
    45d0:	9c 83       	std	Y+4, r25	; 0x04
    45d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    45d4:	eb 81       	ldd	r30, Y+3	; 0x03
    45d6:	fc 81       	ldd	r31, Y+4	; 0x04
    45d8:	80 e3       	ldi	r24, 0x30	; 48
    45da:	80 83       	st	Z, r24
	pxTopOfStack--;
    45dc:	8b 81       	ldd	r24, Y+3	; 0x03
    45de:	9c 81       	ldd	r25, Y+4	; 0x04
    45e0:	01 97       	sbiw	r24, 0x01	; 1
    45e2:	9c 83       	std	Y+4, r25	; 0x04
    45e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    45e6:	eb 81       	ldd	r30, Y+3	; 0x03
    45e8:	fc 81       	ldd	r31, Y+4	; 0x04
    45ea:	81 e3       	ldi	r24, 0x31	; 49
    45ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    45ee:	8b 81       	ldd	r24, Y+3	; 0x03
    45f0:	9c 81       	ldd	r25, Y+4	; 0x04
    45f2:	01 97       	sbiw	r24, 0x01	; 1
    45f4:	9c 83       	std	Y+4, r25	; 0x04
    45f6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    45f8:	8b 81       	ldd	r24, Y+3	; 0x03
    45fa:	9c 81       	ldd	r25, Y+4	; 0x04
}
    45fc:	28 96       	adiw	r28, 0x08	; 8
    45fe:	0f b6       	in	r0, 0x3f	; 63
    4600:	f8 94       	cli
    4602:	de bf       	out	0x3e, r29	; 62
    4604:	0f be       	out	0x3f, r0	; 63
    4606:	cd bf       	out	0x3d, r28	; 61
    4608:	cf 91       	pop	r28
    460a:	df 91       	pop	r29
    460c:	08 95       	ret

0000460e <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    460e:	df 93       	push	r29
    4610:	cf 93       	push	r28
    4612:	cd b7       	in	r28, 0x3d	; 61
    4614:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    4616:	0e 94 f7 23 	call	0x47ee	; 0x47ee <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    461a:	a0 91 4c 07 	lds	r26, 0x074C
    461e:	b0 91 4d 07 	lds	r27, 0x074D
    4622:	cd 91       	ld	r28, X+
    4624:	cd bf       	out	0x3d, r28	; 61
    4626:	dd 91       	ld	r29, X+
    4628:	de bf       	out	0x3e, r29	; 62
    462a:	ff 91       	pop	r31
    462c:	ef 91       	pop	r30
    462e:	df 91       	pop	r29
    4630:	cf 91       	pop	r28
    4632:	bf 91       	pop	r27
    4634:	af 91       	pop	r26
    4636:	9f 91       	pop	r25
    4638:	8f 91       	pop	r24
    463a:	7f 91       	pop	r23
    463c:	6f 91       	pop	r22
    463e:	5f 91       	pop	r21
    4640:	4f 91       	pop	r20
    4642:	3f 91       	pop	r19
    4644:	2f 91       	pop	r18
    4646:	1f 91       	pop	r17
    4648:	0f 91       	pop	r16
    464a:	ff 90       	pop	r15
    464c:	ef 90       	pop	r14
    464e:	df 90       	pop	r13
    4650:	cf 90       	pop	r12
    4652:	bf 90       	pop	r11
    4654:	af 90       	pop	r10
    4656:	9f 90       	pop	r9
    4658:	8f 90       	pop	r8
    465a:	7f 90       	pop	r7
    465c:	6f 90       	pop	r6
    465e:	5f 90       	pop	r5
    4660:	4f 90       	pop	r4
    4662:	3f 90       	pop	r3
    4664:	2f 90       	pop	r2
    4666:	1f 90       	pop	r1
    4668:	0f 90       	pop	r0
    466a:	0f be       	out	0x3f, r0	; 63
    466c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    466e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    4670:	81 e0       	ldi	r24, 0x01	; 1
}
    4672:	cf 91       	pop	r28
    4674:	df 91       	pop	r29
    4676:	08 95       	ret

00004678 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    4678:	df 93       	push	r29
    467a:	cf 93       	push	r28
    467c:	cd b7       	in	r28, 0x3d	; 61
    467e:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    4680:	cf 91       	pop	r28
    4682:	df 91       	pop	r29
    4684:	08 95       	ret

00004686 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    4686:	0f 92       	push	r0
    4688:	0f b6       	in	r0, 0x3f	; 63
    468a:	f8 94       	cli
    468c:	0f 92       	push	r0
    468e:	1f 92       	push	r1
    4690:	11 24       	eor	r1, r1
    4692:	2f 92       	push	r2
    4694:	3f 92       	push	r3
    4696:	4f 92       	push	r4
    4698:	5f 92       	push	r5
    469a:	6f 92       	push	r6
    469c:	7f 92       	push	r7
    469e:	8f 92       	push	r8
    46a0:	9f 92       	push	r9
    46a2:	af 92       	push	r10
    46a4:	bf 92       	push	r11
    46a6:	cf 92       	push	r12
    46a8:	df 92       	push	r13
    46aa:	ef 92       	push	r14
    46ac:	ff 92       	push	r15
    46ae:	0f 93       	push	r16
    46b0:	1f 93       	push	r17
    46b2:	2f 93       	push	r18
    46b4:	3f 93       	push	r19
    46b6:	4f 93       	push	r20
    46b8:	5f 93       	push	r21
    46ba:	6f 93       	push	r22
    46bc:	7f 93       	push	r23
    46be:	8f 93       	push	r24
    46c0:	9f 93       	push	r25
    46c2:	af 93       	push	r26
    46c4:	bf 93       	push	r27
    46c6:	cf 93       	push	r28
    46c8:	df 93       	push	r29
    46ca:	ef 93       	push	r30
    46cc:	ff 93       	push	r31
    46ce:	a0 91 4c 07 	lds	r26, 0x074C
    46d2:	b0 91 4d 07 	lds	r27, 0x074D
    46d6:	0d b6       	in	r0, 0x3d	; 61
    46d8:	0d 92       	st	X+, r0
    46da:	0e b6       	in	r0, 0x3e	; 62
    46dc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    46de:	0e 94 4b 2d 	call	0x5a96	; 0x5a96 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    46e2:	a0 91 4c 07 	lds	r26, 0x074C
    46e6:	b0 91 4d 07 	lds	r27, 0x074D
    46ea:	cd 91       	ld	r28, X+
    46ec:	cd bf       	out	0x3d, r28	; 61
    46ee:	dd 91       	ld	r29, X+
    46f0:	de bf       	out	0x3e, r29	; 62
    46f2:	ff 91       	pop	r31
    46f4:	ef 91       	pop	r30
    46f6:	df 91       	pop	r29
    46f8:	cf 91       	pop	r28
    46fa:	bf 91       	pop	r27
    46fc:	af 91       	pop	r26
    46fe:	9f 91       	pop	r25
    4700:	8f 91       	pop	r24
    4702:	7f 91       	pop	r23
    4704:	6f 91       	pop	r22
    4706:	5f 91       	pop	r21
    4708:	4f 91       	pop	r20
    470a:	3f 91       	pop	r19
    470c:	2f 91       	pop	r18
    470e:	1f 91       	pop	r17
    4710:	0f 91       	pop	r16
    4712:	ff 90       	pop	r15
    4714:	ef 90       	pop	r14
    4716:	df 90       	pop	r13
    4718:	cf 90       	pop	r12
    471a:	bf 90       	pop	r11
    471c:	af 90       	pop	r10
    471e:	9f 90       	pop	r9
    4720:	8f 90       	pop	r8
    4722:	7f 90       	pop	r7
    4724:	6f 90       	pop	r6
    4726:	5f 90       	pop	r5
    4728:	4f 90       	pop	r4
    472a:	3f 90       	pop	r3
    472c:	2f 90       	pop	r2
    472e:	1f 90       	pop	r1
    4730:	0f 90       	pop	r0
    4732:	0f be       	out	0x3f, r0	; 63
    4734:	0f 90       	pop	r0

	asm volatile ( "ret" );
    4736:	08 95       	ret

00004738 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    4738:	0f 92       	push	r0
    473a:	0f b6       	in	r0, 0x3f	; 63
    473c:	f8 94       	cli
    473e:	0f 92       	push	r0
    4740:	1f 92       	push	r1
    4742:	11 24       	eor	r1, r1
    4744:	2f 92       	push	r2
    4746:	3f 92       	push	r3
    4748:	4f 92       	push	r4
    474a:	5f 92       	push	r5
    474c:	6f 92       	push	r6
    474e:	7f 92       	push	r7
    4750:	8f 92       	push	r8
    4752:	9f 92       	push	r9
    4754:	af 92       	push	r10
    4756:	bf 92       	push	r11
    4758:	cf 92       	push	r12
    475a:	df 92       	push	r13
    475c:	ef 92       	push	r14
    475e:	ff 92       	push	r15
    4760:	0f 93       	push	r16
    4762:	1f 93       	push	r17
    4764:	2f 93       	push	r18
    4766:	3f 93       	push	r19
    4768:	4f 93       	push	r20
    476a:	5f 93       	push	r21
    476c:	6f 93       	push	r22
    476e:	7f 93       	push	r23
    4770:	8f 93       	push	r24
    4772:	9f 93       	push	r25
    4774:	af 93       	push	r26
    4776:	bf 93       	push	r27
    4778:	cf 93       	push	r28
    477a:	df 93       	push	r29
    477c:	ef 93       	push	r30
    477e:	ff 93       	push	r31
    4780:	a0 91 4c 07 	lds	r26, 0x074C
    4784:	b0 91 4d 07 	lds	r27, 0x074D
    4788:	0d b6       	in	r0, 0x3d	; 61
    478a:	0d 92       	st	X+, r0
    478c:	0e b6       	in	r0, 0x3e	; 62
    478e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    4790:	0e 94 76 2c 	call	0x58ec	; 0x58ec <vTaskIncrementTick>
	vTaskSwitchContext();
    4794:	0e 94 4b 2d 	call	0x5a96	; 0x5a96 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    4798:	a0 91 4c 07 	lds	r26, 0x074C
    479c:	b0 91 4d 07 	lds	r27, 0x074D
    47a0:	cd 91       	ld	r28, X+
    47a2:	cd bf       	out	0x3d, r28	; 61
    47a4:	dd 91       	ld	r29, X+
    47a6:	de bf       	out	0x3e, r29	; 62
    47a8:	ff 91       	pop	r31
    47aa:	ef 91       	pop	r30
    47ac:	df 91       	pop	r29
    47ae:	cf 91       	pop	r28
    47b0:	bf 91       	pop	r27
    47b2:	af 91       	pop	r26
    47b4:	9f 91       	pop	r25
    47b6:	8f 91       	pop	r24
    47b8:	7f 91       	pop	r23
    47ba:	6f 91       	pop	r22
    47bc:	5f 91       	pop	r21
    47be:	4f 91       	pop	r20
    47c0:	3f 91       	pop	r19
    47c2:	2f 91       	pop	r18
    47c4:	1f 91       	pop	r17
    47c6:	0f 91       	pop	r16
    47c8:	ff 90       	pop	r15
    47ca:	ef 90       	pop	r14
    47cc:	df 90       	pop	r13
    47ce:	cf 90       	pop	r12
    47d0:	bf 90       	pop	r11
    47d2:	af 90       	pop	r10
    47d4:	9f 90       	pop	r9
    47d6:	8f 90       	pop	r8
    47d8:	7f 90       	pop	r7
    47da:	6f 90       	pop	r6
    47dc:	5f 90       	pop	r5
    47de:	4f 90       	pop	r4
    47e0:	3f 90       	pop	r3
    47e2:	2f 90       	pop	r2
    47e4:	1f 90       	pop	r1
    47e6:	0f 90       	pop	r0
    47e8:	0f be       	out	0x3f, r0	; 63
    47ea:	0f 90       	pop	r0

	asm volatile ( "ret" );
    47ec:	08 95       	ret

000047ee <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    47ee:	df 93       	push	r29
    47f0:	cf 93       	push	r28
    47f2:	00 d0       	rcall	.+0      	; 0x47f4 <prvSetupTimerInterrupt+0x6>
    47f4:	00 d0       	rcall	.+0      	; 0x47f6 <prvSetupTimerInterrupt+0x8>
    47f6:	00 d0       	rcall	.+0      	; 0x47f8 <prvSetupTimerInterrupt+0xa>
    47f8:	cd b7       	in	r28, 0x3d	; 61
    47fa:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    47fc:	80 e4       	ldi	r24, 0x40	; 64
    47fe:	9f e1       	ldi	r25, 0x1F	; 31
    4800:	a0 e0       	ldi	r26, 0x00	; 0
    4802:	b0 e0       	ldi	r27, 0x00	; 0
    4804:	8b 83       	std	Y+3, r24	; 0x03
    4806:	9c 83       	std	Y+4, r25	; 0x04
    4808:	ad 83       	std	Y+5, r26	; 0x05
    480a:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    480c:	8b 81       	ldd	r24, Y+3	; 0x03
    480e:	9c 81       	ldd	r25, Y+4	; 0x04
    4810:	ad 81       	ldd	r26, Y+5	; 0x05
    4812:	be 81       	ldd	r27, Y+6	; 0x06
    4814:	68 94       	set
    4816:	15 f8       	bld	r1, 5
    4818:	b6 95       	lsr	r27
    481a:	a7 95       	ror	r26
    481c:	97 95       	ror	r25
    481e:	87 95       	ror	r24
    4820:	16 94       	lsr	r1
    4822:	d1 f7       	brne	.-12     	; 0x4818 <prvSetupTimerInterrupt+0x2a>
    4824:	8b 83       	std	Y+3, r24	; 0x03
    4826:	9c 83       	std	Y+4, r25	; 0x04
    4828:	ad 83       	std	Y+5, r26	; 0x05
    482a:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    482c:	8b 81       	ldd	r24, Y+3	; 0x03
    482e:	9c 81       	ldd	r25, Y+4	; 0x04
    4830:	ad 81       	ldd	r26, Y+5	; 0x05
    4832:	be 81       	ldd	r27, Y+6	; 0x06
    4834:	01 97       	sbiw	r24, 0x01	; 1
    4836:	a1 09       	sbc	r26, r1
    4838:	b1 09       	sbc	r27, r1
    483a:	8b 83       	std	Y+3, r24	; 0x03
    483c:	9c 83       	std	Y+4, r25	; 0x04
    483e:	ad 83       	std	Y+5, r26	; 0x05
    4840:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    4842:	8b 81       	ldd	r24, Y+3	; 0x03
    4844:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    4846:	8b 81       	ldd	r24, Y+3	; 0x03
    4848:	9c 81       	ldd	r25, Y+4	; 0x04
    484a:	ad 81       	ldd	r26, Y+5	; 0x05
    484c:	be 81       	ldd	r27, Y+6	; 0x06
    484e:	89 2f       	mov	r24, r25
    4850:	9a 2f       	mov	r25, r26
    4852:	ab 2f       	mov	r26, r27
    4854:	bb 27       	eor	r27, r27
    4856:	8b 83       	std	Y+3, r24	; 0x03
    4858:	9c 83       	std	Y+4, r25	; 0x04
    485a:	ad 83       	std	Y+5, r26	; 0x05
    485c:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    485e:	8b 81       	ldd	r24, Y+3	; 0x03
    4860:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    4862:	eb e4       	ldi	r30, 0x4B	; 75
    4864:	f0 e0       	ldi	r31, 0x00	; 0
    4866:	8a 81       	ldd	r24, Y+2	; 0x02
    4868:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    486a:	ea e4       	ldi	r30, 0x4A	; 74
    486c:	f0 e0       	ldi	r31, 0x00	; 0
    486e:	89 81       	ldd	r24, Y+1	; 0x01
    4870:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    4872:	8b e0       	ldi	r24, 0x0B	; 11
    4874:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    4876:	ee e4       	ldi	r30, 0x4E	; 78
    4878:	f0 e0       	ldi	r31, 0x00	; 0
    487a:	89 81       	ldd	r24, Y+1	; 0x01
    487c:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    487e:	e9 e5       	ldi	r30, 0x59	; 89
    4880:	f0 e0       	ldi	r31, 0x00	; 0
    4882:	80 81       	ld	r24, Z
    4884:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    4886:	89 81       	ldd	r24, Y+1	; 0x01
    4888:	80 61       	ori	r24, 0x10	; 16
    488a:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    488c:	e9 e5       	ldi	r30, 0x59	; 89
    488e:	f0 e0       	ldi	r31, 0x00	; 0
    4890:	89 81       	ldd	r24, Y+1	; 0x01
    4892:	80 83       	st	Z, r24
}
    4894:	26 96       	adiw	r28, 0x06	; 6
    4896:	0f b6       	in	r0, 0x3f	; 63
    4898:	f8 94       	cli
    489a:	de bf       	out	0x3e, r29	; 62
    489c:	0f be       	out	0x3f, r0	; 63
    489e:	cd bf       	out	0x3d, r28	; 61
    48a0:	cf 91       	pop	r28
    48a2:	df 91       	pop	r29
    48a4:	08 95       	ret

000048a6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    48a6:	0e 94 9c 23 	call	0x4738	; 0x4738 <vPortYieldFromTick>
		asm volatile ( "reti" );
    48aa:	18 95       	reti

000048ac <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    48ac:	df 93       	push	r29
    48ae:	cf 93       	push	r28
    48b0:	cd b7       	in	r28, 0x3d	; 61
    48b2:	de b7       	in	r29, 0x3e	; 62
    48b4:	28 97       	sbiw	r28, 0x08	; 8
    48b6:	0f b6       	in	r0, 0x3f	; 63
    48b8:	f8 94       	cli
    48ba:	de bf       	out	0x3e, r29	; 62
    48bc:	0f be       	out	0x3f, r0	; 63
    48be:	cd bf       	out	0x3d, r28	; 61
    48c0:	8f 83       	std	Y+7, r24	; 0x07
    48c2:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    48c4:	1a 82       	std	Y+2, r1	; 0x02
    48c6:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    48c8:	8f 81       	ldd	r24, Y+7	; 0x07
    48ca:	88 23       	and	r24, r24
    48cc:	09 f4       	brne	.+2      	; 0x48d0 <xQueueCreate+0x24>
    48ce:	8c c0       	rjmp	.+280    	; 0x49e8 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    48d0:	8f e1       	ldi	r24, 0x1F	; 31
    48d2:	90 e0       	ldi	r25, 0x00	; 0
    48d4:	0e 94 dd 1f 	call	0x3fba	; 0x3fba <pvPortMalloc>
    48d8:	9e 83       	std	Y+6, r25	; 0x06
    48da:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    48dc:	8d 81       	ldd	r24, Y+5	; 0x05
    48de:	9e 81       	ldd	r25, Y+6	; 0x06
    48e0:	00 97       	sbiw	r24, 0x00	; 0
    48e2:	09 f4       	brne	.+2      	; 0x48e6 <xQueueCreate+0x3a>
    48e4:	81 c0       	rjmp	.+258    	; 0x49e8 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    48e6:	8f 81       	ldd	r24, Y+7	; 0x07
    48e8:	28 2f       	mov	r18, r24
    48ea:	30 e0       	ldi	r19, 0x00	; 0
    48ec:	88 85       	ldd	r24, Y+8	; 0x08
    48ee:	88 2f       	mov	r24, r24
    48f0:	90 e0       	ldi	r25, 0x00	; 0
    48f2:	ac 01       	movw	r20, r24
    48f4:	24 9f       	mul	r18, r20
    48f6:	c0 01       	movw	r24, r0
    48f8:	25 9f       	mul	r18, r21
    48fa:	90 0d       	add	r25, r0
    48fc:	34 9f       	mul	r19, r20
    48fe:	90 0d       	add	r25, r0
    4900:	11 24       	eor	r1, r1
    4902:	01 96       	adiw	r24, 0x01	; 1
    4904:	9c 83       	std	Y+4, r25	; 0x04
    4906:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    4908:	8b 81       	ldd	r24, Y+3	; 0x03
    490a:	9c 81       	ldd	r25, Y+4	; 0x04
    490c:	0e 94 dd 1f 	call	0x3fba	; 0x3fba <pvPortMalloc>
    4910:	ed 81       	ldd	r30, Y+5	; 0x05
    4912:	fe 81       	ldd	r31, Y+6	; 0x06
    4914:	91 83       	std	Z+1, r25	; 0x01
    4916:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    4918:	ed 81       	ldd	r30, Y+5	; 0x05
    491a:	fe 81       	ldd	r31, Y+6	; 0x06
    491c:	80 81       	ld	r24, Z
    491e:	91 81       	ldd	r25, Z+1	; 0x01
    4920:	00 97       	sbiw	r24, 0x00	; 0
    4922:	09 f4       	brne	.+2      	; 0x4926 <xQueueCreate+0x7a>
    4924:	5d c0       	rjmp	.+186    	; 0x49e0 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    4926:	ed 81       	ldd	r30, Y+5	; 0x05
    4928:	fe 81       	ldd	r31, Y+6	; 0x06
    492a:	40 81       	ld	r20, Z
    492c:	51 81       	ldd	r21, Z+1	; 0x01
    492e:	8f 81       	ldd	r24, Y+7	; 0x07
    4930:	28 2f       	mov	r18, r24
    4932:	30 e0       	ldi	r19, 0x00	; 0
    4934:	88 85       	ldd	r24, Y+8	; 0x08
    4936:	88 2f       	mov	r24, r24
    4938:	90 e0       	ldi	r25, 0x00	; 0
    493a:	bc 01       	movw	r22, r24
    493c:	26 9f       	mul	r18, r22
    493e:	c0 01       	movw	r24, r0
    4940:	27 9f       	mul	r18, r23
    4942:	90 0d       	add	r25, r0
    4944:	36 9f       	mul	r19, r22
    4946:	90 0d       	add	r25, r0
    4948:	11 24       	eor	r1, r1
    494a:	84 0f       	add	r24, r20
    494c:	95 1f       	adc	r25, r21
    494e:	ed 81       	ldd	r30, Y+5	; 0x05
    4950:	fe 81       	ldd	r31, Y+6	; 0x06
    4952:	93 83       	std	Z+3, r25	; 0x03
    4954:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    4956:	ed 81       	ldd	r30, Y+5	; 0x05
    4958:	fe 81       	ldd	r31, Y+6	; 0x06
    495a:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    495c:	ed 81       	ldd	r30, Y+5	; 0x05
    495e:	fe 81       	ldd	r31, Y+6	; 0x06
    4960:	80 81       	ld	r24, Z
    4962:	91 81       	ldd	r25, Z+1	; 0x01
    4964:	ed 81       	ldd	r30, Y+5	; 0x05
    4966:	fe 81       	ldd	r31, Y+6	; 0x06
    4968:	95 83       	std	Z+5, r25	; 0x05
    496a:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    496c:	ed 81       	ldd	r30, Y+5	; 0x05
    496e:	fe 81       	ldd	r31, Y+6	; 0x06
    4970:	40 81       	ld	r20, Z
    4972:	51 81       	ldd	r21, Z+1	; 0x01
    4974:	8f 81       	ldd	r24, Y+7	; 0x07
    4976:	88 2f       	mov	r24, r24
    4978:	90 e0       	ldi	r25, 0x00	; 0
    497a:	9c 01       	movw	r18, r24
    497c:	21 50       	subi	r18, 0x01	; 1
    497e:	30 40       	sbci	r19, 0x00	; 0
    4980:	88 85       	ldd	r24, Y+8	; 0x08
    4982:	88 2f       	mov	r24, r24
    4984:	90 e0       	ldi	r25, 0x00	; 0
    4986:	bc 01       	movw	r22, r24
    4988:	26 9f       	mul	r18, r22
    498a:	c0 01       	movw	r24, r0
    498c:	27 9f       	mul	r18, r23
    498e:	90 0d       	add	r25, r0
    4990:	36 9f       	mul	r19, r22
    4992:	90 0d       	add	r25, r0
    4994:	11 24       	eor	r1, r1
    4996:	84 0f       	add	r24, r20
    4998:	95 1f       	adc	r25, r21
    499a:	ed 81       	ldd	r30, Y+5	; 0x05
    499c:	fe 81       	ldd	r31, Y+6	; 0x06
    499e:	97 83       	std	Z+7, r25	; 0x07
    49a0:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    49a2:	ed 81       	ldd	r30, Y+5	; 0x05
    49a4:	fe 81       	ldd	r31, Y+6	; 0x06
    49a6:	8f 81       	ldd	r24, Y+7	; 0x07
    49a8:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    49aa:	ed 81       	ldd	r30, Y+5	; 0x05
    49ac:	fe 81       	ldd	r31, Y+6	; 0x06
    49ae:	88 85       	ldd	r24, Y+8	; 0x08
    49b0:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    49b2:	ed 81       	ldd	r30, Y+5	; 0x05
    49b4:	fe 81       	ldd	r31, Y+6	; 0x06
    49b6:	8f ef       	ldi	r24, 0xFF	; 255
    49b8:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    49ba:	ed 81       	ldd	r30, Y+5	; 0x05
    49bc:	fe 81       	ldd	r31, Y+6	; 0x06
    49be:	8f ef       	ldi	r24, 0xFF	; 255
    49c0:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    49c2:	8d 81       	ldd	r24, Y+5	; 0x05
    49c4:	9e 81       	ldd	r25, Y+6	; 0x06
    49c6:	08 96       	adiw	r24, 0x08	; 8
    49c8:	0e 94 49 20 	call	0x4092	; 0x4092 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    49cc:	8d 81       	ldd	r24, Y+5	; 0x05
    49ce:	9e 81       	ldd	r25, Y+6	; 0x06
    49d0:	41 96       	adiw	r24, 0x11	; 17
    49d2:	0e 94 49 20 	call	0x4092	; 0x4092 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    49d6:	8d 81       	ldd	r24, Y+5	; 0x05
    49d8:	9e 81       	ldd	r25, Y+6	; 0x06
    49da:	9a 83       	std	Y+2, r25	; 0x02
    49dc:	89 83       	std	Y+1, r24	; 0x01
    49de:	04 c0       	rjmp	.+8      	; 0x49e8 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    49e0:	8d 81       	ldd	r24, Y+5	; 0x05
    49e2:	9e 81       	ldd	r25, Y+6	; 0x06
    49e4:	0e 94 23 20 	call	0x4046	; 0x4046 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    49e8:	89 81       	ldd	r24, Y+1	; 0x01
    49ea:	9a 81       	ldd	r25, Y+2	; 0x02
}
    49ec:	28 96       	adiw	r28, 0x08	; 8
    49ee:	0f b6       	in	r0, 0x3f	; 63
    49f0:	f8 94       	cli
    49f2:	de bf       	out	0x3e, r29	; 62
    49f4:	0f be       	out	0x3f, r0	; 63
    49f6:	cd bf       	out	0x3d, r28	; 61
    49f8:	cf 91       	pop	r28
    49fa:	df 91       	pop	r29
    49fc:	08 95       	ret

000049fe <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
    49fe:	df 93       	push	r29
    4a00:	cf 93       	push	r28
    4a02:	00 d0       	rcall	.+0      	; 0x4a04 <xQueueCreateMutex+0x6>
    4a04:	cd b7       	in	r28, 0x3d	; 61
    4a06:	de b7       	in	r29, 0x3e	; 62
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    4a08:	8f e1       	ldi	r24, 0x1F	; 31
    4a0a:	90 e0       	ldi	r25, 0x00	; 0
    4a0c:	0e 94 dd 1f 	call	0x3fba	; 0x3fba <pvPortMalloc>
    4a10:	9a 83       	std	Y+2, r25	; 0x02
    4a12:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    4a14:	89 81       	ldd	r24, Y+1	; 0x01
    4a16:	9a 81       	ldd	r25, Y+2	; 0x02
    4a18:	00 97       	sbiw	r24, 0x00	; 0
    4a1a:	a9 f1       	breq	.+106    	; 0x4a86 <xQueueCreateMutex+0x88>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    4a1c:	e9 81       	ldd	r30, Y+1	; 0x01
    4a1e:	fa 81       	ldd	r31, Y+2	; 0x02
    4a20:	13 82       	std	Z+3, r1	; 0x03
    4a22:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    4a24:	e9 81       	ldd	r30, Y+1	; 0x01
    4a26:	fa 81       	ldd	r31, Y+2	; 0x02
    4a28:	11 82       	std	Z+1, r1	; 0x01
    4a2a:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    4a2c:	e9 81       	ldd	r30, Y+1	; 0x01
    4a2e:	fa 81       	ldd	r31, Y+2	; 0x02
    4a30:	15 82       	std	Z+5, r1	; 0x05
    4a32:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    4a34:	e9 81       	ldd	r30, Y+1	; 0x01
    4a36:	fa 81       	ldd	r31, Y+2	; 0x02
    4a38:	17 82       	std	Z+7, r1	; 0x07
    4a3a:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    4a3c:	e9 81       	ldd	r30, Y+1	; 0x01
    4a3e:	fa 81       	ldd	r31, Y+2	; 0x02
    4a40:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    4a42:	e9 81       	ldd	r30, Y+1	; 0x01
    4a44:	fa 81       	ldd	r31, Y+2	; 0x02
    4a46:	81 e0       	ldi	r24, 0x01	; 1
    4a48:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    4a4a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a4c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a4e:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    4a50:	e9 81       	ldd	r30, Y+1	; 0x01
    4a52:	fa 81       	ldd	r31, Y+2	; 0x02
    4a54:	8f ef       	ldi	r24, 0xFF	; 255
    4a56:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    4a58:	e9 81       	ldd	r30, Y+1	; 0x01
    4a5a:	fa 81       	ldd	r31, Y+2	; 0x02
    4a5c:	8f ef       	ldi	r24, 0xFF	; 255
    4a5e:	86 8f       	std	Z+30, r24	; 0x1e

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    4a60:	89 81       	ldd	r24, Y+1	; 0x01
    4a62:	9a 81       	ldd	r25, Y+2	; 0x02
    4a64:	08 96       	adiw	r24, 0x08	; 8
    4a66:	0e 94 49 20 	call	0x4092	; 0x4092 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    4a6a:	89 81       	ldd	r24, Y+1	; 0x01
    4a6c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a6e:	41 96       	adiw	r24, 0x11	; 17
    4a70:	0e 94 49 20 	call	0x4092	; 0x4092 <vListInitialise>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    4a74:	89 81       	ldd	r24, Y+1	; 0x01
    4a76:	9a 81       	ldd	r25, Y+2	; 0x02
    4a78:	60 e0       	ldi	r22, 0x00	; 0
    4a7a:	70 e0       	ldi	r23, 0x00	; 0
    4a7c:	40 e0       	ldi	r20, 0x00	; 0
    4a7e:	50 e0       	ldi	r21, 0x00	; 0
    4a80:	20 e0       	ldi	r18, 0x00	; 0
    4a82:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    4a86:	89 81       	ldd	r24, Y+1	; 0x01
    4a88:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4a8a:	0f 90       	pop	r0
    4a8c:	0f 90       	pop	r0
    4a8e:	cf 91       	pop	r28
    4a90:	df 91       	pop	r29
    4a92:	08 95       	ret

00004a94 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    4a94:	df 93       	push	r29
    4a96:	cf 93       	push	r28
    4a98:	00 d0       	rcall	.+0      	; 0x4a9a <xQueueCreateCountingSemaphore+0x6>
    4a9a:	00 d0       	rcall	.+0      	; 0x4a9c <xQueueCreateCountingSemaphore+0x8>
    4a9c:	cd b7       	in	r28, 0x3d	; 61
    4a9e:	de b7       	in	r29, 0x3e	; 62
    4aa0:	8b 83       	std	Y+3, r24	; 0x03
    4aa2:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    4aa4:	8b 81       	ldd	r24, Y+3	; 0x03
    4aa6:	60 e0       	ldi	r22, 0x00	; 0
    4aa8:	0e 94 56 24 	call	0x48ac	; 0x48ac <xQueueCreate>
    4aac:	9a 83       	std	Y+2, r25	; 0x02
    4aae:	89 83       	std	Y+1, r24	; 0x01

		if( pxHandle != NULL )
    4ab0:	89 81       	ldd	r24, Y+1	; 0x01
    4ab2:	9a 81       	ldd	r25, Y+2	; 0x02
    4ab4:	00 97       	sbiw	r24, 0x00	; 0
    4ab6:	21 f0       	breq	.+8      	; 0x4ac0 <xQueueCreateCountingSemaphore+0x2c>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    4ab8:	e9 81       	ldd	r30, Y+1	; 0x01
    4aba:	fa 81       	ldd	r31, Y+2	; 0x02
    4abc:	8c 81       	ldd	r24, Y+4	; 0x04
    4abe:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
    4ac0:	89 81       	ldd	r24, Y+1	; 0x01
    4ac2:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4ac4:	0f 90       	pop	r0
    4ac6:	0f 90       	pop	r0
    4ac8:	0f 90       	pop	r0
    4aca:	0f 90       	pop	r0
    4acc:	cf 91       	pop	r28
    4ace:	df 91       	pop	r29
    4ad0:	08 95       	ret

00004ad2 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    4ad2:	df 93       	push	r29
    4ad4:	cf 93       	push	r28
    4ad6:	cd b7       	in	r28, 0x3d	; 61
    4ad8:	de b7       	in	r29, 0x3e	; 62
    4ada:	2c 97       	sbiw	r28, 0x0c	; 12
    4adc:	0f b6       	in	r0, 0x3f	; 63
    4ade:	f8 94       	cli
    4ae0:	de bf       	out	0x3e, r29	; 62
    4ae2:	0f be       	out	0x3f, r0	; 63
    4ae4:	cd bf       	out	0x3d, r28	; 61
    4ae6:	9e 83       	std	Y+6, r25	; 0x06
    4ae8:	8d 83       	std	Y+5, r24	; 0x05
    4aea:	78 87       	std	Y+8, r23	; 0x08
    4aec:	6f 83       	std	Y+7, r22	; 0x07
    4aee:	5a 87       	std	Y+10, r21	; 0x0a
    4af0:	49 87       	std	Y+9, r20	; 0x09
    4af2:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    4af4:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    4af6:	0f b6       	in	r0, 0x3f	; 63
    4af8:	f8 94       	cli
    4afa:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4afc:	ed 81       	ldd	r30, Y+5	; 0x05
    4afe:	fe 81       	ldd	r31, Y+6	; 0x06
    4b00:	92 8d       	ldd	r25, Z+26	; 0x1a
    4b02:	ed 81       	ldd	r30, Y+5	; 0x05
    4b04:	fe 81       	ldd	r31, Y+6	; 0x06
    4b06:	83 8d       	ldd	r24, Z+27	; 0x1b
    4b08:	98 17       	cp	r25, r24
    4b0a:	d8 f4       	brcc	.+54     	; 0x4b42 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    4b0c:	8d 81       	ldd	r24, Y+5	; 0x05
    4b0e:	9e 81       	ldd	r25, Y+6	; 0x06
    4b10:	2f 81       	ldd	r18, Y+7	; 0x07
    4b12:	38 85       	ldd	r19, Y+8	; 0x08
    4b14:	b9 01       	movw	r22, r18
    4b16:	4b 85       	ldd	r20, Y+11	; 0x0b
    4b18:	0e 94 c1 27 	call	0x4f82	; 0x4f82 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4b1c:	ed 81       	ldd	r30, Y+5	; 0x05
    4b1e:	fe 81       	ldd	r31, Y+6	; 0x06
    4b20:	81 89       	ldd	r24, Z+17	; 0x11
    4b22:	88 23       	and	r24, r24
    4b24:	49 f0       	breq	.+18     	; 0x4b38 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    4b26:	8d 81       	ldd	r24, Y+5	; 0x05
    4b28:	9e 81       	ldd	r25, Y+6	; 0x06
    4b2a:	41 96       	adiw	r24, 0x11	; 17
    4b2c:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <xTaskRemoveFromEventList>
    4b30:	81 30       	cpi	r24, 0x01	; 1
    4b32:	11 f4       	brne	.+4      	; 0x4b38 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    4b34:	0e 94 43 23 	call	0x4686	; 0x4686 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    4b38:	0f 90       	pop	r0
    4b3a:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    4b3c:	81 e0       	ldi	r24, 0x01	; 1
    4b3e:	8c 87       	std	Y+12, r24	; 0x0c
    4b40:	5c c0       	rjmp	.+184    	; 0x4bfa <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    4b42:	89 85       	ldd	r24, Y+9	; 0x09
    4b44:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b46:	00 97       	sbiw	r24, 0x00	; 0
    4b48:	21 f4       	brne	.+8      	; 0x4b52 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    4b4a:	0f 90       	pop	r0
    4b4c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    4b4e:	1c 86       	std	Y+12, r1	; 0x0c
    4b50:	54 c0       	rjmp	.+168    	; 0x4bfa <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    4b52:	89 81       	ldd	r24, Y+1	; 0x01
    4b54:	88 23       	and	r24, r24
    4b56:	31 f4       	brne	.+12     	; 0x4b64 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4b58:	ce 01       	movw	r24, r28
    4b5a:	02 96       	adiw	r24, 0x02	; 2
    4b5c:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    4b60:	81 e0       	ldi	r24, 0x01	; 1
    4b62:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    4b64:	0f 90       	pop	r0
    4b66:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4b68:	0e 94 ab 2b 	call	0x5756	; 0x5756 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    4b6c:	0f b6       	in	r0, 0x3f	; 63
    4b6e:	f8 94       	cli
    4b70:	0f 92       	push	r0
    4b72:	ed 81       	ldd	r30, Y+5	; 0x05
    4b74:	fe 81       	ldd	r31, Y+6	; 0x06
    4b76:	85 8d       	ldd	r24, Z+29	; 0x1d
    4b78:	8f 3f       	cpi	r24, 0xFF	; 255
    4b7a:	19 f4       	brne	.+6      	; 0x4b82 <xQueueGenericSend+0xb0>
    4b7c:	ed 81       	ldd	r30, Y+5	; 0x05
    4b7e:	fe 81       	ldd	r31, Y+6	; 0x06
    4b80:	15 8e       	std	Z+29, r1	; 0x1d
    4b82:	ed 81       	ldd	r30, Y+5	; 0x05
    4b84:	fe 81       	ldd	r31, Y+6	; 0x06
    4b86:	86 8d       	ldd	r24, Z+30	; 0x1e
    4b88:	8f 3f       	cpi	r24, 0xFF	; 255
    4b8a:	19 f4       	brne	.+6      	; 0x4b92 <xQueueGenericSend+0xc0>
    4b8c:	ed 81       	ldd	r30, Y+5	; 0x05
    4b8e:	fe 81       	ldd	r31, Y+6	; 0x06
    4b90:	16 8e       	std	Z+30, r1	; 0x1e
    4b92:	0f 90       	pop	r0
    4b94:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4b96:	ce 01       	movw	r24, r28
    4b98:	02 96       	adiw	r24, 0x02	; 2
    4b9a:	9e 01       	movw	r18, r28
    4b9c:	27 5f       	subi	r18, 0xF7	; 247
    4b9e:	3f 4f       	sbci	r19, 0xFF	; 255
    4ba0:	b9 01       	movw	r22, r18
    4ba2:	0e 94 68 2e 	call	0x5cd0	; 0x5cd0 <xTaskCheckForTimeOut>
    4ba6:	88 23       	and	r24, r24
    4ba8:	09 f5       	brne	.+66     	; 0x4bec <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    4baa:	8d 81       	ldd	r24, Y+5	; 0x05
    4bac:	9e 81       	ldd	r25, Y+6	; 0x06
    4bae:	0e 94 36 29 	call	0x526c	; 0x526c <prvIsQueueFull>
    4bb2:	88 23       	and	r24, r24
    4bb4:	a1 f0       	breq	.+40     	; 0x4bde <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    4bb6:	8d 81       	ldd	r24, Y+5	; 0x05
    4bb8:	9e 81       	ldd	r25, Y+6	; 0x06
    4bba:	08 96       	adiw	r24, 0x08	; 8
    4bbc:	29 85       	ldd	r18, Y+9	; 0x09
    4bbe:	3a 85       	ldd	r19, Y+10	; 0x0a
    4bc0:	b9 01       	movw	r22, r18
    4bc2:	0e 94 b1 2d 	call	0x5b62	; 0x5b62 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    4bc6:	8d 81       	ldd	r24, Y+5	; 0x05
    4bc8:	9e 81       	ldd	r25, Y+6	; 0x06
    4bca:	0e 94 af 28 	call	0x515e	; 0x515e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    4bce:	0e 94 b7 2b 	call	0x576e	; 0x576e <xTaskResumeAll>
    4bd2:	88 23       	and	r24, r24
    4bd4:	09 f0       	breq	.+2      	; 0x4bd8 <xQueueGenericSend+0x106>
    4bd6:	8f cf       	rjmp	.-226    	; 0x4af6 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    4bd8:	0e 94 43 23 	call	0x4686	; 0x4686 <vPortYield>
    4bdc:	8c cf       	rjmp	.-232    	; 0x4af6 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    4bde:	8d 81       	ldd	r24, Y+5	; 0x05
    4be0:	9e 81       	ldd	r25, Y+6	; 0x06
    4be2:	0e 94 af 28 	call	0x515e	; 0x515e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    4be6:	0e 94 b7 2b 	call	0x576e	; 0x576e <xTaskResumeAll>
    4bea:	85 cf       	rjmp	.-246    	; 0x4af6 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    4bec:	8d 81       	ldd	r24, Y+5	; 0x05
    4bee:	9e 81       	ldd	r25, Y+6	; 0x06
    4bf0:	0e 94 af 28 	call	0x515e	; 0x515e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    4bf4:	0e 94 b7 2b 	call	0x576e	; 0x576e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    4bf8:	1c 86       	std	Y+12, r1	; 0x0c
    4bfa:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    4bfc:	2c 96       	adiw	r28, 0x0c	; 12
    4bfe:	0f b6       	in	r0, 0x3f	; 63
    4c00:	f8 94       	cli
    4c02:	de bf       	out	0x3e, r29	; 62
    4c04:	0f be       	out	0x3f, r0	; 63
    4c06:	cd bf       	out	0x3d, r28	; 61
    4c08:	cf 91       	pop	r28
    4c0a:	df 91       	pop	r29
    4c0c:	08 95       	ret

00004c0e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    4c0e:	df 93       	push	r29
    4c10:	cf 93       	push	r28
    4c12:	cd b7       	in	r28, 0x3d	; 61
    4c14:	de b7       	in	r29, 0x3e	; 62
    4c16:	29 97       	sbiw	r28, 0x09	; 9
    4c18:	0f b6       	in	r0, 0x3f	; 63
    4c1a:	f8 94       	cli
    4c1c:	de bf       	out	0x3e, r29	; 62
    4c1e:	0f be       	out	0x3f, r0	; 63
    4c20:	cd bf       	out	0x3d, r28	; 61
    4c22:	9c 83       	std	Y+4, r25	; 0x04
    4c24:	8b 83       	std	Y+3, r24	; 0x03
    4c26:	7e 83       	std	Y+6, r23	; 0x06
    4c28:	6d 83       	std	Y+5, r22	; 0x05
    4c2a:	58 87       	std	Y+8, r21	; 0x08
    4c2c:	4f 83       	std	Y+7, r20	; 0x07
    4c2e:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4c30:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4c32:	eb 81       	ldd	r30, Y+3	; 0x03
    4c34:	fc 81       	ldd	r31, Y+4	; 0x04
    4c36:	92 8d       	ldd	r25, Z+26	; 0x1a
    4c38:	eb 81       	ldd	r30, Y+3	; 0x03
    4c3a:	fc 81       	ldd	r31, Y+4	; 0x04
    4c3c:	83 8d       	ldd	r24, Z+27	; 0x1b
    4c3e:	98 17       	cp	r25, r24
    4c40:	40 f5       	brcc	.+80     	; 0x4c92 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    4c42:	8b 81       	ldd	r24, Y+3	; 0x03
    4c44:	9c 81       	ldd	r25, Y+4	; 0x04
    4c46:	2d 81       	ldd	r18, Y+5	; 0x05
    4c48:	3e 81       	ldd	r19, Y+6	; 0x06
    4c4a:	b9 01       	movw	r22, r18
    4c4c:	49 85       	ldd	r20, Y+9	; 0x09
    4c4e:	0e 94 c1 27 	call	0x4f82	; 0x4f82 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    4c52:	eb 81       	ldd	r30, Y+3	; 0x03
    4c54:	fc 81       	ldd	r31, Y+4	; 0x04
    4c56:	86 8d       	ldd	r24, Z+30	; 0x1e
    4c58:	8f 3f       	cpi	r24, 0xFF	; 255
    4c5a:	89 f4       	brne	.+34     	; 0x4c7e <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4c5c:	eb 81       	ldd	r30, Y+3	; 0x03
    4c5e:	fc 81       	ldd	r31, Y+4	; 0x04
    4c60:	81 89       	ldd	r24, Z+17	; 0x11
    4c62:	88 23       	and	r24, r24
    4c64:	99 f0       	breq	.+38     	; 0x4c8c <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4c66:	8b 81       	ldd	r24, Y+3	; 0x03
    4c68:	9c 81       	ldd	r25, Y+4	; 0x04
    4c6a:	41 96       	adiw	r24, 0x11	; 17
    4c6c:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <xTaskRemoveFromEventList>
    4c70:	88 23       	and	r24, r24
    4c72:	61 f0       	breq	.+24     	; 0x4c8c <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    4c74:	ef 81       	ldd	r30, Y+7	; 0x07
    4c76:	f8 85       	ldd	r31, Y+8	; 0x08
    4c78:	81 e0       	ldi	r24, 0x01	; 1
    4c7a:	80 83       	st	Z, r24
    4c7c:	07 c0       	rjmp	.+14     	; 0x4c8c <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    4c7e:	eb 81       	ldd	r30, Y+3	; 0x03
    4c80:	fc 81       	ldd	r31, Y+4	; 0x04
    4c82:	86 8d       	ldd	r24, Z+30	; 0x1e
    4c84:	8f 5f       	subi	r24, 0xFF	; 255
    4c86:	eb 81       	ldd	r30, Y+3	; 0x03
    4c88:	fc 81       	ldd	r31, Y+4	; 0x04
    4c8a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    4c8c:	81 e0       	ldi	r24, 0x01	; 1
    4c8e:	8a 83       	std	Y+2, r24	; 0x02
    4c90:	01 c0       	rjmp	.+2      	; 0x4c94 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    4c92:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4c94:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4c96:	29 96       	adiw	r28, 0x09	; 9
    4c98:	0f b6       	in	r0, 0x3f	; 63
    4c9a:	f8 94       	cli
    4c9c:	de bf       	out	0x3e, r29	; 62
    4c9e:	0f be       	out	0x3f, r0	; 63
    4ca0:	cd bf       	out	0x3d, r28	; 61
    4ca2:	cf 91       	pop	r28
    4ca4:	df 91       	pop	r29
    4ca6:	08 95       	ret

00004ca8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    4ca8:	df 93       	push	r29
    4caa:	cf 93       	push	r28
    4cac:	cd b7       	in	r28, 0x3d	; 61
    4cae:	de b7       	in	r29, 0x3e	; 62
    4cb0:	2e 97       	sbiw	r28, 0x0e	; 14
    4cb2:	0f b6       	in	r0, 0x3f	; 63
    4cb4:	f8 94       	cli
    4cb6:	de bf       	out	0x3e, r29	; 62
    4cb8:	0f be       	out	0x3f, r0	; 63
    4cba:	cd bf       	out	0x3d, r28	; 61
    4cbc:	98 87       	std	Y+8, r25	; 0x08
    4cbe:	8f 83       	std	Y+7, r24	; 0x07
    4cc0:	7a 87       	std	Y+10, r23	; 0x0a
    4cc2:	69 87       	std	Y+9, r22	; 0x09
    4cc4:	5c 87       	std	Y+12, r21	; 0x0c
    4cc6:	4b 87       	std	Y+11, r20	; 0x0b
    4cc8:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    4cca:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    4ccc:	0f b6       	in	r0, 0x3f	; 63
    4cce:	f8 94       	cli
    4cd0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    4cd2:	ef 81       	ldd	r30, Y+7	; 0x07
    4cd4:	f8 85       	ldd	r31, Y+8	; 0x08
    4cd6:	82 8d       	ldd	r24, Z+26	; 0x1a
    4cd8:	88 23       	and	r24, r24
    4cda:	09 f4       	brne	.+2      	; 0x4cde <xQueueGenericReceive+0x36>
    4cdc:	4b c0       	rjmp	.+150    	; 0x4d74 <xQueueGenericReceive+0xcc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    4cde:	ef 81       	ldd	r30, Y+7	; 0x07
    4ce0:	f8 85       	ldd	r31, Y+8	; 0x08
    4ce2:	86 81       	ldd	r24, Z+6	; 0x06
    4ce4:	97 81       	ldd	r25, Z+7	; 0x07
    4ce6:	9a 83       	std	Y+2, r25	; 0x02
    4ce8:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    4cea:	8f 81       	ldd	r24, Y+7	; 0x07
    4cec:	98 85       	ldd	r25, Y+8	; 0x08
    4cee:	29 85       	ldd	r18, Y+9	; 0x09
    4cf0:	3a 85       	ldd	r19, Y+10	; 0x0a
    4cf2:	b9 01       	movw	r22, r18
    4cf4:	0e 94 67 28 	call	0x50ce	; 0x50ce <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    4cf8:	8d 85       	ldd	r24, Y+13	; 0x0d
    4cfa:	88 23       	and	r24, r24
    4cfc:	11 f5       	brne	.+68     	; 0x4d42 <xQueueGenericReceive+0x9a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    4cfe:	ef 81       	ldd	r30, Y+7	; 0x07
    4d00:	f8 85       	ldd	r31, Y+8	; 0x08
    4d02:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d04:	81 50       	subi	r24, 0x01	; 1
    4d06:	ef 81       	ldd	r30, Y+7	; 0x07
    4d08:	f8 85       	ldd	r31, Y+8	; 0x08
    4d0a:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4d0c:	ef 81       	ldd	r30, Y+7	; 0x07
    4d0e:	f8 85       	ldd	r31, Y+8	; 0x08
    4d10:	80 81       	ld	r24, Z
    4d12:	91 81       	ldd	r25, Z+1	; 0x01
    4d14:	00 97       	sbiw	r24, 0x00	; 0
    4d16:	31 f4       	brne	.+12     	; 0x4d24 <xQueueGenericReceive+0x7c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    4d18:	0e 94 5e 30 	call	0x60bc	; 0x60bc <xTaskGetCurrentTaskHandle>
    4d1c:	ef 81       	ldd	r30, Y+7	; 0x07
    4d1e:	f8 85       	ldd	r31, Y+8	; 0x08
    4d20:	93 83       	std	Z+3, r25	; 0x03
    4d22:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4d24:	ef 81       	ldd	r30, Y+7	; 0x07
    4d26:	f8 85       	ldd	r31, Y+8	; 0x08
    4d28:	80 85       	ldd	r24, Z+8	; 0x08
    4d2a:	88 23       	and	r24, r24
    4d2c:	f1 f0       	breq	.+60     	; 0x4d6a <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    4d2e:	8f 81       	ldd	r24, Y+7	; 0x07
    4d30:	98 85       	ldd	r25, Y+8	; 0x08
    4d32:	08 96       	adiw	r24, 0x08	; 8
    4d34:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <xTaskRemoveFromEventList>
    4d38:	81 30       	cpi	r24, 0x01	; 1
    4d3a:	b9 f4       	brne	.+46     	; 0x4d6a <xQueueGenericReceive+0xc2>
						{
							portYIELD_WITHIN_API();
    4d3c:	0e 94 43 23 	call	0x4686	; 0x4686 <vPortYield>
    4d40:	14 c0       	rjmp	.+40     	; 0x4d6a <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    4d42:	ef 81       	ldd	r30, Y+7	; 0x07
    4d44:	f8 85       	ldd	r31, Y+8	; 0x08
    4d46:	89 81       	ldd	r24, Y+1	; 0x01
    4d48:	9a 81       	ldd	r25, Y+2	; 0x02
    4d4a:	97 83       	std	Z+7, r25	; 0x07
    4d4c:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4d4e:	ef 81       	ldd	r30, Y+7	; 0x07
    4d50:	f8 85       	ldd	r31, Y+8	; 0x08
    4d52:	81 89       	ldd	r24, Z+17	; 0x11
    4d54:	88 23       	and	r24, r24
    4d56:	49 f0       	breq	.+18     	; 0x4d6a <xQueueGenericReceive+0xc2>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4d58:	8f 81       	ldd	r24, Y+7	; 0x07
    4d5a:	98 85       	ldd	r25, Y+8	; 0x08
    4d5c:	41 96       	adiw	r24, 0x11	; 17
    4d5e:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <xTaskRemoveFromEventList>
    4d62:	88 23       	and	r24, r24
    4d64:	11 f0       	breq	.+4      	; 0x4d6a <xQueueGenericReceive+0xc2>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    4d66:	0e 94 43 23 	call	0x4686	; 0x4686 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    4d6a:	0f 90       	pop	r0
    4d6c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    4d6e:	81 e0       	ldi	r24, 0x01	; 1
    4d70:	8e 87       	std	Y+14, r24	; 0x0e
    4d72:	6d c0       	rjmp	.+218    	; 0x4e4e <xQueueGenericReceive+0x1a6>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    4d74:	8b 85       	ldd	r24, Y+11	; 0x0b
    4d76:	9c 85       	ldd	r25, Y+12	; 0x0c
    4d78:	00 97       	sbiw	r24, 0x00	; 0
    4d7a:	21 f4       	brne	.+8      	; 0x4d84 <xQueueGenericReceive+0xdc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    4d7c:	0f 90       	pop	r0
    4d7e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    4d80:	1e 86       	std	Y+14, r1	; 0x0e
    4d82:	65 c0       	rjmp	.+202    	; 0x4e4e <xQueueGenericReceive+0x1a6>
				}
				else if( xEntryTimeSet == pdFALSE )
    4d84:	8b 81       	ldd	r24, Y+3	; 0x03
    4d86:	88 23       	and	r24, r24
    4d88:	31 f4       	brne	.+12     	; 0x4d96 <xQueueGenericReceive+0xee>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4d8a:	ce 01       	movw	r24, r28
    4d8c:	04 96       	adiw	r24, 0x04	; 4
    4d8e:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    4d92:	81 e0       	ldi	r24, 0x01	; 1
    4d94:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    4d96:	0f 90       	pop	r0
    4d98:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4d9a:	0e 94 ab 2b 	call	0x5756	; 0x5756 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    4d9e:	0f b6       	in	r0, 0x3f	; 63
    4da0:	f8 94       	cli
    4da2:	0f 92       	push	r0
    4da4:	ef 81       	ldd	r30, Y+7	; 0x07
    4da6:	f8 85       	ldd	r31, Y+8	; 0x08
    4da8:	85 8d       	ldd	r24, Z+29	; 0x1d
    4daa:	8f 3f       	cpi	r24, 0xFF	; 255
    4dac:	19 f4       	brne	.+6      	; 0x4db4 <xQueueGenericReceive+0x10c>
    4dae:	ef 81       	ldd	r30, Y+7	; 0x07
    4db0:	f8 85       	ldd	r31, Y+8	; 0x08
    4db2:	15 8e       	std	Z+29, r1	; 0x1d
    4db4:	ef 81       	ldd	r30, Y+7	; 0x07
    4db6:	f8 85       	ldd	r31, Y+8	; 0x08
    4db8:	86 8d       	ldd	r24, Z+30	; 0x1e
    4dba:	8f 3f       	cpi	r24, 0xFF	; 255
    4dbc:	19 f4       	brne	.+6      	; 0x4dc4 <xQueueGenericReceive+0x11c>
    4dbe:	ef 81       	ldd	r30, Y+7	; 0x07
    4dc0:	f8 85       	ldd	r31, Y+8	; 0x08
    4dc2:	16 8e       	std	Z+30, r1	; 0x1e
    4dc4:	0f 90       	pop	r0
    4dc6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4dc8:	ce 01       	movw	r24, r28
    4dca:	04 96       	adiw	r24, 0x04	; 4
    4dcc:	9e 01       	movw	r18, r28
    4dce:	25 5f       	subi	r18, 0xF5	; 245
    4dd0:	3f 4f       	sbci	r19, 0xFF	; 255
    4dd2:	b9 01       	movw	r22, r18
    4dd4:	0e 94 68 2e 	call	0x5cd0	; 0x5cd0 <xTaskCheckForTimeOut>
    4dd8:	88 23       	and	r24, r24
    4dda:	91 f5       	brne	.+100    	; 0x4e40 <xQueueGenericReceive+0x198>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4ddc:	8f 81       	ldd	r24, Y+7	; 0x07
    4dde:	98 85       	ldd	r25, Y+8	; 0x08
    4de0:	0e 94 03 29 	call	0x5206	; 0x5206 <prvIsQueueEmpty>
    4de4:	88 23       	and	r24, r24
    4de6:	29 f1       	breq	.+74     	; 0x4e32 <xQueueGenericReceive+0x18a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4de8:	ef 81       	ldd	r30, Y+7	; 0x07
    4dea:	f8 85       	ldd	r31, Y+8	; 0x08
    4dec:	80 81       	ld	r24, Z
    4dee:	91 81       	ldd	r25, Z+1	; 0x01
    4df0:	00 97       	sbiw	r24, 0x00	; 0
    4df2:	59 f4       	brne	.+22     	; 0x4e0a <xQueueGenericReceive+0x162>
					{
						portENTER_CRITICAL();
    4df4:	0f b6       	in	r0, 0x3f	; 63
    4df6:	f8 94       	cli
    4df8:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    4dfa:	ef 81       	ldd	r30, Y+7	; 0x07
    4dfc:	f8 85       	ldd	r31, Y+8	; 0x08
    4dfe:	82 81       	ldd	r24, Z+2	; 0x02
    4e00:	93 81       	ldd	r25, Z+3	; 0x03
    4e02:	0e 94 70 30 	call	0x60e0	; 0x60e0 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    4e06:	0f 90       	pop	r0
    4e08:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    4e0a:	8f 81       	ldd	r24, Y+7	; 0x07
    4e0c:	98 85       	ldd	r25, Y+8	; 0x08
    4e0e:	41 96       	adiw	r24, 0x11	; 17
    4e10:	2b 85       	ldd	r18, Y+11	; 0x0b
    4e12:	3c 85       	ldd	r19, Y+12	; 0x0c
    4e14:	b9 01       	movw	r22, r18
    4e16:	0e 94 b1 2d 	call	0x5b62	; 0x5b62 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    4e1a:	8f 81       	ldd	r24, Y+7	; 0x07
    4e1c:	98 85       	ldd	r25, Y+8	; 0x08
    4e1e:	0e 94 af 28 	call	0x515e	; 0x515e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    4e22:	0e 94 b7 2b 	call	0x576e	; 0x576e <xTaskResumeAll>
    4e26:	88 23       	and	r24, r24
    4e28:	09 f0       	breq	.+2      	; 0x4e2c <xQueueGenericReceive+0x184>
    4e2a:	50 cf       	rjmp	.-352    	; 0x4ccc <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    4e2c:	0e 94 43 23 	call	0x4686	; 0x4686 <vPortYield>
    4e30:	4d cf       	rjmp	.-358    	; 0x4ccc <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    4e32:	8f 81       	ldd	r24, Y+7	; 0x07
    4e34:	98 85       	ldd	r25, Y+8	; 0x08
    4e36:	0e 94 af 28 	call	0x515e	; 0x515e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    4e3a:	0e 94 b7 2b 	call	0x576e	; 0x576e <xTaskResumeAll>
    4e3e:	46 cf       	rjmp	.-372    	; 0x4ccc <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    4e40:	8f 81       	ldd	r24, Y+7	; 0x07
    4e42:	98 85       	ldd	r25, Y+8	; 0x08
    4e44:	0e 94 af 28 	call	0x515e	; 0x515e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    4e48:	0e 94 b7 2b 	call	0x576e	; 0x576e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    4e4c:	1e 86       	std	Y+14, r1	; 0x0e
    4e4e:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    4e50:	2e 96       	adiw	r28, 0x0e	; 14
    4e52:	0f b6       	in	r0, 0x3f	; 63
    4e54:	f8 94       	cli
    4e56:	de bf       	out	0x3e, r29	; 62
    4e58:	0f be       	out	0x3f, r0	; 63
    4e5a:	cd bf       	out	0x3d, r28	; 61
    4e5c:	cf 91       	pop	r28
    4e5e:	df 91       	pop	r29
    4e60:	08 95       	ret

00004e62 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    4e62:	df 93       	push	r29
    4e64:	cf 93       	push	r28
    4e66:	cd b7       	in	r28, 0x3d	; 61
    4e68:	de b7       	in	r29, 0x3e	; 62
    4e6a:	28 97       	sbiw	r28, 0x08	; 8
    4e6c:	0f b6       	in	r0, 0x3f	; 63
    4e6e:	f8 94       	cli
    4e70:	de bf       	out	0x3e, r29	; 62
    4e72:	0f be       	out	0x3f, r0	; 63
    4e74:	cd bf       	out	0x3d, r28	; 61
    4e76:	9c 83       	std	Y+4, r25	; 0x04
    4e78:	8b 83       	std	Y+3, r24	; 0x03
    4e7a:	7e 83       	std	Y+6, r23	; 0x06
    4e7c:	6d 83       	std	Y+5, r22	; 0x05
    4e7e:	58 87       	std	Y+8, r21	; 0x08
    4e80:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4e82:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    4e84:	eb 81       	ldd	r30, Y+3	; 0x03
    4e86:	fc 81       	ldd	r31, Y+4	; 0x04
    4e88:	82 8d       	ldd	r24, Z+26	; 0x1a
    4e8a:	88 23       	and	r24, r24
    4e8c:	71 f1       	breq	.+92     	; 0x4eea <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    4e8e:	8b 81       	ldd	r24, Y+3	; 0x03
    4e90:	9c 81       	ldd	r25, Y+4	; 0x04
    4e92:	2d 81       	ldd	r18, Y+5	; 0x05
    4e94:	3e 81       	ldd	r19, Y+6	; 0x06
    4e96:	b9 01       	movw	r22, r18
    4e98:	0e 94 67 28 	call	0x50ce	; 0x50ce <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    4e9c:	eb 81       	ldd	r30, Y+3	; 0x03
    4e9e:	fc 81       	ldd	r31, Y+4	; 0x04
    4ea0:	82 8d       	ldd	r24, Z+26	; 0x1a
    4ea2:	81 50       	subi	r24, 0x01	; 1
    4ea4:	eb 81       	ldd	r30, Y+3	; 0x03
    4ea6:	fc 81       	ldd	r31, Y+4	; 0x04
    4ea8:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    4eaa:	eb 81       	ldd	r30, Y+3	; 0x03
    4eac:	fc 81       	ldd	r31, Y+4	; 0x04
    4eae:	85 8d       	ldd	r24, Z+29	; 0x1d
    4eb0:	8f 3f       	cpi	r24, 0xFF	; 255
    4eb2:	89 f4       	brne	.+34     	; 0x4ed6 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4eb4:	eb 81       	ldd	r30, Y+3	; 0x03
    4eb6:	fc 81       	ldd	r31, Y+4	; 0x04
    4eb8:	80 85       	ldd	r24, Z+8	; 0x08
    4eba:	88 23       	and	r24, r24
    4ebc:	99 f0       	breq	.+38     	; 0x4ee4 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    4ec0:	9c 81       	ldd	r25, Y+4	; 0x04
    4ec2:	08 96       	adiw	r24, 0x08	; 8
    4ec4:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <xTaskRemoveFromEventList>
    4ec8:	88 23       	and	r24, r24
    4eca:	61 f0       	breq	.+24     	; 0x4ee4 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    4ecc:	ef 81       	ldd	r30, Y+7	; 0x07
    4ece:	f8 85       	ldd	r31, Y+8	; 0x08
    4ed0:	81 e0       	ldi	r24, 0x01	; 1
    4ed2:	80 83       	st	Z, r24
    4ed4:	07 c0       	rjmp	.+14     	; 0x4ee4 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    4ed6:	eb 81       	ldd	r30, Y+3	; 0x03
    4ed8:	fc 81       	ldd	r31, Y+4	; 0x04
    4eda:	85 8d       	ldd	r24, Z+29	; 0x1d
    4edc:	8f 5f       	subi	r24, 0xFF	; 255
    4ede:	eb 81       	ldd	r30, Y+3	; 0x03
    4ee0:	fc 81       	ldd	r31, Y+4	; 0x04
    4ee2:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    4ee4:	81 e0       	ldi	r24, 0x01	; 1
    4ee6:	8a 83       	std	Y+2, r24	; 0x02
    4ee8:	01 c0       	rjmp	.+2      	; 0x4eec <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    4eea:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4eec:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4eee:	28 96       	adiw	r28, 0x08	; 8
    4ef0:	0f b6       	in	r0, 0x3f	; 63
    4ef2:	f8 94       	cli
    4ef4:	de bf       	out	0x3e, r29	; 62
    4ef6:	0f be       	out	0x3f, r0	; 63
    4ef8:	cd bf       	out	0x3d, r28	; 61
    4efa:	cf 91       	pop	r28
    4efc:	df 91       	pop	r29
    4efe:	08 95       	ret

00004f00 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    4f00:	df 93       	push	r29
    4f02:	cf 93       	push	r28
    4f04:	00 d0       	rcall	.+0      	; 0x4f06 <uxQueueMessagesWaiting+0x6>
    4f06:	0f 92       	push	r0
    4f08:	cd b7       	in	r28, 0x3d	; 61
    4f0a:	de b7       	in	r29, 0x3e	; 62
    4f0c:	9b 83       	std	Y+3, r25	; 0x03
    4f0e:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    4f10:	0f b6       	in	r0, 0x3f	; 63
    4f12:	f8 94       	cli
    4f14:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    4f16:	ea 81       	ldd	r30, Y+2	; 0x02
    4f18:	fb 81       	ldd	r31, Y+3	; 0x03
    4f1a:	82 8d       	ldd	r24, Z+26	; 0x1a
    4f1c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    4f1e:	0f 90       	pop	r0
    4f20:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    4f22:	89 81       	ldd	r24, Y+1	; 0x01
}
    4f24:	0f 90       	pop	r0
    4f26:	0f 90       	pop	r0
    4f28:	0f 90       	pop	r0
    4f2a:	cf 91       	pop	r28
    4f2c:	df 91       	pop	r29
    4f2e:	08 95       	ret

00004f30 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    4f30:	df 93       	push	r29
    4f32:	cf 93       	push	r28
    4f34:	00 d0       	rcall	.+0      	; 0x4f36 <uxQueueMessagesWaitingFromISR+0x6>
    4f36:	0f 92       	push	r0
    4f38:	cd b7       	in	r28, 0x3d	; 61
    4f3a:	de b7       	in	r29, 0x3e	; 62
    4f3c:	9b 83       	std	Y+3, r25	; 0x03
    4f3e:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    4f40:	ea 81       	ldd	r30, Y+2	; 0x02
    4f42:	fb 81       	ldd	r31, Y+3	; 0x03
    4f44:	82 8d       	ldd	r24, Z+26	; 0x1a
    4f46:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    4f48:	89 81       	ldd	r24, Y+1	; 0x01
}
    4f4a:	0f 90       	pop	r0
    4f4c:	0f 90       	pop	r0
    4f4e:	0f 90       	pop	r0
    4f50:	cf 91       	pop	r28
    4f52:	df 91       	pop	r29
    4f54:	08 95       	ret

00004f56 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    4f56:	df 93       	push	r29
    4f58:	cf 93       	push	r28
    4f5a:	00 d0       	rcall	.+0      	; 0x4f5c <vQueueDelete+0x6>
    4f5c:	cd b7       	in	r28, 0x3d	; 61
    4f5e:	de b7       	in	r29, 0x3e	; 62
    4f60:	9a 83       	std	Y+2, r25	; 0x02
    4f62:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    4f64:	e9 81       	ldd	r30, Y+1	; 0x01
    4f66:	fa 81       	ldd	r31, Y+2	; 0x02
    4f68:	80 81       	ld	r24, Z
    4f6a:	91 81       	ldd	r25, Z+1	; 0x01
    4f6c:	0e 94 23 20 	call	0x4046	; 0x4046 <vPortFree>
	vPortFree( pxQueue );
    4f70:	89 81       	ldd	r24, Y+1	; 0x01
    4f72:	9a 81       	ldd	r25, Y+2	; 0x02
    4f74:	0e 94 23 20 	call	0x4046	; 0x4046 <vPortFree>
}
    4f78:	0f 90       	pop	r0
    4f7a:	0f 90       	pop	r0
    4f7c:	cf 91       	pop	r28
    4f7e:	df 91       	pop	r29
    4f80:	08 95       	ret

00004f82 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    4f82:	df 93       	push	r29
    4f84:	cf 93       	push	r28
    4f86:	00 d0       	rcall	.+0      	; 0x4f88 <prvCopyDataToQueue+0x6>
    4f88:	00 d0       	rcall	.+0      	; 0x4f8a <prvCopyDataToQueue+0x8>
    4f8a:	0f 92       	push	r0
    4f8c:	cd b7       	in	r28, 0x3d	; 61
    4f8e:	de b7       	in	r29, 0x3e	; 62
    4f90:	9a 83       	std	Y+2, r25	; 0x02
    4f92:	89 83       	std	Y+1, r24	; 0x01
    4f94:	7c 83       	std	Y+4, r23	; 0x04
    4f96:	6b 83       	std	Y+3, r22	; 0x03
    4f98:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    4f9a:	e9 81       	ldd	r30, Y+1	; 0x01
    4f9c:	fa 81       	ldd	r31, Y+2	; 0x02
    4f9e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4fa0:	88 23       	and	r24, r24
    4fa2:	91 f4       	brne	.+36     	; 0x4fc8 <prvCopyDataToQueue+0x46>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4fa4:	e9 81       	ldd	r30, Y+1	; 0x01
    4fa6:	fa 81       	ldd	r31, Y+2	; 0x02
    4fa8:	80 81       	ld	r24, Z
    4faa:	91 81       	ldd	r25, Z+1	; 0x01
    4fac:	00 97       	sbiw	r24, 0x00	; 0
    4fae:	09 f0       	breq	.+2      	; 0x4fb2 <prvCopyDataToQueue+0x30>
    4fb0:	7f c0       	rjmp	.+254    	; 0x50b0 <prvCopyDataToQueue+0x12e>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    4fb2:	e9 81       	ldd	r30, Y+1	; 0x01
    4fb4:	fa 81       	ldd	r31, Y+2	; 0x02
    4fb6:	82 81       	ldd	r24, Z+2	; 0x02
    4fb8:	93 81       	ldd	r25, Z+3	; 0x03
    4fba:	0e 94 f0 30 	call	0x61e0	; 0x61e0 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    4fbe:	e9 81       	ldd	r30, Y+1	; 0x01
    4fc0:	fa 81       	ldd	r31, Y+2	; 0x02
    4fc2:	13 82       	std	Z+3, r1	; 0x03
    4fc4:	12 82       	std	Z+2, r1	; 0x02
    4fc6:	74 c0       	rjmp	.+232    	; 0x50b0 <prvCopyDataToQueue+0x12e>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    4fc8:	8d 81       	ldd	r24, Y+5	; 0x05
    4fca:	88 23       	and	r24, r24
    4fcc:	99 f5       	brne	.+102    	; 0x5034 <prvCopyDataToQueue+0xb2>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    4fce:	e9 81       	ldd	r30, Y+1	; 0x01
    4fd0:	fa 81       	ldd	r31, Y+2	; 0x02
    4fd2:	64 81       	ldd	r22, Z+4	; 0x04
    4fd4:	75 81       	ldd	r23, Z+5	; 0x05
    4fd6:	e9 81       	ldd	r30, Y+1	; 0x01
    4fd8:	fa 81       	ldd	r31, Y+2	; 0x02
    4fda:	84 8d       	ldd	r24, Z+28	; 0x1c
    4fdc:	48 2f       	mov	r20, r24
    4fde:	50 e0       	ldi	r21, 0x00	; 0
    4fe0:	2b 81       	ldd	r18, Y+3	; 0x03
    4fe2:	3c 81       	ldd	r19, Y+4	; 0x04
    4fe4:	cb 01       	movw	r24, r22
    4fe6:	b9 01       	movw	r22, r18
    4fe8:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    4fec:	e9 81       	ldd	r30, Y+1	; 0x01
    4fee:	fa 81       	ldd	r31, Y+2	; 0x02
    4ff0:	24 81       	ldd	r18, Z+4	; 0x04
    4ff2:	35 81       	ldd	r19, Z+5	; 0x05
    4ff4:	e9 81       	ldd	r30, Y+1	; 0x01
    4ff6:	fa 81       	ldd	r31, Y+2	; 0x02
    4ff8:	84 8d       	ldd	r24, Z+28	; 0x1c
    4ffa:	88 2f       	mov	r24, r24
    4ffc:	90 e0       	ldi	r25, 0x00	; 0
    4ffe:	82 0f       	add	r24, r18
    5000:	93 1f       	adc	r25, r19
    5002:	e9 81       	ldd	r30, Y+1	; 0x01
    5004:	fa 81       	ldd	r31, Y+2	; 0x02
    5006:	95 83       	std	Z+5, r25	; 0x05
    5008:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    500a:	e9 81       	ldd	r30, Y+1	; 0x01
    500c:	fa 81       	ldd	r31, Y+2	; 0x02
    500e:	24 81       	ldd	r18, Z+4	; 0x04
    5010:	35 81       	ldd	r19, Z+5	; 0x05
    5012:	e9 81       	ldd	r30, Y+1	; 0x01
    5014:	fa 81       	ldd	r31, Y+2	; 0x02
    5016:	82 81       	ldd	r24, Z+2	; 0x02
    5018:	93 81       	ldd	r25, Z+3	; 0x03
    501a:	28 17       	cp	r18, r24
    501c:	39 07       	cpc	r19, r25
    501e:	08 f4       	brcc	.+2      	; 0x5022 <prvCopyDataToQueue+0xa0>
    5020:	47 c0       	rjmp	.+142    	; 0x50b0 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    5022:	e9 81       	ldd	r30, Y+1	; 0x01
    5024:	fa 81       	ldd	r31, Y+2	; 0x02
    5026:	80 81       	ld	r24, Z
    5028:	91 81       	ldd	r25, Z+1	; 0x01
    502a:	e9 81       	ldd	r30, Y+1	; 0x01
    502c:	fa 81       	ldd	r31, Y+2	; 0x02
    502e:	95 83       	std	Z+5, r25	; 0x05
    5030:	84 83       	std	Z+4, r24	; 0x04
    5032:	3e c0       	rjmp	.+124    	; 0x50b0 <prvCopyDataToQueue+0x12e>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    5034:	e9 81       	ldd	r30, Y+1	; 0x01
    5036:	fa 81       	ldd	r31, Y+2	; 0x02
    5038:	66 81       	ldd	r22, Z+6	; 0x06
    503a:	77 81       	ldd	r23, Z+7	; 0x07
    503c:	e9 81       	ldd	r30, Y+1	; 0x01
    503e:	fa 81       	ldd	r31, Y+2	; 0x02
    5040:	84 8d       	ldd	r24, Z+28	; 0x1c
    5042:	48 2f       	mov	r20, r24
    5044:	50 e0       	ldi	r21, 0x00	; 0
    5046:	2b 81       	ldd	r18, Y+3	; 0x03
    5048:	3c 81       	ldd	r19, Y+4	; 0x04
    504a:	cb 01       	movw	r24, r22
    504c:	b9 01       	movw	r22, r18
    504e:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    5052:	e9 81       	ldd	r30, Y+1	; 0x01
    5054:	fa 81       	ldd	r31, Y+2	; 0x02
    5056:	26 81       	ldd	r18, Z+6	; 0x06
    5058:	37 81       	ldd	r19, Z+7	; 0x07
    505a:	e9 81       	ldd	r30, Y+1	; 0x01
    505c:	fa 81       	ldd	r31, Y+2	; 0x02
    505e:	84 8d       	ldd	r24, Z+28	; 0x1c
    5060:	88 2f       	mov	r24, r24
    5062:	90 e0       	ldi	r25, 0x00	; 0
    5064:	90 95       	com	r25
    5066:	81 95       	neg	r24
    5068:	9f 4f       	sbci	r25, 0xFF	; 255
    506a:	82 0f       	add	r24, r18
    506c:	93 1f       	adc	r25, r19
    506e:	e9 81       	ldd	r30, Y+1	; 0x01
    5070:	fa 81       	ldd	r31, Y+2	; 0x02
    5072:	97 83       	std	Z+7, r25	; 0x07
    5074:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    5076:	e9 81       	ldd	r30, Y+1	; 0x01
    5078:	fa 81       	ldd	r31, Y+2	; 0x02
    507a:	26 81       	ldd	r18, Z+6	; 0x06
    507c:	37 81       	ldd	r19, Z+7	; 0x07
    507e:	e9 81       	ldd	r30, Y+1	; 0x01
    5080:	fa 81       	ldd	r31, Y+2	; 0x02
    5082:	80 81       	ld	r24, Z
    5084:	91 81       	ldd	r25, Z+1	; 0x01
    5086:	28 17       	cp	r18, r24
    5088:	39 07       	cpc	r19, r25
    508a:	90 f4       	brcc	.+36     	; 0x50b0 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    508c:	e9 81       	ldd	r30, Y+1	; 0x01
    508e:	fa 81       	ldd	r31, Y+2	; 0x02
    5090:	22 81       	ldd	r18, Z+2	; 0x02
    5092:	33 81       	ldd	r19, Z+3	; 0x03
    5094:	e9 81       	ldd	r30, Y+1	; 0x01
    5096:	fa 81       	ldd	r31, Y+2	; 0x02
    5098:	84 8d       	ldd	r24, Z+28	; 0x1c
    509a:	88 2f       	mov	r24, r24
    509c:	90 e0       	ldi	r25, 0x00	; 0
    509e:	90 95       	com	r25
    50a0:	81 95       	neg	r24
    50a2:	9f 4f       	sbci	r25, 0xFF	; 255
    50a4:	82 0f       	add	r24, r18
    50a6:	93 1f       	adc	r25, r19
    50a8:	e9 81       	ldd	r30, Y+1	; 0x01
    50aa:	fa 81       	ldd	r31, Y+2	; 0x02
    50ac:	97 83       	std	Z+7, r25	; 0x07
    50ae:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    50b0:	e9 81       	ldd	r30, Y+1	; 0x01
    50b2:	fa 81       	ldd	r31, Y+2	; 0x02
    50b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    50b6:	8f 5f       	subi	r24, 0xFF	; 255
    50b8:	e9 81       	ldd	r30, Y+1	; 0x01
    50ba:	fa 81       	ldd	r31, Y+2	; 0x02
    50bc:	82 8f       	std	Z+26, r24	; 0x1a
}
    50be:	0f 90       	pop	r0
    50c0:	0f 90       	pop	r0
    50c2:	0f 90       	pop	r0
    50c4:	0f 90       	pop	r0
    50c6:	0f 90       	pop	r0
    50c8:	cf 91       	pop	r28
    50ca:	df 91       	pop	r29
    50cc:	08 95       	ret

000050ce <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    50ce:	df 93       	push	r29
    50d0:	cf 93       	push	r28
    50d2:	00 d0       	rcall	.+0      	; 0x50d4 <prvCopyDataFromQueue+0x6>
    50d4:	00 d0       	rcall	.+0      	; 0x50d6 <prvCopyDataFromQueue+0x8>
    50d6:	cd b7       	in	r28, 0x3d	; 61
    50d8:	de b7       	in	r29, 0x3e	; 62
    50da:	9a 83       	std	Y+2, r25	; 0x02
    50dc:	89 83       	std	Y+1, r24	; 0x01
    50de:	7c 83       	std	Y+4, r23	; 0x04
    50e0:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    50e2:	e9 81       	ldd	r30, Y+1	; 0x01
    50e4:	fa 81       	ldd	r31, Y+2	; 0x02
    50e6:	80 81       	ld	r24, Z
    50e8:	91 81       	ldd	r25, Z+1	; 0x01
    50ea:	00 97       	sbiw	r24, 0x00	; 0
    50ec:	89 f1       	breq	.+98     	; 0x5150 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    50ee:	e9 81       	ldd	r30, Y+1	; 0x01
    50f0:	fa 81       	ldd	r31, Y+2	; 0x02
    50f2:	26 81       	ldd	r18, Z+6	; 0x06
    50f4:	37 81       	ldd	r19, Z+7	; 0x07
    50f6:	e9 81       	ldd	r30, Y+1	; 0x01
    50f8:	fa 81       	ldd	r31, Y+2	; 0x02
    50fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    50fc:	88 2f       	mov	r24, r24
    50fe:	90 e0       	ldi	r25, 0x00	; 0
    5100:	82 0f       	add	r24, r18
    5102:	93 1f       	adc	r25, r19
    5104:	e9 81       	ldd	r30, Y+1	; 0x01
    5106:	fa 81       	ldd	r31, Y+2	; 0x02
    5108:	97 83       	std	Z+7, r25	; 0x07
    510a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    510c:	e9 81       	ldd	r30, Y+1	; 0x01
    510e:	fa 81       	ldd	r31, Y+2	; 0x02
    5110:	26 81       	ldd	r18, Z+6	; 0x06
    5112:	37 81       	ldd	r19, Z+7	; 0x07
    5114:	e9 81       	ldd	r30, Y+1	; 0x01
    5116:	fa 81       	ldd	r31, Y+2	; 0x02
    5118:	82 81       	ldd	r24, Z+2	; 0x02
    511a:	93 81       	ldd	r25, Z+3	; 0x03
    511c:	28 17       	cp	r18, r24
    511e:	39 07       	cpc	r19, r25
    5120:	40 f0       	brcs	.+16     	; 0x5132 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    5122:	e9 81       	ldd	r30, Y+1	; 0x01
    5124:	fa 81       	ldd	r31, Y+2	; 0x02
    5126:	80 81       	ld	r24, Z
    5128:	91 81       	ldd	r25, Z+1	; 0x01
    512a:	e9 81       	ldd	r30, Y+1	; 0x01
    512c:	fa 81       	ldd	r31, Y+2	; 0x02
    512e:	97 83       	std	Z+7, r25	; 0x07
    5130:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    5132:	e9 81       	ldd	r30, Y+1	; 0x01
    5134:	fa 81       	ldd	r31, Y+2	; 0x02
    5136:	46 81       	ldd	r20, Z+6	; 0x06
    5138:	57 81       	ldd	r21, Z+7	; 0x07
    513a:	e9 81       	ldd	r30, Y+1	; 0x01
    513c:	fa 81       	ldd	r31, Y+2	; 0x02
    513e:	84 8d       	ldd	r24, Z+28	; 0x1c
    5140:	28 2f       	mov	r18, r24
    5142:	30 e0       	ldi	r19, 0x00	; 0
    5144:	8b 81       	ldd	r24, Y+3	; 0x03
    5146:	9c 81       	ldd	r25, Y+4	; 0x04
    5148:	ba 01       	movw	r22, r20
    514a:	a9 01       	movw	r20, r18
    514c:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <memcpy>
	}
}
    5150:	0f 90       	pop	r0
    5152:	0f 90       	pop	r0
    5154:	0f 90       	pop	r0
    5156:	0f 90       	pop	r0
    5158:	cf 91       	pop	r28
    515a:	df 91       	pop	r29
    515c:	08 95       	ret

0000515e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    515e:	df 93       	push	r29
    5160:	cf 93       	push	r28
    5162:	00 d0       	rcall	.+0      	; 0x5164 <prvUnlockQueue+0x6>
    5164:	cd b7       	in	r28, 0x3d	; 61
    5166:	de b7       	in	r29, 0x3e	; 62
    5168:	9a 83       	std	Y+2, r25	; 0x02
    516a:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    516c:	0f b6       	in	r0, 0x3f	; 63
    516e:	f8 94       	cli
    5170:	0f 92       	push	r0
    5172:	15 c0       	rjmp	.+42     	; 0x519e <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5174:	e9 81       	ldd	r30, Y+1	; 0x01
    5176:	fa 81       	ldd	r31, Y+2	; 0x02
    5178:	81 89       	ldd	r24, Z+17	; 0x11
    517a:	88 23       	and	r24, r24
    517c:	a9 f0       	breq	.+42     	; 0x51a8 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    517e:	89 81       	ldd	r24, Y+1	; 0x01
    5180:	9a 81       	ldd	r25, Y+2	; 0x02
    5182:	41 96       	adiw	r24, 0x11	; 17
    5184:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <xTaskRemoveFromEventList>
    5188:	88 23       	and	r24, r24
    518a:	11 f0       	breq	.+4      	; 0x5190 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    518c:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    5190:	e9 81       	ldd	r30, Y+1	; 0x01
    5192:	fa 81       	ldd	r31, Y+2	; 0x02
    5194:	86 8d       	ldd	r24, Z+30	; 0x1e
    5196:	81 50       	subi	r24, 0x01	; 1
    5198:	e9 81       	ldd	r30, Y+1	; 0x01
    519a:	fa 81       	ldd	r31, Y+2	; 0x02
    519c:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    519e:	e9 81       	ldd	r30, Y+1	; 0x01
    51a0:	fa 81       	ldd	r31, Y+2	; 0x02
    51a2:	86 8d       	ldd	r24, Z+30	; 0x1e
    51a4:	18 16       	cp	r1, r24
    51a6:	34 f3       	brlt	.-52     	; 0x5174 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    51a8:	e9 81       	ldd	r30, Y+1	; 0x01
    51aa:	fa 81       	ldd	r31, Y+2	; 0x02
    51ac:	8f ef       	ldi	r24, 0xFF	; 255
    51ae:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    51b0:	0f 90       	pop	r0
    51b2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    51b4:	0f b6       	in	r0, 0x3f	; 63
    51b6:	f8 94       	cli
    51b8:	0f 92       	push	r0
    51ba:	15 c0       	rjmp	.+42     	; 0x51e6 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    51bc:	e9 81       	ldd	r30, Y+1	; 0x01
    51be:	fa 81       	ldd	r31, Y+2	; 0x02
    51c0:	80 85       	ldd	r24, Z+8	; 0x08
    51c2:	88 23       	and	r24, r24
    51c4:	a9 f0       	breq	.+42     	; 0x51f0 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    51c6:	89 81       	ldd	r24, Y+1	; 0x01
    51c8:	9a 81       	ldd	r25, Y+2	; 0x02
    51ca:	08 96       	adiw	r24, 0x08	; 8
    51cc:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <xTaskRemoveFromEventList>
    51d0:	88 23       	and	r24, r24
    51d2:	11 f0       	breq	.+4      	; 0x51d8 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    51d4:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    51d8:	e9 81       	ldd	r30, Y+1	; 0x01
    51da:	fa 81       	ldd	r31, Y+2	; 0x02
    51dc:	85 8d       	ldd	r24, Z+29	; 0x1d
    51de:	81 50       	subi	r24, 0x01	; 1
    51e0:	e9 81       	ldd	r30, Y+1	; 0x01
    51e2:	fa 81       	ldd	r31, Y+2	; 0x02
    51e4:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    51e6:	e9 81       	ldd	r30, Y+1	; 0x01
    51e8:	fa 81       	ldd	r31, Y+2	; 0x02
    51ea:	85 8d       	ldd	r24, Z+29	; 0x1d
    51ec:	18 16       	cp	r1, r24
    51ee:	34 f3       	brlt	.-52     	; 0x51bc <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    51f0:	e9 81       	ldd	r30, Y+1	; 0x01
    51f2:	fa 81       	ldd	r31, Y+2	; 0x02
    51f4:	8f ef       	ldi	r24, 0xFF	; 255
    51f6:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    51f8:	0f 90       	pop	r0
    51fa:	0f be       	out	0x3f, r0	; 63
}
    51fc:	0f 90       	pop	r0
    51fe:	0f 90       	pop	r0
    5200:	cf 91       	pop	r28
    5202:	df 91       	pop	r29
    5204:	08 95       	ret

00005206 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    5206:	df 93       	push	r29
    5208:	cf 93       	push	r28
    520a:	00 d0       	rcall	.+0      	; 0x520c <prvIsQueueEmpty+0x6>
    520c:	0f 92       	push	r0
    520e:	cd b7       	in	r28, 0x3d	; 61
    5210:	de b7       	in	r29, 0x3e	; 62
    5212:	9b 83       	std	Y+3, r25	; 0x03
    5214:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    5216:	0f b6       	in	r0, 0x3f	; 63
    5218:	f8 94       	cli
    521a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    521c:	ea 81       	ldd	r30, Y+2	; 0x02
    521e:	fb 81       	ldd	r31, Y+3	; 0x03
    5220:	82 8d       	ldd	r24, Z+26	; 0x1a
    5222:	19 82       	std	Y+1, r1	; 0x01
    5224:	88 23       	and	r24, r24
    5226:	11 f4       	brne	.+4      	; 0x522c <prvIsQueueEmpty+0x26>
    5228:	81 e0       	ldi	r24, 0x01	; 1
    522a:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    522c:	0f 90       	pop	r0
    522e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5230:	89 81       	ldd	r24, Y+1	; 0x01
}
    5232:	0f 90       	pop	r0
    5234:	0f 90       	pop	r0
    5236:	0f 90       	pop	r0
    5238:	cf 91       	pop	r28
    523a:	df 91       	pop	r29
    523c:	08 95       	ret

0000523e <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    523e:	df 93       	push	r29
    5240:	cf 93       	push	r28
    5242:	00 d0       	rcall	.+0      	; 0x5244 <xQueueIsQueueEmptyFromISR+0x6>
    5244:	0f 92       	push	r0
    5246:	cd b7       	in	r28, 0x3d	; 61
    5248:	de b7       	in	r29, 0x3e	; 62
    524a:	9b 83       	std	Y+3, r25	; 0x03
    524c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    524e:	ea 81       	ldd	r30, Y+2	; 0x02
    5250:	fb 81       	ldd	r31, Y+3	; 0x03
    5252:	82 8d       	ldd	r24, Z+26	; 0x1a
    5254:	19 82       	std	Y+1, r1	; 0x01
    5256:	88 23       	and	r24, r24
    5258:	11 f4       	brne	.+4      	; 0x525e <xQueueIsQueueEmptyFromISR+0x20>
    525a:	81 e0       	ldi	r24, 0x01	; 1
    525c:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    525e:	89 81       	ldd	r24, Y+1	; 0x01
}
    5260:	0f 90       	pop	r0
    5262:	0f 90       	pop	r0
    5264:	0f 90       	pop	r0
    5266:	cf 91       	pop	r28
    5268:	df 91       	pop	r29
    526a:	08 95       	ret

0000526c <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    526c:	df 93       	push	r29
    526e:	cf 93       	push	r28
    5270:	00 d0       	rcall	.+0      	; 0x5272 <prvIsQueueFull+0x6>
    5272:	0f 92       	push	r0
    5274:	cd b7       	in	r28, 0x3d	; 61
    5276:	de b7       	in	r29, 0x3e	; 62
    5278:	9b 83       	std	Y+3, r25	; 0x03
    527a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    527c:	0f b6       	in	r0, 0x3f	; 63
    527e:	f8 94       	cli
    5280:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    5282:	ea 81       	ldd	r30, Y+2	; 0x02
    5284:	fb 81       	ldd	r31, Y+3	; 0x03
    5286:	92 8d       	ldd	r25, Z+26	; 0x1a
    5288:	ea 81       	ldd	r30, Y+2	; 0x02
    528a:	fb 81       	ldd	r31, Y+3	; 0x03
    528c:	83 8d       	ldd	r24, Z+27	; 0x1b
    528e:	19 82       	std	Y+1, r1	; 0x01
    5290:	98 17       	cp	r25, r24
    5292:	11 f4       	brne	.+4      	; 0x5298 <prvIsQueueFull+0x2c>
    5294:	81 e0       	ldi	r24, 0x01	; 1
    5296:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    5298:	0f 90       	pop	r0
    529a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    529c:	89 81       	ldd	r24, Y+1	; 0x01
}
    529e:	0f 90       	pop	r0
    52a0:	0f 90       	pop	r0
    52a2:	0f 90       	pop	r0
    52a4:	cf 91       	pop	r28
    52a6:	df 91       	pop	r29
    52a8:	08 95       	ret

000052aa <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    52aa:	df 93       	push	r29
    52ac:	cf 93       	push	r28
    52ae:	00 d0       	rcall	.+0      	; 0x52b0 <xQueueIsQueueFullFromISR+0x6>
    52b0:	0f 92       	push	r0
    52b2:	cd b7       	in	r28, 0x3d	; 61
    52b4:	de b7       	in	r29, 0x3e	; 62
    52b6:	9b 83       	std	Y+3, r25	; 0x03
    52b8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    52ba:	ea 81       	ldd	r30, Y+2	; 0x02
    52bc:	fb 81       	ldd	r31, Y+3	; 0x03
    52be:	92 8d       	ldd	r25, Z+26	; 0x1a
    52c0:	ea 81       	ldd	r30, Y+2	; 0x02
    52c2:	fb 81       	ldd	r31, Y+3	; 0x03
    52c4:	83 8d       	ldd	r24, Z+27	; 0x1b
    52c6:	19 82       	std	Y+1, r1	; 0x01
    52c8:	98 17       	cp	r25, r24
    52ca:	11 f4       	brne	.+4      	; 0x52d0 <xQueueIsQueueFullFromISR+0x26>
    52cc:	81 e0       	ldi	r24, 0x01	; 1
    52ce:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    52d0:	89 81       	ldd	r24, Y+1	; 0x01
}
    52d2:	0f 90       	pop	r0
    52d4:	0f 90       	pop	r0
    52d6:	0f 90       	pop	r0
    52d8:	cf 91       	pop	r28
    52da:	df 91       	pop	r29
    52dc:	08 95       	ret

000052de <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    52de:	af 92       	push	r10
    52e0:	bf 92       	push	r11
    52e2:	cf 92       	push	r12
    52e4:	df 92       	push	r13
    52e6:	ef 92       	push	r14
    52e8:	ff 92       	push	r15
    52ea:	0f 93       	push	r16
    52ec:	1f 93       	push	r17
    52ee:	df 93       	push	r29
    52f0:	cf 93       	push	r28
    52f2:	cd b7       	in	r28, 0x3d	; 61
    52f4:	de b7       	in	r29, 0x3e	; 62
    52f6:	64 97       	sbiw	r28, 0x14	; 20
    52f8:	0f b6       	in	r0, 0x3f	; 63
    52fa:	f8 94       	cli
    52fc:	de bf       	out	0x3e, r29	; 62
    52fe:	0f be       	out	0x3f, r0	; 63
    5300:	cd bf       	out	0x3d, r28	; 61
    5302:	9f 83       	std	Y+7, r25	; 0x07
    5304:	8e 83       	std	Y+6, r24	; 0x06
    5306:	79 87       	std	Y+9, r23	; 0x09
    5308:	68 87       	std	Y+8, r22	; 0x08
    530a:	5b 87       	std	Y+11, r21	; 0x0b
    530c:	4a 87       	std	Y+10, r20	; 0x0a
    530e:	3d 87       	std	Y+13, r19	; 0x0d
    5310:	2c 87       	std	Y+12, r18	; 0x0c
    5312:	0e 87       	std	Y+14, r16	; 0x0e
    5314:	f8 8a       	std	Y+16, r15	; 0x10
    5316:	ef 86       	std	Y+15, r14	; 0x0f
    5318:	da 8a       	std	Y+18, r13	; 0x12
    531a:	c9 8a       	std	Y+17, r12	; 0x11
    531c:	bc 8a       	std	Y+20, r11	; 0x14
    531e:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    5320:	8a 85       	ldd	r24, Y+10	; 0x0a
    5322:	9b 85       	ldd	r25, Y+11	; 0x0b
    5324:	29 89       	ldd	r18, Y+17	; 0x11
    5326:	3a 89       	ldd	r19, Y+18	; 0x12
    5328:	b9 01       	movw	r22, r18
    532a:	0e 94 f8 2f 	call	0x5ff0	; 0x5ff0 <prvAllocateTCBAndStack>
    532e:	9c 83       	std	Y+4, r25	; 0x04
    5330:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    5332:	8b 81       	ldd	r24, Y+3	; 0x03
    5334:	9c 81       	ldd	r25, Y+4	; 0x04
    5336:	00 97       	sbiw	r24, 0x00	; 0
    5338:	09 f4       	brne	.+2      	; 0x533c <xTaskGenericCreate+0x5e>
    533a:	99 c0       	rjmp	.+306    	; 0x546e <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    533c:	eb 81       	ldd	r30, Y+3	; 0x03
    533e:	fc 81       	ldd	r31, Y+4	; 0x04
    5340:	27 89       	ldd	r18, Z+23	; 0x17
    5342:	30 8d       	ldd	r19, Z+24	; 0x18
    5344:	8a 85       	ldd	r24, Y+10	; 0x0a
    5346:	9b 85       	ldd	r25, Y+11	; 0x0b
    5348:	01 97       	sbiw	r24, 0x01	; 1
    534a:	82 0f       	add	r24, r18
    534c:	93 1f       	adc	r25, r19
    534e:	9a 83       	std	Y+2, r25	; 0x02
    5350:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    5352:	8b 81       	ldd	r24, Y+3	; 0x03
    5354:	9c 81       	ldd	r25, Y+4	; 0x04
    5356:	28 85       	ldd	r18, Y+8	; 0x08
    5358:	39 85       	ldd	r19, Y+9	; 0x09
    535a:	eb 89       	ldd	r30, Y+19	; 0x13
    535c:	fc 89       	ldd	r31, Y+20	; 0x14
    535e:	aa 85       	ldd	r26, Y+10	; 0x0a
    5360:	bb 85       	ldd	r27, Y+11	; 0x0b
    5362:	b9 01       	movw	r22, r18
    5364:	4e 85       	ldd	r20, Y+14	; 0x0e
    5366:	9f 01       	movw	r18, r30
    5368:	8d 01       	movw	r16, r26
    536a:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    536e:	89 81       	ldd	r24, Y+1	; 0x01
    5370:	9a 81       	ldd	r25, Y+2	; 0x02
    5372:	2e 81       	ldd	r18, Y+6	; 0x06
    5374:	3f 81       	ldd	r19, Y+7	; 0x07
    5376:	4c 85       	ldd	r20, Y+12	; 0x0c
    5378:	5d 85       	ldd	r21, Y+13	; 0x0d
    537a:	b9 01       	movw	r22, r18
    537c:	0e 94 84 21 	call	0x4308	; 0x4308 <pxPortInitialiseStack>
    5380:	eb 81       	ldd	r30, Y+3	; 0x03
    5382:	fc 81       	ldd	r31, Y+4	; 0x04
    5384:	91 83       	std	Z+1, r25	; 0x01
    5386:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    5388:	8f 85       	ldd	r24, Y+15	; 0x0f
    538a:	98 89       	ldd	r25, Y+16	; 0x10
    538c:	00 97       	sbiw	r24, 0x00	; 0
    538e:	31 f0       	breq	.+12     	; 0x539c <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    5390:	ef 85       	ldd	r30, Y+15	; 0x0f
    5392:	f8 89       	ldd	r31, Y+16	; 0x10
    5394:	8b 81       	ldd	r24, Y+3	; 0x03
    5396:	9c 81       	ldd	r25, Y+4	; 0x04
    5398:	91 83       	std	Z+1, r25	; 0x01
    539a:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    539c:	0f b6       	in	r0, 0x3f	; 63
    539e:	f8 94       	cli
    53a0:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    53a2:	80 91 4f 07 	lds	r24, 0x074F
    53a6:	8f 5f       	subi	r24, 0xFF	; 255
    53a8:	80 93 4f 07 	sts	0x074F, r24
			if( pxCurrentTCB == NULL )
    53ac:	80 91 4c 07 	lds	r24, 0x074C
    53b0:	90 91 4d 07 	lds	r25, 0x074D
    53b4:	00 97       	sbiw	r24, 0x00	; 0
    53b6:	69 f4       	brne	.+26     	; 0x53d2 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    53b8:	8b 81       	ldd	r24, Y+3	; 0x03
    53ba:	9c 81       	ldd	r25, Y+4	; 0x04
    53bc:	90 93 4d 07 	sts	0x074D, r25
    53c0:	80 93 4c 07 	sts	0x074C, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    53c4:	80 91 4f 07 	lds	r24, 0x074F
    53c8:	81 30       	cpi	r24, 0x01	; 1
    53ca:	a9 f4       	brne	.+42     	; 0x53f6 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    53cc:	0e 94 34 2f 	call	0x5e68	; 0x5e68 <prvInitialiseTaskLists>
    53d0:	12 c0       	rjmp	.+36     	; 0x53f6 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    53d2:	80 91 54 07 	lds	r24, 0x0754
    53d6:	88 23       	and	r24, r24
    53d8:	71 f4       	brne	.+28     	; 0x53f6 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    53da:	e0 91 4c 07 	lds	r30, 0x074C
    53de:	f0 91 4d 07 	lds	r31, 0x074D
    53e2:	96 89       	ldd	r25, Z+22	; 0x16
    53e4:	8e 85       	ldd	r24, Y+14	; 0x0e
    53e6:	89 17       	cp	r24, r25
    53e8:	30 f0       	brcs	.+12     	; 0x53f6 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    53ea:	8b 81       	ldd	r24, Y+3	; 0x03
    53ec:	9c 81       	ldd	r25, Y+4	; 0x04
    53ee:	90 93 4d 07 	sts	0x074D, r25
    53f2:	80 93 4c 07 	sts	0x074C, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    53f6:	eb 81       	ldd	r30, Y+3	; 0x03
    53f8:	fc 81       	ldd	r31, Y+4	; 0x04
    53fa:	96 89       	ldd	r25, Z+22	; 0x16
    53fc:	80 91 52 07 	lds	r24, 0x0752
    5400:	89 17       	cp	r24, r25
    5402:	28 f4       	brcc	.+10     	; 0x540e <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    5404:	eb 81       	ldd	r30, Y+3	; 0x03
    5406:	fc 81       	ldd	r31, Y+4	; 0x04
    5408:	86 89       	ldd	r24, Z+22	; 0x16
    540a:	80 93 52 07 	sts	0x0752, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    540e:	80 91 59 07 	lds	r24, 0x0759
    5412:	8f 5f       	subi	r24, 0xFF	; 255
    5414:	80 93 59 07 	sts	0x0759, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    5418:	eb 81       	ldd	r30, Y+3	; 0x03
    541a:	fc 81       	ldd	r31, Y+4	; 0x04
    541c:	96 89       	ldd	r25, Z+22	; 0x16
    541e:	80 91 53 07 	lds	r24, 0x0753
    5422:	89 17       	cp	r24, r25
    5424:	28 f4       	brcc	.+10     	; 0x5430 <xTaskGenericCreate+0x152>
    5426:	eb 81       	ldd	r30, Y+3	; 0x03
    5428:	fc 81       	ldd	r31, Y+4	; 0x04
    542a:	86 89       	ldd	r24, Z+22	; 0x16
    542c:	80 93 53 07 	sts	0x0753, r24
    5430:	eb 81       	ldd	r30, Y+3	; 0x03
    5432:	fc 81       	ldd	r31, Y+4	; 0x04
    5434:	86 89       	ldd	r24, Z+22	; 0x16
    5436:	28 2f       	mov	r18, r24
    5438:	30 e0       	ldi	r19, 0x00	; 0
    543a:	c9 01       	movw	r24, r18
    543c:	88 0f       	add	r24, r24
    543e:	99 1f       	adc	r25, r25
    5440:	88 0f       	add	r24, r24
    5442:	99 1f       	adc	r25, r25
    5444:	88 0f       	add	r24, r24
    5446:	99 1f       	adc	r25, r25
    5448:	82 0f       	add	r24, r18
    544a:	93 1f       	adc	r25, r19
    544c:	ac 01       	movw	r20, r24
    544e:	46 5a       	subi	r20, 0xA6	; 166
    5450:	58 4f       	sbci	r21, 0xF8	; 248
    5452:	8b 81       	ldd	r24, Y+3	; 0x03
    5454:	9c 81       	ldd	r25, Y+4	; 0x04
    5456:	9c 01       	movw	r18, r24
    5458:	2e 5f       	subi	r18, 0xFE	; 254
    545a:	3f 4f       	sbci	r19, 0xFF	; 255
    545c:	ca 01       	movw	r24, r20
    545e:	b9 01       	movw	r22, r18
    5460:	0e 94 83 20 	call	0x4106	; 0x4106 <vListInsertEnd>

			xReturn = pdPASS;
    5464:	81 e0       	ldi	r24, 0x01	; 1
    5466:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    5468:	0f 90       	pop	r0
    546a:	0f be       	out	0x3f, r0	; 63
    546c:	02 c0       	rjmp	.+4      	; 0x5472 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    546e:	8f ef       	ldi	r24, 0xFF	; 255
    5470:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    5472:	8d 81       	ldd	r24, Y+5	; 0x05
    5474:	81 30       	cpi	r24, 0x01	; 1
    5476:	71 f4       	brne	.+28     	; 0x5494 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    5478:	80 91 54 07 	lds	r24, 0x0754
    547c:	88 23       	and	r24, r24
    547e:	51 f0       	breq	.+20     	; 0x5494 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    5480:	e0 91 4c 07 	lds	r30, 0x074C
    5484:	f0 91 4d 07 	lds	r31, 0x074D
    5488:	96 89       	ldd	r25, Z+22	; 0x16
    548a:	8e 85       	ldd	r24, Y+14	; 0x0e
    548c:	98 17       	cp	r25, r24
    548e:	10 f4       	brcc	.+4      	; 0x5494 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    5490:	0e 94 43 23 	call	0x4686	; 0x4686 <vPortYield>
			}
		}
	}

	return xReturn;
    5494:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5496:	64 96       	adiw	r28, 0x14	; 20
    5498:	0f b6       	in	r0, 0x3f	; 63
    549a:	f8 94       	cli
    549c:	de bf       	out	0x3e, r29	; 62
    549e:	0f be       	out	0x3f, r0	; 63
    54a0:	cd bf       	out	0x3d, r28	; 61
    54a2:	cf 91       	pop	r28
    54a4:	df 91       	pop	r29
    54a6:	1f 91       	pop	r17
    54a8:	0f 91       	pop	r16
    54aa:	ff 90       	pop	r15
    54ac:	ef 90       	pop	r14
    54ae:	df 90       	pop	r13
    54b0:	cf 90       	pop	r12
    54b2:	bf 90       	pop	r11
    54b4:	af 90       	pop	r10
    54b6:	08 95       	ret

000054b8 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    54b8:	df 93       	push	r29
    54ba:	cf 93       	push	r28
    54bc:	00 d0       	rcall	.+0      	; 0x54be <vTaskDelete+0x6>
    54be:	00 d0       	rcall	.+0      	; 0x54c0 <vTaskDelete+0x8>
    54c0:	00 d0       	rcall	.+0      	; 0x54c2 <vTaskDelete+0xa>
    54c2:	cd b7       	in	r28, 0x3d	; 61
    54c4:	de b7       	in	r29, 0x3e	; 62
    54c6:	9c 83       	std	Y+4, r25	; 0x04
    54c8:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    54ca:	0f b6       	in	r0, 0x3f	; 63
    54cc:	f8 94       	cli
    54ce:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    54d0:	20 91 4c 07 	lds	r18, 0x074C
    54d4:	30 91 4d 07 	lds	r19, 0x074D
    54d8:	8b 81       	ldd	r24, Y+3	; 0x03
    54da:	9c 81       	ldd	r25, Y+4	; 0x04
    54dc:	82 17       	cp	r24, r18
    54de:	93 07       	cpc	r25, r19
    54e0:	11 f4       	brne	.+4      	; 0x54e6 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    54e2:	1c 82       	std	Y+4, r1	; 0x04
    54e4:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    54e6:	8b 81       	ldd	r24, Y+3	; 0x03
    54e8:	9c 81       	ldd	r25, Y+4	; 0x04
    54ea:	00 97       	sbiw	r24, 0x00	; 0
    54ec:	39 f4       	brne	.+14     	; 0x54fc <vTaskDelete+0x44>
    54ee:	80 91 4c 07 	lds	r24, 0x074C
    54f2:	90 91 4d 07 	lds	r25, 0x074D
    54f6:	9e 83       	std	Y+6, r25	; 0x06
    54f8:	8d 83       	std	Y+5, r24	; 0x05
    54fa:	04 c0       	rjmp	.+8      	; 0x5504 <vTaskDelete+0x4c>
    54fc:	8b 81       	ldd	r24, Y+3	; 0x03
    54fe:	9c 81       	ldd	r25, Y+4	; 0x04
    5500:	9e 83       	std	Y+6, r25	; 0x06
    5502:	8d 83       	std	Y+5, r24	; 0x05
    5504:	8d 81       	ldd	r24, Y+5	; 0x05
    5506:	9e 81       	ldd	r25, Y+6	; 0x06
    5508:	9a 83       	std	Y+2, r25	; 0x02
    550a:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    550c:	89 81       	ldd	r24, Y+1	; 0x01
    550e:	9a 81       	ldd	r25, Y+2	; 0x02
    5510:	02 96       	adiw	r24, 0x02	; 2
    5512:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    5516:	e9 81       	ldd	r30, Y+1	; 0x01
    5518:	fa 81       	ldd	r31, Y+2	; 0x02
    551a:	84 89       	ldd	r24, Z+20	; 0x14
    551c:	95 89       	ldd	r25, Z+21	; 0x15
    551e:	00 97       	sbiw	r24, 0x00	; 0
    5520:	29 f0       	breq	.+10     	; 0x552c <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    5522:	89 81       	ldd	r24, Y+1	; 0x01
    5524:	9a 81       	ldd	r25, Y+2	; 0x02
    5526:	0c 96       	adiw	r24, 0x0c	; 12
    5528:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    552c:	89 81       	ldd	r24, Y+1	; 0x01
    552e:	9a 81       	ldd	r25, Y+2	; 0x02
    5530:	9c 01       	movw	r18, r24
    5532:	2e 5f       	subi	r18, 0xFE	; 254
    5534:	3f 4f       	sbci	r19, 0xFF	; 255
    5536:	81 ec       	ldi	r24, 0xC1	; 193
    5538:	97 e0       	ldi	r25, 0x07	; 7
    553a:	b9 01       	movw	r22, r18
    553c:	0e 94 83 20 	call	0x4106	; 0x4106 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    5540:	80 91 4e 07 	lds	r24, 0x074E
    5544:	8f 5f       	subi	r24, 0xFF	; 255
    5546:	80 93 4e 07 	sts	0x074E, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    554a:	80 91 59 07 	lds	r24, 0x0759
    554e:	8f 5f       	subi	r24, 0xFF	; 255
    5550:	80 93 59 07 	sts	0x0759, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    5554:	0f 90       	pop	r0
    5556:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    5558:	80 91 54 07 	lds	r24, 0x0754
    555c:	88 23       	and	r24, r24
    555e:	31 f0       	breq	.+12     	; 0x556c <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    5560:	8b 81       	ldd	r24, Y+3	; 0x03
    5562:	9c 81       	ldd	r25, Y+4	; 0x04
    5564:	00 97       	sbiw	r24, 0x00	; 0
    5566:	11 f4       	brne	.+4      	; 0x556c <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    5568:	0e 94 43 23 	call	0x4686	; 0x4686 <vPortYield>
			}
		}
	}
    556c:	26 96       	adiw	r28, 0x06	; 6
    556e:	0f b6       	in	r0, 0x3f	; 63
    5570:	f8 94       	cli
    5572:	de bf       	out	0x3e, r29	; 62
    5574:	0f be       	out	0x3f, r0	; 63
    5576:	cd bf       	out	0x3d, r28	; 61
    5578:	cf 91       	pop	r28
    557a:	df 91       	pop	r29
    557c:	08 95       	ret

0000557e <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    557e:	df 93       	push	r29
    5580:	cf 93       	push	r28
    5582:	cd b7       	in	r28, 0x3d	; 61
    5584:	de b7       	in	r29, 0x3e	; 62
    5586:	28 97       	sbiw	r28, 0x08	; 8
    5588:	0f b6       	in	r0, 0x3f	; 63
    558a:	f8 94       	cli
    558c:	de bf       	out	0x3e, r29	; 62
    558e:	0f be       	out	0x3f, r0	; 63
    5590:	cd bf       	out	0x3d, r28	; 61
    5592:	9e 83       	std	Y+6, r25	; 0x06
    5594:	8d 83       	std	Y+5, r24	; 0x05
    5596:	78 87       	std	Y+8, r23	; 0x08
    5598:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    559a:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    559c:	0e 94 ab 2b 	call	0x5756	; 0x5756 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    55a0:	ed 81       	ldd	r30, Y+5	; 0x05
    55a2:	fe 81       	ldd	r31, Y+6	; 0x06
    55a4:	20 81       	ld	r18, Z
    55a6:	31 81       	ldd	r19, Z+1	; 0x01
    55a8:	8f 81       	ldd	r24, Y+7	; 0x07
    55aa:	98 85       	ldd	r25, Y+8	; 0x08
    55ac:	82 0f       	add	r24, r18
    55ae:	93 1f       	adc	r25, r19
    55b0:	9c 83       	std	Y+4, r25	; 0x04
    55b2:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    55b4:	ed 81       	ldd	r30, Y+5	; 0x05
    55b6:	fe 81       	ldd	r31, Y+6	; 0x06
    55b8:	20 81       	ld	r18, Z
    55ba:	31 81       	ldd	r19, Z+1	; 0x01
    55bc:	80 91 50 07 	lds	r24, 0x0750
    55c0:	90 91 51 07 	lds	r25, 0x0751
    55c4:	82 17       	cp	r24, r18
    55c6:	93 07       	cpc	r25, r19
    55c8:	a8 f4       	brcc	.+42     	; 0x55f4 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    55ca:	ed 81       	ldd	r30, Y+5	; 0x05
    55cc:	fe 81       	ldd	r31, Y+6	; 0x06
    55ce:	20 81       	ld	r18, Z
    55d0:	31 81       	ldd	r19, Z+1	; 0x01
    55d2:	8b 81       	ldd	r24, Y+3	; 0x03
    55d4:	9c 81       	ldd	r25, Y+4	; 0x04
    55d6:	82 17       	cp	r24, r18
    55d8:	93 07       	cpc	r25, r19
    55da:	00 f5       	brcc	.+64     	; 0x561c <vTaskDelayUntil+0x9e>
    55dc:	20 91 50 07 	lds	r18, 0x0750
    55e0:	30 91 51 07 	lds	r19, 0x0751
    55e4:	8b 81       	ldd	r24, Y+3	; 0x03
    55e6:	9c 81       	ldd	r25, Y+4	; 0x04
    55e8:	28 17       	cp	r18, r24
    55ea:	39 07       	cpc	r19, r25
    55ec:	b8 f4       	brcc	.+46     	; 0x561c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    55ee:	81 e0       	ldi	r24, 0x01	; 1
    55f0:	89 83       	std	Y+1, r24	; 0x01
    55f2:	14 c0       	rjmp	.+40     	; 0x561c <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    55f4:	ed 81       	ldd	r30, Y+5	; 0x05
    55f6:	fe 81       	ldd	r31, Y+6	; 0x06
    55f8:	20 81       	ld	r18, Z
    55fa:	31 81       	ldd	r19, Z+1	; 0x01
    55fc:	8b 81       	ldd	r24, Y+3	; 0x03
    55fe:	9c 81       	ldd	r25, Y+4	; 0x04
    5600:	82 17       	cp	r24, r18
    5602:	93 07       	cpc	r25, r19
    5604:	48 f0       	brcs	.+18     	; 0x5618 <vTaskDelayUntil+0x9a>
    5606:	20 91 50 07 	lds	r18, 0x0750
    560a:	30 91 51 07 	lds	r19, 0x0751
    560e:	8b 81       	ldd	r24, Y+3	; 0x03
    5610:	9c 81       	ldd	r25, Y+4	; 0x04
    5612:	28 17       	cp	r18, r24
    5614:	39 07       	cpc	r19, r25
    5616:	10 f4       	brcc	.+4      	; 0x561c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    5618:	81 e0       	ldi	r24, 0x01	; 1
    561a:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    561c:	ed 81       	ldd	r30, Y+5	; 0x05
    561e:	fe 81       	ldd	r31, Y+6	; 0x06
    5620:	8b 81       	ldd	r24, Y+3	; 0x03
    5622:	9c 81       	ldd	r25, Y+4	; 0x04
    5624:	91 83       	std	Z+1, r25	; 0x01
    5626:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    5628:	89 81       	ldd	r24, Y+1	; 0x01
    562a:	88 23       	and	r24, r24
    562c:	59 f0       	breq	.+22     	; 0x5644 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    562e:	80 91 4c 07 	lds	r24, 0x074C
    5632:	90 91 4d 07 	lds	r25, 0x074D
    5636:	02 96       	adiw	r24, 0x02	; 2
    5638:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    563c:	8b 81       	ldd	r24, Y+3	; 0x03
    563e:	9c 81       	ldd	r25, Y+4	; 0x04
    5640:	0e 94 af 2f 	call	0x5f5e	; 0x5f5e <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    5644:	0e 94 b7 2b 	call	0x576e	; 0x576e <xTaskResumeAll>
    5648:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    564a:	8a 81       	ldd	r24, Y+2	; 0x02
    564c:	88 23       	and	r24, r24
    564e:	11 f4       	brne	.+4      	; 0x5654 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    5650:	0e 94 43 23 	call	0x4686	; 0x4686 <vPortYield>
		}
	}
    5654:	28 96       	adiw	r28, 0x08	; 8
    5656:	0f b6       	in	r0, 0x3f	; 63
    5658:	f8 94       	cli
    565a:	de bf       	out	0x3e, r29	; 62
    565c:	0f be       	out	0x3f, r0	; 63
    565e:	cd bf       	out	0x3d, r28	; 61
    5660:	cf 91       	pop	r28
    5662:	df 91       	pop	r29
    5664:	08 95       	ret

00005666 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    5666:	df 93       	push	r29
    5668:	cf 93       	push	r28
    566a:	00 d0       	rcall	.+0      	; 0x566c <vTaskDelay+0x6>
    566c:	00 d0       	rcall	.+0      	; 0x566e <vTaskDelay+0x8>
    566e:	0f 92       	push	r0
    5670:	cd b7       	in	r28, 0x3d	; 61
    5672:	de b7       	in	r29, 0x3e	; 62
    5674:	9d 83       	std	Y+5, r25	; 0x05
    5676:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    5678:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    567a:	8c 81       	ldd	r24, Y+4	; 0x04
    567c:	9d 81       	ldd	r25, Y+5	; 0x05
    567e:	00 97       	sbiw	r24, 0x00	; 0
    5680:	d1 f0       	breq	.+52     	; 0x56b6 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    5682:	0e 94 ab 2b 	call	0x5756	; 0x5756 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    5686:	20 91 50 07 	lds	r18, 0x0750
    568a:	30 91 51 07 	lds	r19, 0x0751
    568e:	8c 81       	ldd	r24, Y+4	; 0x04
    5690:	9d 81       	ldd	r25, Y+5	; 0x05
    5692:	82 0f       	add	r24, r18
    5694:	93 1f       	adc	r25, r19
    5696:	9b 83       	std	Y+3, r25	; 0x03
    5698:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    569a:	80 91 4c 07 	lds	r24, 0x074C
    569e:	90 91 4d 07 	lds	r25, 0x074D
    56a2:	02 96       	adiw	r24, 0x02	; 2
    56a4:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    56a8:	8a 81       	ldd	r24, Y+2	; 0x02
    56aa:	9b 81       	ldd	r25, Y+3	; 0x03
    56ac:	0e 94 af 2f 	call	0x5f5e	; 0x5f5e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    56b0:	0e 94 b7 2b 	call	0x576e	; 0x576e <xTaskResumeAll>
    56b4:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    56b6:	89 81       	ldd	r24, Y+1	; 0x01
    56b8:	88 23       	and	r24, r24
    56ba:	11 f4       	brne	.+4      	; 0x56c0 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    56bc:	0e 94 43 23 	call	0x4686	; 0x4686 <vPortYield>
		}
	}
    56c0:	0f 90       	pop	r0
    56c2:	0f 90       	pop	r0
    56c4:	0f 90       	pop	r0
    56c6:	0f 90       	pop	r0
    56c8:	0f 90       	pop	r0
    56ca:	cf 91       	pop	r28
    56cc:	df 91       	pop	r29
    56ce:	08 95       	ret

000056d0 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    56d0:	af 92       	push	r10
    56d2:	bf 92       	push	r11
    56d4:	cf 92       	push	r12
    56d6:	df 92       	push	r13
    56d8:	ef 92       	push	r14
    56da:	ff 92       	push	r15
    56dc:	0f 93       	push	r16
    56de:	df 93       	push	r29
    56e0:	cf 93       	push	r28
    56e2:	0f 92       	push	r0
    56e4:	cd b7       	in	r28, 0x3d	; 61
    56e6:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    56e8:	20 e6       	ldi	r18, 0x60	; 96
    56ea:	30 e0       	ldi	r19, 0x00	; 0
    56ec:	8f ec       	ldi	r24, 0xCF	; 207
    56ee:	9e e2       	ldi	r25, 0x2E	; 46
    56f0:	b9 01       	movw	r22, r18
    56f2:	45 e5       	ldi	r20, 0x55	; 85
    56f4:	50 e0       	ldi	r21, 0x00	; 0
    56f6:	20 e0       	ldi	r18, 0x00	; 0
    56f8:	30 e0       	ldi	r19, 0x00	; 0
    56fa:	00 e0       	ldi	r16, 0x00	; 0
    56fc:	ee 24       	eor	r14, r14
    56fe:	ff 24       	eor	r15, r15
    5700:	cc 24       	eor	r12, r12
    5702:	dd 24       	eor	r13, r13
    5704:	aa 24       	eor	r10, r10
    5706:	bb 24       	eor	r11, r11
    5708:	0e 94 6f 29 	call	0x52de	; 0x52de <xTaskGenericCreate>
    570c:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    570e:	89 81       	ldd	r24, Y+1	; 0x01
    5710:	81 30       	cpi	r24, 0x01	; 1
    5712:	51 f4       	brne	.+20     	; 0x5728 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    5714:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    5716:	81 e0       	ldi	r24, 0x01	; 1
    5718:	80 93 54 07 	sts	0x0754, r24
		xTickCount = ( portTickType ) 0U;
    571c:	10 92 51 07 	sts	0x0751, r1
    5720:	10 92 50 07 	sts	0x0750, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    5724:	0e 94 07 23 	call	0x460e	; 0x460e <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    5728:	0f 90       	pop	r0
    572a:	cf 91       	pop	r28
    572c:	df 91       	pop	r29
    572e:	0f 91       	pop	r16
    5730:	ff 90       	pop	r15
    5732:	ef 90       	pop	r14
    5734:	df 90       	pop	r13
    5736:	cf 90       	pop	r12
    5738:	bf 90       	pop	r11
    573a:	af 90       	pop	r10
    573c:	08 95       	ret

0000573e <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    573e:	df 93       	push	r29
    5740:	cf 93       	push	r28
    5742:	cd b7       	in	r28, 0x3d	; 61
    5744:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    5746:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    5748:	10 92 54 07 	sts	0x0754, r1
	vPortEndScheduler();
    574c:	0e 94 3c 23 	call	0x4678	; 0x4678 <vPortEndScheduler>
}
    5750:	cf 91       	pop	r28
    5752:	df 91       	pop	r29
    5754:	08 95       	ret

00005756 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    5756:	df 93       	push	r29
    5758:	cf 93       	push	r28
    575a:	cd b7       	in	r28, 0x3d	; 61
    575c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    575e:	80 91 55 07 	lds	r24, 0x0755
    5762:	8f 5f       	subi	r24, 0xFF	; 255
    5764:	80 93 55 07 	sts	0x0755, r24
}
    5768:	cf 91       	pop	r28
    576a:	df 91       	pop	r29
    576c:	08 95       	ret

0000576e <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    576e:	df 93       	push	r29
    5770:	cf 93       	push	r28
    5772:	00 d0       	rcall	.+0      	; 0x5774 <xTaskResumeAll+0x6>
    5774:	00 d0       	rcall	.+0      	; 0x5776 <xTaskResumeAll+0x8>
    5776:	cd b7       	in	r28, 0x3d	; 61
    5778:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    577a:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    577c:	0f b6       	in	r0, 0x3f	; 63
    577e:	f8 94       	cli
    5780:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    5782:	80 91 55 07 	lds	r24, 0x0755
    5786:	81 50       	subi	r24, 0x01	; 1
    5788:	80 93 55 07 	sts	0x0755, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    578c:	80 91 55 07 	lds	r24, 0x0755
    5790:	88 23       	and	r24, r24
    5792:	09 f0       	breq	.+2      	; 0x5796 <xTaskResumeAll+0x28>
    5794:	6c c0       	rjmp	.+216    	; 0x586e <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    5796:	80 91 4f 07 	lds	r24, 0x074F
    579a:	88 23       	and	r24, r24
    579c:	09 f4       	brne	.+2      	; 0x57a0 <xTaskResumeAll+0x32>
    579e:	67 c0       	rjmp	.+206    	; 0x586e <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    57a0:	19 82       	std	Y+1, r1	; 0x01
    57a2:	41 c0       	rjmp	.+130    	; 0x5826 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    57a4:	e0 91 bd 07 	lds	r30, 0x07BD
    57a8:	f0 91 be 07 	lds	r31, 0x07BE
    57ac:	86 81       	ldd	r24, Z+6	; 0x06
    57ae:	97 81       	ldd	r25, Z+7	; 0x07
    57b0:	9c 83       	std	Y+4, r25	; 0x04
    57b2:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    57b4:	8b 81       	ldd	r24, Y+3	; 0x03
    57b6:	9c 81       	ldd	r25, Y+4	; 0x04
    57b8:	0c 96       	adiw	r24, 0x0c	; 12
    57ba:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    57be:	8b 81       	ldd	r24, Y+3	; 0x03
    57c0:	9c 81       	ldd	r25, Y+4	; 0x04
    57c2:	02 96       	adiw	r24, 0x02	; 2
    57c4:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    57c8:	eb 81       	ldd	r30, Y+3	; 0x03
    57ca:	fc 81       	ldd	r31, Y+4	; 0x04
    57cc:	96 89       	ldd	r25, Z+22	; 0x16
    57ce:	80 91 53 07 	lds	r24, 0x0753
    57d2:	89 17       	cp	r24, r25
    57d4:	28 f4       	brcc	.+10     	; 0x57e0 <xTaskResumeAll+0x72>
    57d6:	eb 81       	ldd	r30, Y+3	; 0x03
    57d8:	fc 81       	ldd	r31, Y+4	; 0x04
    57da:	86 89       	ldd	r24, Z+22	; 0x16
    57dc:	80 93 53 07 	sts	0x0753, r24
    57e0:	eb 81       	ldd	r30, Y+3	; 0x03
    57e2:	fc 81       	ldd	r31, Y+4	; 0x04
    57e4:	86 89       	ldd	r24, Z+22	; 0x16
    57e6:	28 2f       	mov	r18, r24
    57e8:	30 e0       	ldi	r19, 0x00	; 0
    57ea:	c9 01       	movw	r24, r18
    57ec:	88 0f       	add	r24, r24
    57ee:	99 1f       	adc	r25, r25
    57f0:	88 0f       	add	r24, r24
    57f2:	99 1f       	adc	r25, r25
    57f4:	88 0f       	add	r24, r24
    57f6:	99 1f       	adc	r25, r25
    57f8:	82 0f       	add	r24, r18
    57fa:	93 1f       	adc	r25, r19
    57fc:	86 5a       	subi	r24, 0xA6	; 166
    57fe:	98 4f       	sbci	r25, 0xF8	; 248
    5800:	2b 81       	ldd	r18, Y+3	; 0x03
    5802:	3c 81       	ldd	r19, Y+4	; 0x04
    5804:	2e 5f       	subi	r18, 0xFE	; 254
    5806:	3f 4f       	sbci	r19, 0xFF	; 255
    5808:	b9 01       	movw	r22, r18
    580a:	0e 94 83 20 	call	0x4106	; 0x4106 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    580e:	eb 81       	ldd	r30, Y+3	; 0x03
    5810:	fc 81       	ldd	r31, Y+4	; 0x04
    5812:	96 89       	ldd	r25, Z+22	; 0x16
    5814:	e0 91 4c 07 	lds	r30, 0x074C
    5818:	f0 91 4d 07 	lds	r31, 0x074D
    581c:	86 89       	ldd	r24, Z+22	; 0x16
    581e:	98 17       	cp	r25, r24
    5820:	10 f0       	brcs	.+4      	; 0x5826 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    5822:	81 e0       	ldi	r24, 0x01	; 1
    5824:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    5826:	80 91 b8 07 	lds	r24, 0x07B8
    582a:	88 23       	and	r24, r24
    582c:	09 f0       	breq	.+2      	; 0x5830 <xTaskResumeAll+0xc2>
    582e:	ba cf       	rjmp	.-140    	; 0x57a4 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    5830:	80 91 56 07 	lds	r24, 0x0756
    5834:	88 23       	and	r24, r24
    5836:	71 f0       	breq	.+28     	; 0x5854 <xTaskResumeAll+0xe6>
    5838:	07 c0       	rjmp	.+14     	; 0x5848 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    583a:	0e 94 76 2c 	call	0x58ec	; 0x58ec <vTaskIncrementTick>
						--uxMissedTicks;
    583e:	80 91 56 07 	lds	r24, 0x0756
    5842:	81 50       	subi	r24, 0x01	; 1
    5844:	80 93 56 07 	sts	0x0756, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    5848:	80 91 56 07 	lds	r24, 0x0756
    584c:	88 23       	and	r24, r24
    584e:	a9 f7       	brne	.-22     	; 0x583a <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    5850:	81 e0       	ldi	r24, 0x01	; 1
    5852:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    5854:	89 81       	ldd	r24, Y+1	; 0x01
    5856:	81 30       	cpi	r24, 0x01	; 1
    5858:	21 f0       	breq	.+8      	; 0x5862 <xTaskResumeAll+0xf4>
    585a:	80 91 57 07 	lds	r24, 0x0757
    585e:	81 30       	cpi	r24, 0x01	; 1
    5860:	31 f4       	brne	.+12     	; 0x586e <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    5862:	81 e0       	ldi	r24, 0x01	; 1
    5864:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    5866:	10 92 57 07 	sts	0x0757, r1
					portYIELD_WITHIN_API();
    586a:	0e 94 43 23 	call	0x4686	; 0x4686 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    586e:	0f 90       	pop	r0
    5870:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    5872:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5874:	0f 90       	pop	r0
    5876:	0f 90       	pop	r0
    5878:	0f 90       	pop	r0
    587a:	0f 90       	pop	r0
    587c:	cf 91       	pop	r28
    587e:	df 91       	pop	r29
    5880:	08 95       	ret

00005882 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    5882:	df 93       	push	r29
    5884:	cf 93       	push	r28
    5886:	00 d0       	rcall	.+0      	; 0x5888 <xTaskGetTickCount+0x6>
    5888:	cd b7       	in	r28, 0x3d	; 61
    588a:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    588c:	0f b6       	in	r0, 0x3f	; 63
    588e:	f8 94       	cli
    5890:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    5892:	80 91 50 07 	lds	r24, 0x0750
    5896:	90 91 51 07 	lds	r25, 0x0751
    589a:	9a 83       	std	Y+2, r25	; 0x02
    589c:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    589e:	0f 90       	pop	r0
    58a0:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    58a2:	89 81       	ldd	r24, Y+1	; 0x01
    58a4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    58a6:	0f 90       	pop	r0
    58a8:	0f 90       	pop	r0
    58aa:	cf 91       	pop	r28
    58ac:	df 91       	pop	r29
    58ae:	08 95       	ret

000058b0 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    58b0:	df 93       	push	r29
    58b2:	cf 93       	push	r28
    58b4:	00 d0       	rcall	.+0      	; 0x58b6 <xTaskGetTickCountFromISR+0x6>
    58b6:	0f 92       	push	r0
    58b8:	cd b7       	in	r28, 0x3d	; 61
    58ba:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    58bc:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    58be:	80 91 50 07 	lds	r24, 0x0750
    58c2:	90 91 51 07 	lds	r25, 0x0751
    58c6:	9b 83       	std	Y+3, r25	; 0x03
    58c8:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    58ca:	8a 81       	ldd	r24, Y+2	; 0x02
    58cc:	9b 81       	ldd	r25, Y+3	; 0x03
}
    58ce:	0f 90       	pop	r0
    58d0:	0f 90       	pop	r0
    58d2:	0f 90       	pop	r0
    58d4:	cf 91       	pop	r28
    58d6:	df 91       	pop	r29
    58d8:	08 95       	ret

000058da <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    58da:	df 93       	push	r29
    58dc:	cf 93       	push	r28
    58de:	cd b7       	in	r28, 0x3d	; 61
    58e0:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    58e2:	80 91 4f 07 	lds	r24, 0x074F
}
    58e6:	cf 91       	pop	r28
    58e8:	df 91       	pop	r29
    58ea:	08 95       	ret

000058ec <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    58ec:	df 93       	push	r29
    58ee:	cf 93       	push	r28
    58f0:	00 d0       	rcall	.+0      	; 0x58f2 <vTaskIncrementTick+0x6>
    58f2:	00 d0       	rcall	.+0      	; 0x58f4 <vTaskIncrementTick+0x8>
    58f4:	00 d0       	rcall	.+0      	; 0x58f6 <vTaskIncrementTick+0xa>
    58f6:	cd b7       	in	r28, 0x3d	; 61
    58f8:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    58fa:	80 91 55 07 	lds	r24, 0x0755
    58fe:	88 23       	and	r24, r24
    5900:	09 f0       	breq	.+2      	; 0x5904 <vTaskIncrementTick+0x18>
    5902:	bb c0       	rjmp	.+374    	; 0x5a7a <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    5904:	80 91 50 07 	lds	r24, 0x0750
    5908:	90 91 51 07 	lds	r25, 0x0751
    590c:	01 96       	adiw	r24, 0x01	; 1
    590e:	90 93 51 07 	sts	0x0751, r25
    5912:	80 93 50 07 	sts	0x0750, r24
		if( xTickCount == ( portTickType ) 0U )
    5916:	80 91 50 07 	lds	r24, 0x0750
    591a:	90 91 51 07 	lds	r25, 0x0751
    591e:	00 97       	sbiw	r24, 0x00	; 0
    5920:	d1 f5       	brne	.+116    	; 0x5996 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    5922:	80 91 b4 07 	lds	r24, 0x07B4
    5926:	90 91 b5 07 	lds	r25, 0x07B5
    592a:	9c 83       	std	Y+4, r25	; 0x04
    592c:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    592e:	80 91 b6 07 	lds	r24, 0x07B6
    5932:	90 91 b7 07 	lds	r25, 0x07B7
    5936:	90 93 b5 07 	sts	0x07B5, r25
    593a:	80 93 b4 07 	sts	0x07B4, r24
			pxOverflowDelayedTaskList = pxTemp;
    593e:	8b 81       	ldd	r24, Y+3	; 0x03
    5940:	9c 81       	ldd	r25, Y+4	; 0x04
    5942:	90 93 b7 07 	sts	0x07B7, r25
    5946:	80 93 b6 07 	sts	0x07B6, r24
			xNumOfOverflows++;
    594a:	80 91 58 07 	lds	r24, 0x0758
    594e:	8f 5f       	subi	r24, 0xFF	; 255
    5950:	80 93 58 07 	sts	0x0758, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5954:	e0 91 b4 07 	lds	r30, 0x07B4
    5958:	f0 91 b5 07 	lds	r31, 0x07B5
    595c:	80 81       	ld	r24, Z
    595e:	88 23       	and	r24, r24
    5960:	39 f4       	brne	.+14     	; 0x5970 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    5962:	8f ef       	ldi	r24, 0xFF	; 255
    5964:	9f ef       	ldi	r25, 0xFF	; 255
    5966:	90 93 bc 01 	sts	0x01BC, r25
    596a:	80 93 bb 01 	sts	0x01BB, r24
    596e:	13 c0       	rjmp	.+38     	; 0x5996 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    5970:	e0 91 b4 07 	lds	r30, 0x07B4
    5974:	f0 91 b5 07 	lds	r31, 0x07B5
    5978:	05 80       	ldd	r0, Z+5	; 0x05
    597a:	f6 81       	ldd	r31, Z+6	; 0x06
    597c:	e0 2d       	mov	r30, r0
    597e:	86 81       	ldd	r24, Z+6	; 0x06
    5980:	97 81       	ldd	r25, Z+7	; 0x07
    5982:	9e 83       	std	Y+6, r25	; 0x06
    5984:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    5986:	ed 81       	ldd	r30, Y+5	; 0x05
    5988:	fe 81       	ldd	r31, Y+6	; 0x06
    598a:	82 81       	ldd	r24, Z+2	; 0x02
    598c:	93 81       	ldd	r25, Z+3	; 0x03
    598e:	90 93 bc 01 	sts	0x01BC, r25
    5992:	80 93 bb 01 	sts	0x01BB, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    5996:	20 91 50 07 	lds	r18, 0x0750
    599a:	30 91 51 07 	lds	r19, 0x0751
    599e:	80 91 bb 01 	lds	r24, 0x01BB
    59a2:	90 91 bc 01 	lds	r25, 0x01BC
    59a6:	28 17       	cp	r18, r24
    59a8:	39 07       	cpc	r19, r25
    59aa:	08 f4       	brcc	.+2      	; 0x59ae <vTaskIncrementTick+0xc2>
    59ac:	6b c0       	rjmp	.+214    	; 0x5a84 <vTaskIncrementTick+0x198>
    59ae:	e0 91 b4 07 	lds	r30, 0x07B4
    59b2:	f0 91 b5 07 	lds	r31, 0x07B5
    59b6:	80 81       	ld	r24, Z
    59b8:	88 23       	and	r24, r24
    59ba:	39 f4       	brne	.+14     	; 0x59ca <vTaskIncrementTick+0xde>
    59bc:	8f ef       	ldi	r24, 0xFF	; 255
    59be:	9f ef       	ldi	r25, 0xFF	; 255
    59c0:	90 93 bc 01 	sts	0x01BC, r25
    59c4:	80 93 bb 01 	sts	0x01BB, r24
    59c8:	5d c0       	rjmp	.+186    	; 0x5a84 <vTaskIncrementTick+0x198>
    59ca:	e0 91 b4 07 	lds	r30, 0x07B4
    59ce:	f0 91 b5 07 	lds	r31, 0x07B5
    59d2:	05 80       	ldd	r0, Z+5	; 0x05
    59d4:	f6 81       	ldd	r31, Z+6	; 0x06
    59d6:	e0 2d       	mov	r30, r0
    59d8:	86 81       	ldd	r24, Z+6	; 0x06
    59da:	97 81       	ldd	r25, Z+7	; 0x07
    59dc:	9e 83       	std	Y+6, r25	; 0x06
    59de:	8d 83       	std	Y+5, r24	; 0x05
    59e0:	ed 81       	ldd	r30, Y+5	; 0x05
    59e2:	fe 81       	ldd	r31, Y+6	; 0x06
    59e4:	82 81       	ldd	r24, Z+2	; 0x02
    59e6:	93 81       	ldd	r25, Z+3	; 0x03
    59e8:	9a 83       	std	Y+2, r25	; 0x02
    59ea:	89 83       	std	Y+1, r24	; 0x01
    59ec:	20 91 50 07 	lds	r18, 0x0750
    59f0:	30 91 51 07 	lds	r19, 0x0751
    59f4:	89 81       	ldd	r24, Y+1	; 0x01
    59f6:	9a 81       	ldd	r25, Y+2	; 0x02
    59f8:	28 17       	cp	r18, r24
    59fa:	39 07       	cpc	r19, r25
    59fc:	38 f4       	brcc	.+14     	; 0x5a0c <vTaskIncrementTick+0x120>
    59fe:	89 81       	ldd	r24, Y+1	; 0x01
    5a00:	9a 81       	ldd	r25, Y+2	; 0x02
    5a02:	90 93 bc 01 	sts	0x01BC, r25
    5a06:	80 93 bb 01 	sts	0x01BB, r24
    5a0a:	3c c0       	rjmp	.+120    	; 0x5a84 <vTaskIncrementTick+0x198>
    5a0c:	8d 81       	ldd	r24, Y+5	; 0x05
    5a0e:	9e 81       	ldd	r25, Y+6	; 0x06
    5a10:	02 96       	adiw	r24, 0x02	; 2
    5a12:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
    5a16:	ed 81       	ldd	r30, Y+5	; 0x05
    5a18:	fe 81       	ldd	r31, Y+6	; 0x06
    5a1a:	84 89       	ldd	r24, Z+20	; 0x14
    5a1c:	95 89       	ldd	r25, Z+21	; 0x15
    5a1e:	00 97       	sbiw	r24, 0x00	; 0
    5a20:	29 f0       	breq	.+10     	; 0x5a2c <vTaskIncrementTick+0x140>
    5a22:	8d 81       	ldd	r24, Y+5	; 0x05
    5a24:	9e 81       	ldd	r25, Y+6	; 0x06
    5a26:	0c 96       	adiw	r24, 0x0c	; 12
    5a28:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
    5a2c:	ed 81       	ldd	r30, Y+5	; 0x05
    5a2e:	fe 81       	ldd	r31, Y+6	; 0x06
    5a30:	96 89       	ldd	r25, Z+22	; 0x16
    5a32:	80 91 53 07 	lds	r24, 0x0753
    5a36:	89 17       	cp	r24, r25
    5a38:	28 f4       	brcc	.+10     	; 0x5a44 <vTaskIncrementTick+0x158>
    5a3a:	ed 81       	ldd	r30, Y+5	; 0x05
    5a3c:	fe 81       	ldd	r31, Y+6	; 0x06
    5a3e:	86 89       	ldd	r24, Z+22	; 0x16
    5a40:	80 93 53 07 	sts	0x0753, r24
    5a44:	ed 81       	ldd	r30, Y+5	; 0x05
    5a46:	fe 81       	ldd	r31, Y+6	; 0x06
    5a48:	86 89       	ldd	r24, Z+22	; 0x16
    5a4a:	28 2f       	mov	r18, r24
    5a4c:	30 e0       	ldi	r19, 0x00	; 0
    5a4e:	c9 01       	movw	r24, r18
    5a50:	88 0f       	add	r24, r24
    5a52:	99 1f       	adc	r25, r25
    5a54:	88 0f       	add	r24, r24
    5a56:	99 1f       	adc	r25, r25
    5a58:	88 0f       	add	r24, r24
    5a5a:	99 1f       	adc	r25, r25
    5a5c:	82 0f       	add	r24, r18
    5a5e:	93 1f       	adc	r25, r19
    5a60:	ac 01       	movw	r20, r24
    5a62:	46 5a       	subi	r20, 0xA6	; 166
    5a64:	58 4f       	sbci	r21, 0xF8	; 248
    5a66:	8d 81       	ldd	r24, Y+5	; 0x05
    5a68:	9e 81       	ldd	r25, Y+6	; 0x06
    5a6a:	9c 01       	movw	r18, r24
    5a6c:	2e 5f       	subi	r18, 0xFE	; 254
    5a6e:	3f 4f       	sbci	r19, 0xFF	; 255
    5a70:	ca 01       	movw	r24, r20
    5a72:	b9 01       	movw	r22, r18
    5a74:	0e 94 83 20 	call	0x4106	; 0x4106 <vListInsertEnd>
    5a78:	9a cf       	rjmp	.-204    	; 0x59ae <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    5a7a:	80 91 56 07 	lds	r24, 0x0756
    5a7e:	8f 5f       	subi	r24, 0xFF	; 255
    5a80:	80 93 56 07 	sts	0x0756, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    5a84:	26 96       	adiw	r28, 0x06	; 6
    5a86:	0f b6       	in	r0, 0x3f	; 63
    5a88:	f8 94       	cli
    5a8a:	de bf       	out	0x3e, r29	; 62
    5a8c:	0f be       	out	0x3f, r0	; 63
    5a8e:	cd bf       	out	0x3d, r28	; 61
    5a90:	cf 91       	pop	r28
    5a92:	df 91       	pop	r29
    5a94:	08 95       	ret

00005a96 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5a96:	df 93       	push	r29
    5a98:	cf 93       	push	r28
    5a9a:	00 d0       	rcall	.+0      	; 0x5a9c <vTaskSwitchContext+0x6>
    5a9c:	cd b7       	in	r28, 0x3d	; 61
    5a9e:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    5aa0:	80 91 55 07 	lds	r24, 0x0755
    5aa4:	88 23       	and	r24, r24
    5aa6:	49 f0       	breq	.+18     	; 0x5aba <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    5aa8:	81 e0       	ldi	r24, 0x01	; 1
    5aaa:	80 93 57 07 	sts	0x0757, r24
    5aae:	54 c0       	rjmp	.+168    	; 0x5b58 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    5ab0:	80 91 53 07 	lds	r24, 0x0753
    5ab4:	81 50       	subi	r24, 0x01	; 1
    5ab6:	80 93 53 07 	sts	0x0753, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    5aba:	80 91 53 07 	lds	r24, 0x0753
    5abe:	28 2f       	mov	r18, r24
    5ac0:	30 e0       	ldi	r19, 0x00	; 0
    5ac2:	c9 01       	movw	r24, r18
    5ac4:	88 0f       	add	r24, r24
    5ac6:	99 1f       	adc	r25, r25
    5ac8:	88 0f       	add	r24, r24
    5aca:	99 1f       	adc	r25, r25
    5acc:	88 0f       	add	r24, r24
    5ace:	99 1f       	adc	r25, r25
    5ad0:	82 0f       	add	r24, r18
    5ad2:	93 1f       	adc	r25, r19
    5ad4:	fc 01       	movw	r30, r24
    5ad6:	e6 5a       	subi	r30, 0xA6	; 166
    5ad8:	f8 4f       	sbci	r31, 0xF8	; 248
    5ada:	80 81       	ld	r24, Z
    5adc:	88 23       	and	r24, r24
    5ade:	41 f3       	breq	.-48     	; 0x5ab0 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    5ae0:	80 91 53 07 	lds	r24, 0x0753
    5ae4:	28 2f       	mov	r18, r24
    5ae6:	30 e0       	ldi	r19, 0x00	; 0
    5ae8:	c9 01       	movw	r24, r18
    5aea:	88 0f       	add	r24, r24
    5aec:	99 1f       	adc	r25, r25
    5aee:	88 0f       	add	r24, r24
    5af0:	99 1f       	adc	r25, r25
    5af2:	88 0f       	add	r24, r24
    5af4:	99 1f       	adc	r25, r25
    5af6:	82 0f       	add	r24, r18
    5af8:	93 1f       	adc	r25, r19
    5afa:	86 5a       	subi	r24, 0xA6	; 166
    5afc:	98 4f       	sbci	r25, 0xF8	; 248
    5afe:	9a 83       	std	Y+2, r25	; 0x02
    5b00:	89 83       	std	Y+1, r24	; 0x01
    5b02:	e9 81       	ldd	r30, Y+1	; 0x01
    5b04:	fa 81       	ldd	r31, Y+2	; 0x02
    5b06:	01 80       	ldd	r0, Z+1	; 0x01
    5b08:	f2 81       	ldd	r31, Z+2	; 0x02
    5b0a:	e0 2d       	mov	r30, r0
    5b0c:	82 81       	ldd	r24, Z+2	; 0x02
    5b0e:	93 81       	ldd	r25, Z+3	; 0x03
    5b10:	e9 81       	ldd	r30, Y+1	; 0x01
    5b12:	fa 81       	ldd	r31, Y+2	; 0x02
    5b14:	92 83       	std	Z+2, r25	; 0x02
    5b16:	81 83       	std	Z+1, r24	; 0x01
    5b18:	e9 81       	ldd	r30, Y+1	; 0x01
    5b1a:	fa 81       	ldd	r31, Y+2	; 0x02
    5b1c:	21 81       	ldd	r18, Z+1	; 0x01
    5b1e:	32 81       	ldd	r19, Z+2	; 0x02
    5b20:	89 81       	ldd	r24, Y+1	; 0x01
    5b22:	9a 81       	ldd	r25, Y+2	; 0x02
    5b24:	03 96       	adiw	r24, 0x03	; 3
    5b26:	28 17       	cp	r18, r24
    5b28:	39 07       	cpc	r19, r25
    5b2a:	59 f4       	brne	.+22     	; 0x5b42 <vTaskSwitchContext+0xac>
    5b2c:	e9 81       	ldd	r30, Y+1	; 0x01
    5b2e:	fa 81       	ldd	r31, Y+2	; 0x02
    5b30:	01 80       	ldd	r0, Z+1	; 0x01
    5b32:	f2 81       	ldd	r31, Z+2	; 0x02
    5b34:	e0 2d       	mov	r30, r0
    5b36:	82 81       	ldd	r24, Z+2	; 0x02
    5b38:	93 81       	ldd	r25, Z+3	; 0x03
    5b3a:	e9 81       	ldd	r30, Y+1	; 0x01
    5b3c:	fa 81       	ldd	r31, Y+2	; 0x02
    5b3e:	92 83       	std	Z+2, r25	; 0x02
    5b40:	81 83       	std	Z+1, r24	; 0x01
    5b42:	e9 81       	ldd	r30, Y+1	; 0x01
    5b44:	fa 81       	ldd	r31, Y+2	; 0x02
    5b46:	01 80       	ldd	r0, Z+1	; 0x01
    5b48:	f2 81       	ldd	r31, Z+2	; 0x02
    5b4a:	e0 2d       	mov	r30, r0
    5b4c:	86 81       	ldd	r24, Z+6	; 0x06
    5b4e:	97 81       	ldd	r25, Z+7	; 0x07
    5b50:	90 93 4d 07 	sts	0x074D, r25
    5b54:	80 93 4c 07 	sts	0x074C, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    5b58:	0f 90       	pop	r0
    5b5a:	0f 90       	pop	r0
    5b5c:	cf 91       	pop	r28
    5b5e:	df 91       	pop	r29
    5b60:	08 95       	ret

00005b62 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    5b62:	df 93       	push	r29
    5b64:	cf 93       	push	r28
    5b66:	00 d0       	rcall	.+0      	; 0x5b68 <vTaskPlaceOnEventList+0x6>
    5b68:	00 d0       	rcall	.+0      	; 0x5b6a <vTaskPlaceOnEventList+0x8>
    5b6a:	00 d0       	rcall	.+0      	; 0x5b6c <vTaskPlaceOnEventList+0xa>
    5b6c:	cd b7       	in	r28, 0x3d	; 61
    5b6e:	de b7       	in	r29, 0x3e	; 62
    5b70:	9c 83       	std	Y+4, r25	; 0x04
    5b72:	8b 83       	std	Y+3, r24	; 0x03
    5b74:	7e 83       	std	Y+6, r23	; 0x06
    5b76:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    5b78:	4b 81       	ldd	r20, Y+3	; 0x03
    5b7a:	5c 81       	ldd	r21, Y+4	; 0x04
    5b7c:	80 91 4c 07 	lds	r24, 0x074C
    5b80:	90 91 4d 07 	lds	r25, 0x074D
    5b84:	9c 01       	movw	r18, r24
    5b86:	24 5f       	subi	r18, 0xF4	; 244
    5b88:	3f 4f       	sbci	r19, 0xFF	; 255
    5b8a:	ca 01       	movw	r24, r20
    5b8c:	b9 01       	movw	r22, r18
    5b8e:	0e 94 cf 20 	call	0x419e	; 0x419e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5b92:	80 91 4c 07 	lds	r24, 0x074C
    5b96:	90 91 4d 07 	lds	r25, 0x074D
    5b9a:	02 96       	adiw	r24, 0x02	; 2
    5b9c:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    5ba0:	20 91 50 07 	lds	r18, 0x0750
    5ba4:	30 91 51 07 	lds	r19, 0x0751
    5ba8:	8d 81       	ldd	r24, Y+5	; 0x05
    5baa:	9e 81       	ldd	r25, Y+6	; 0x06
    5bac:	82 0f       	add	r24, r18
    5bae:	93 1f       	adc	r25, r19
    5bb0:	9a 83       	std	Y+2, r25	; 0x02
    5bb2:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5bb4:	89 81       	ldd	r24, Y+1	; 0x01
    5bb6:	9a 81       	ldd	r25, Y+2	; 0x02
    5bb8:	0e 94 af 2f 	call	0x5f5e	; 0x5f5e <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    5bbc:	26 96       	adiw	r28, 0x06	; 6
    5bbe:	0f b6       	in	r0, 0x3f	; 63
    5bc0:	f8 94       	cli
    5bc2:	de bf       	out	0x3e, r29	; 62
    5bc4:	0f be       	out	0x3f, r0	; 63
    5bc6:	cd bf       	out	0x3d, r28	; 61
    5bc8:	cf 91       	pop	r28
    5bca:	df 91       	pop	r29
    5bcc:	08 95       	ret

00005bce <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    5bce:	df 93       	push	r29
    5bd0:	cf 93       	push	r28
    5bd2:	00 d0       	rcall	.+0      	; 0x5bd4 <xTaskRemoveFromEventList+0x6>
    5bd4:	00 d0       	rcall	.+0      	; 0x5bd6 <xTaskRemoveFromEventList+0x8>
    5bd6:	0f 92       	push	r0
    5bd8:	cd b7       	in	r28, 0x3d	; 61
    5bda:	de b7       	in	r29, 0x3e	; 62
    5bdc:	9d 83       	std	Y+5, r25	; 0x05
    5bde:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    5be0:	ec 81       	ldd	r30, Y+4	; 0x04
    5be2:	fd 81       	ldd	r31, Y+5	; 0x05
    5be4:	05 80       	ldd	r0, Z+5	; 0x05
    5be6:	f6 81       	ldd	r31, Z+6	; 0x06
    5be8:	e0 2d       	mov	r30, r0
    5bea:	86 81       	ldd	r24, Z+6	; 0x06
    5bec:	97 81       	ldd	r25, Z+7	; 0x07
    5bee:	9b 83       	std	Y+3, r25	; 0x03
    5bf0:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5bf2:	8a 81       	ldd	r24, Y+2	; 0x02
    5bf4:	9b 81       	ldd	r25, Y+3	; 0x03
    5bf6:	0c 96       	adiw	r24, 0x0c	; 12
    5bf8:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    5bfc:	80 91 55 07 	lds	r24, 0x0755
    5c00:	88 23       	and	r24, r24
    5c02:	61 f5       	brne	.+88     	; 0x5c5c <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5c04:	8a 81       	ldd	r24, Y+2	; 0x02
    5c06:	9b 81       	ldd	r25, Y+3	; 0x03
    5c08:	02 96       	adiw	r24, 0x02	; 2
    5c0a:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    5c0e:	ea 81       	ldd	r30, Y+2	; 0x02
    5c10:	fb 81       	ldd	r31, Y+3	; 0x03
    5c12:	96 89       	ldd	r25, Z+22	; 0x16
    5c14:	80 91 53 07 	lds	r24, 0x0753
    5c18:	89 17       	cp	r24, r25
    5c1a:	28 f4       	brcc	.+10     	; 0x5c26 <xTaskRemoveFromEventList+0x58>
    5c1c:	ea 81       	ldd	r30, Y+2	; 0x02
    5c1e:	fb 81       	ldd	r31, Y+3	; 0x03
    5c20:	86 89       	ldd	r24, Z+22	; 0x16
    5c22:	80 93 53 07 	sts	0x0753, r24
    5c26:	ea 81       	ldd	r30, Y+2	; 0x02
    5c28:	fb 81       	ldd	r31, Y+3	; 0x03
    5c2a:	86 89       	ldd	r24, Z+22	; 0x16
    5c2c:	28 2f       	mov	r18, r24
    5c2e:	30 e0       	ldi	r19, 0x00	; 0
    5c30:	c9 01       	movw	r24, r18
    5c32:	88 0f       	add	r24, r24
    5c34:	99 1f       	adc	r25, r25
    5c36:	88 0f       	add	r24, r24
    5c38:	99 1f       	adc	r25, r25
    5c3a:	88 0f       	add	r24, r24
    5c3c:	99 1f       	adc	r25, r25
    5c3e:	82 0f       	add	r24, r18
    5c40:	93 1f       	adc	r25, r19
    5c42:	ac 01       	movw	r20, r24
    5c44:	46 5a       	subi	r20, 0xA6	; 166
    5c46:	58 4f       	sbci	r21, 0xF8	; 248
    5c48:	8a 81       	ldd	r24, Y+2	; 0x02
    5c4a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c4c:	9c 01       	movw	r18, r24
    5c4e:	2e 5f       	subi	r18, 0xFE	; 254
    5c50:	3f 4f       	sbci	r19, 0xFF	; 255
    5c52:	ca 01       	movw	r24, r20
    5c54:	b9 01       	movw	r22, r18
    5c56:	0e 94 83 20 	call	0x4106	; 0x4106 <vListInsertEnd>
    5c5a:	0a c0       	rjmp	.+20     	; 0x5c70 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5c5c:	8a 81       	ldd	r24, Y+2	; 0x02
    5c5e:	9b 81       	ldd	r25, Y+3	; 0x03
    5c60:	9c 01       	movw	r18, r24
    5c62:	24 5f       	subi	r18, 0xF4	; 244
    5c64:	3f 4f       	sbci	r19, 0xFF	; 255
    5c66:	88 eb       	ldi	r24, 0xB8	; 184
    5c68:	97 e0       	ldi	r25, 0x07	; 7
    5c6a:	b9 01       	movw	r22, r18
    5c6c:	0e 94 83 20 	call	0x4106	; 0x4106 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5c70:	ea 81       	ldd	r30, Y+2	; 0x02
    5c72:	fb 81       	ldd	r31, Y+3	; 0x03
    5c74:	96 89       	ldd	r25, Z+22	; 0x16
    5c76:	e0 91 4c 07 	lds	r30, 0x074C
    5c7a:	f0 91 4d 07 	lds	r31, 0x074D
    5c7e:	86 89       	ldd	r24, Z+22	; 0x16
    5c80:	98 17       	cp	r25, r24
    5c82:	18 f0       	brcs	.+6      	; 0x5c8a <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    5c84:	81 e0       	ldi	r24, 0x01	; 1
    5c86:	89 83       	std	Y+1, r24	; 0x01
    5c88:	01 c0       	rjmp	.+2      	; 0x5c8c <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    5c8a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5c8c:	89 81       	ldd	r24, Y+1	; 0x01
}
    5c8e:	0f 90       	pop	r0
    5c90:	0f 90       	pop	r0
    5c92:	0f 90       	pop	r0
    5c94:	0f 90       	pop	r0
    5c96:	0f 90       	pop	r0
    5c98:	cf 91       	pop	r28
    5c9a:	df 91       	pop	r29
    5c9c:	08 95       	ret

00005c9e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    5c9e:	df 93       	push	r29
    5ca0:	cf 93       	push	r28
    5ca2:	00 d0       	rcall	.+0      	; 0x5ca4 <vTaskSetTimeOutState+0x6>
    5ca4:	cd b7       	in	r28, 0x3d	; 61
    5ca6:	de b7       	in	r29, 0x3e	; 62
    5ca8:	9a 83       	std	Y+2, r25	; 0x02
    5caa:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5cac:	80 91 58 07 	lds	r24, 0x0758
    5cb0:	e9 81       	ldd	r30, Y+1	; 0x01
    5cb2:	fa 81       	ldd	r31, Y+2	; 0x02
    5cb4:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5cb6:	80 91 50 07 	lds	r24, 0x0750
    5cba:	90 91 51 07 	lds	r25, 0x0751
    5cbe:	e9 81       	ldd	r30, Y+1	; 0x01
    5cc0:	fa 81       	ldd	r31, Y+2	; 0x02
    5cc2:	92 83       	std	Z+2, r25	; 0x02
    5cc4:	81 83       	std	Z+1, r24	; 0x01
}
    5cc6:	0f 90       	pop	r0
    5cc8:	0f 90       	pop	r0
    5cca:	cf 91       	pop	r28
    5ccc:	df 91       	pop	r29
    5cce:	08 95       	ret

00005cd0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    5cd0:	df 93       	push	r29
    5cd2:	cf 93       	push	r28
    5cd4:	00 d0       	rcall	.+0      	; 0x5cd6 <xTaskCheckForTimeOut+0x6>
    5cd6:	00 d0       	rcall	.+0      	; 0x5cd8 <xTaskCheckForTimeOut+0x8>
    5cd8:	0f 92       	push	r0
    5cda:	cd b7       	in	r28, 0x3d	; 61
    5cdc:	de b7       	in	r29, 0x3e	; 62
    5cde:	9b 83       	std	Y+3, r25	; 0x03
    5ce0:	8a 83       	std	Y+2, r24	; 0x02
    5ce2:	7d 83       	std	Y+5, r23	; 0x05
    5ce4:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5ce6:	0f b6       	in	r0, 0x3f	; 63
    5ce8:	f8 94       	cli
    5cea:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    5cec:	ea 81       	ldd	r30, Y+2	; 0x02
    5cee:	fb 81       	ldd	r31, Y+3	; 0x03
    5cf0:	90 81       	ld	r25, Z
    5cf2:	80 91 58 07 	lds	r24, 0x0758
    5cf6:	98 17       	cp	r25, r24
    5cf8:	71 f0       	breq	.+28     	; 0x5d16 <xTaskCheckForTimeOut+0x46>
    5cfa:	ea 81       	ldd	r30, Y+2	; 0x02
    5cfc:	fb 81       	ldd	r31, Y+3	; 0x03
    5cfe:	21 81       	ldd	r18, Z+1	; 0x01
    5d00:	32 81       	ldd	r19, Z+2	; 0x02
    5d02:	80 91 50 07 	lds	r24, 0x0750
    5d06:	90 91 51 07 	lds	r25, 0x0751
    5d0a:	82 17       	cp	r24, r18
    5d0c:	93 07       	cpc	r25, r19
    5d0e:	18 f0       	brcs	.+6      	; 0x5d16 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    5d10:	81 e0       	ldi	r24, 0x01	; 1
    5d12:	89 83       	std	Y+1, r24	; 0x01
    5d14:	2f c0       	rjmp	.+94     	; 0x5d74 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    5d16:	20 91 50 07 	lds	r18, 0x0750
    5d1a:	30 91 51 07 	lds	r19, 0x0751
    5d1e:	ea 81       	ldd	r30, Y+2	; 0x02
    5d20:	fb 81       	ldd	r31, Y+3	; 0x03
    5d22:	81 81       	ldd	r24, Z+1	; 0x01
    5d24:	92 81       	ldd	r25, Z+2	; 0x02
    5d26:	28 1b       	sub	r18, r24
    5d28:	39 0b       	sbc	r19, r25
    5d2a:	ec 81       	ldd	r30, Y+4	; 0x04
    5d2c:	fd 81       	ldd	r31, Y+5	; 0x05
    5d2e:	80 81       	ld	r24, Z
    5d30:	91 81       	ldd	r25, Z+1	; 0x01
    5d32:	28 17       	cp	r18, r24
    5d34:	39 07       	cpc	r19, r25
    5d36:	e0 f4       	brcc	.+56     	; 0x5d70 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    5d38:	ec 81       	ldd	r30, Y+4	; 0x04
    5d3a:	fd 81       	ldd	r31, Y+5	; 0x05
    5d3c:	40 81       	ld	r20, Z
    5d3e:	51 81       	ldd	r21, Z+1	; 0x01
    5d40:	ea 81       	ldd	r30, Y+2	; 0x02
    5d42:	fb 81       	ldd	r31, Y+3	; 0x03
    5d44:	21 81       	ldd	r18, Z+1	; 0x01
    5d46:	32 81       	ldd	r19, Z+2	; 0x02
    5d48:	80 91 50 07 	lds	r24, 0x0750
    5d4c:	90 91 51 07 	lds	r25, 0x0751
    5d50:	b9 01       	movw	r22, r18
    5d52:	68 1b       	sub	r22, r24
    5d54:	79 0b       	sbc	r23, r25
    5d56:	cb 01       	movw	r24, r22
    5d58:	84 0f       	add	r24, r20
    5d5a:	95 1f       	adc	r25, r21
    5d5c:	ec 81       	ldd	r30, Y+4	; 0x04
    5d5e:	fd 81       	ldd	r31, Y+5	; 0x05
    5d60:	91 83       	std	Z+1, r25	; 0x01
    5d62:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    5d64:	8a 81       	ldd	r24, Y+2	; 0x02
    5d66:	9b 81       	ldd	r25, Y+3	; 0x03
    5d68:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    5d6c:	19 82       	std	Y+1, r1	; 0x01
    5d6e:	02 c0       	rjmp	.+4      	; 0x5d74 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    5d70:	81 e0       	ldi	r24, 0x01	; 1
    5d72:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    5d74:	0f 90       	pop	r0
    5d76:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5d78:	89 81       	ldd	r24, Y+1	; 0x01
}
    5d7a:	0f 90       	pop	r0
    5d7c:	0f 90       	pop	r0
    5d7e:	0f 90       	pop	r0
    5d80:	0f 90       	pop	r0
    5d82:	0f 90       	pop	r0
    5d84:	cf 91       	pop	r28
    5d86:	df 91       	pop	r29
    5d88:	08 95       	ret

00005d8a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5d8a:	df 93       	push	r29
    5d8c:	cf 93       	push	r28
    5d8e:	cd b7       	in	r28, 0x3d	; 61
    5d90:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    5d92:	81 e0       	ldi	r24, 0x01	; 1
    5d94:	80 93 57 07 	sts	0x0757, r24
}
    5d98:	cf 91       	pop	r28
    5d9a:	df 91       	pop	r29
    5d9c:	08 95       	ret

00005d9e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5d9e:	df 93       	push	r29
    5da0:	cf 93       	push	r28
    5da2:	00 d0       	rcall	.+0      	; 0x5da4 <prvIdleTask+0x6>
    5da4:	cd b7       	in	r28, 0x3d	; 61
    5da6:	de b7       	in	r29, 0x3e	; 62
    5da8:	9a 83       	std	Y+2, r25	; 0x02
    5daa:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    5dac:	0e 94 71 2f 	call	0x5ee2	; 0x5ee2 <prvCheckTasksWaitingTermination>
    5db0:	fd cf       	rjmp	.-6      	; 0x5dac <prvIdleTask+0xe>

00005db2 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    5db2:	0f 93       	push	r16
    5db4:	1f 93       	push	r17
    5db6:	df 93       	push	r29
    5db8:	cf 93       	push	r28
    5dba:	cd b7       	in	r28, 0x3d	; 61
    5dbc:	de b7       	in	r29, 0x3e	; 62
    5dbe:	29 97       	sbiw	r28, 0x09	; 9
    5dc0:	0f b6       	in	r0, 0x3f	; 63
    5dc2:	f8 94       	cli
    5dc4:	de bf       	out	0x3e, r29	; 62
    5dc6:	0f be       	out	0x3f, r0	; 63
    5dc8:	cd bf       	out	0x3d, r28	; 61
    5dca:	9a 83       	std	Y+2, r25	; 0x02
    5dcc:	89 83       	std	Y+1, r24	; 0x01
    5dce:	7c 83       	std	Y+4, r23	; 0x04
    5dd0:	6b 83       	std	Y+3, r22	; 0x03
    5dd2:	4d 83       	std	Y+5, r20	; 0x05
    5dd4:	3f 83       	std	Y+7, r19	; 0x07
    5dd6:	2e 83       	std	Y+6, r18	; 0x06
    5dd8:	19 87       	std	Y+9, r17	; 0x09
    5dda:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    5ddc:	89 81       	ldd	r24, Y+1	; 0x01
    5dde:	9a 81       	ldd	r25, Y+2	; 0x02
    5de0:	49 96       	adiw	r24, 0x19	; 25
    5de2:	2b 81       	ldd	r18, Y+3	; 0x03
    5de4:	3c 81       	ldd	r19, Y+4	; 0x04
    5de6:	b9 01       	movw	r22, r18
    5de8:	48 e0       	ldi	r20, 0x08	; 8
    5dea:	50 e0       	ldi	r21, 0x00	; 0
    5dec:	0e 94 70 37 	call	0x6ee0	; 0x6ee0 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    5df0:	e9 81       	ldd	r30, Y+1	; 0x01
    5df2:	fa 81       	ldd	r31, Y+2	; 0x02
    5df4:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    5df6:	8d 81       	ldd	r24, Y+5	; 0x05
    5df8:	88 30       	cpi	r24, 0x08	; 8
    5dfa:	10 f0       	brcs	.+4      	; 0x5e00 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    5dfc:	87 e0       	ldi	r24, 0x07	; 7
    5dfe:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    5e00:	e9 81       	ldd	r30, Y+1	; 0x01
    5e02:	fa 81       	ldd	r31, Y+2	; 0x02
    5e04:	8d 81       	ldd	r24, Y+5	; 0x05
    5e06:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    5e08:	e9 81       	ldd	r30, Y+1	; 0x01
    5e0a:	fa 81       	ldd	r31, Y+2	; 0x02
    5e0c:	8d 81       	ldd	r24, Y+5	; 0x05
    5e0e:	81 a3       	std	Z+33, r24	; 0x21
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    5e10:	89 81       	ldd	r24, Y+1	; 0x01
    5e12:	9a 81       	ldd	r25, Y+2	; 0x02
    5e14:	02 96       	adiw	r24, 0x02	; 2
    5e16:	0e 94 73 20 	call	0x40e6	; 0x40e6 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    5e1a:	89 81       	ldd	r24, Y+1	; 0x01
    5e1c:	9a 81       	ldd	r25, Y+2	; 0x02
    5e1e:	0c 96       	adiw	r24, 0x0c	; 12
    5e20:	0e 94 73 20 	call	0x40e6	; 0x40e6 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    5e24:	e9 81       	ldd	r30, Y+1	; 0x01
    5e26:	fa 81       	ldd	r31, Y+2	; 0x02
    5e28:	89 81       	ldd	r24, Y+1	; 0x01
    5e2a:	9a 81       	ldd	r25, Y+2	; 0x02
    5e2c:	91 87       	std	Z+9, r25	; 0x09
    5e2e:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    5e30:	8d 81       	ldd	r24, Y+5	; 0x05
    5e32:	28 2f       	mov	r18, r24
    5e34:	30 e0       	ldi	r19, 0x00	; 0
    5e36:	88 e0       	ldi	r24, 0x08	; 8
    5e38:	90 e0       	ldi	r25, 0x00	; 0
    5e3a:	82 1b       	sub	r24, r18
    5e3c:	93 0b       	sbc	r25, r19
    5e3e:	e9 81       	ldd	r30, Y+1	; 0x01
    5e40:	fa 81       	ldd	r31, Y+2	; 0x02
    5e42:	95 87       	std	Z+13, r25	; 0x0d
    5e44:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    5e46:	e9 81       	ldd	r30, Y+1	; 0x01
    5e48:	fa 81       	ldd	r31, Y+2	; 0x02
    5e4a:	89 81       	ldd	r24, Y+1	; 0x01
    5e4c:	9a 81       	ldd	r25, Y+2	; 0x02
    5e4e:	93 8b       	std	Z+19, r25	; 0x13
    5e50:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    5e52:	29 96       	adiw	r28, 0x09	; 9
    5e54:	0f b6       	in	r0, 0x3f	; 63
    5e56:	f8 94       	cli
    5e58:	de bf       	out	0x3e, r29	; 62
    5e5a:	0f be       	out	0x3f, r0	; 63
    5e5c:	cd bf       	out	0x3d, r28	; 61
    5e5e:	cf 91       	pop	r28
    5e60:	df 91       	pop	r29
    5e62:	1f 91       	pop	r17
    5e64:	0f 91       	pop	r16
    5e66:	08 95       	ret

00005e68 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    5e68:	df 93       	push	r29
    5e6a:	cf 93       	push	r28
    5e6c:	0f 92       	push	r0
    5e6e:	cd b7       	in	r28, 0x3d	; 61
    5e70:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    5e72:	19 82       	std	Y+1, r1	; 0x01
    5e74:	13 c0       	rjmp	.+38     	; 0x5e9c <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    5e76:	89 81       	ldd	r24, Y+1	; 0x01
    5e78:	28 2f       	mov	r18, r24
    5e7a:	30 e0       	ldi	r19, 0x00	; 0
    5e7c:	c9 01       	movw	r24, r18
    5e7e:	88 0f       	add	r24, r24
    5e80:	99 1f       	adc	r25, r25
    5e82:	88 0f       	add	r24, r24
    5e84:	99 1f       	adc	r25, r25
    5e86:	88 0f       	add	r24, r24
    5e88:	99 1f       	adc	r25, r25
    5e8a:	82 0f       	add	r24, r18
    5e8c:	93 1f       	adc	r25, r19
    5e8e:	86 5a       	subi	r24, 0xA6	; 166
    5e90:	98 4f       	sbci	r25, 0xF8	; 248
    5e92:	0e 94 49 20 	call	0x4092	; 0x4092 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    5e96:	89 81       	ldd	r24, Y+1	; 0x01
    5e98:	8f 5f       	subi	r24, 0xFF	; 255
    5e9a:	89 83       	std	Y+1, r24	; 0x01
    5e9c:	89 81       	ldd	r24, Y+1	; 0x01
    5e9e:	88 30       	cpi	r24, 0x08	; 8
    5ea0:	50 f3       	brcs	.-44     	; 0x5e76 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    5ea2:	82 ea       	ldi	r24, 0xA2	; 162
    5ea4:	97 e0       	ldi	r25, 0x07	; 7
    5ea6:	0e 94 49 20 	call	0x4092	; 0x4092 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    5eaa:	8b ea       	ldi	r24, 0xAB	; 171
    5eac:	97 e0       	ldi	r25, 0x07	; 7
    5eae:	0e 94 49 20 	call	0x4092	; 0x4092 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    5eb2:	88 eb       	ldi	r24, 0xB8	; 184
    5eb4:	97 e0       	ldi	r25, 0x07	; 7
    5eb6:	0e 94 49 20 	call	0x4092	; 0x4092 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    5eba:	81 ec       	ldi	r24, 0xC1	; 193
    5ebc:	97 e0       	ldi	r25, 0x07	; 7
    5ebe:	0e 94 49 20 	call	0x4092	; 0x4092 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5ec2:	82 ea       	ldi	r24, 0xA2	; 162
    5ec4:	97 e0       	ldi	r25, 0x07	; 7
    5ec6:	90 93 b5 07 	sts	0x07B5, r25
    5eca:	80 93 b4 07 	sts	0x07B4, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5ece:	8b ea       	ldi	r24, 0xAB	; 171
    5ed0:	97 e0       	ldi	r25, 0x07	; 7
    5ed2:	90 93 b7 07 	sts	0x07B7, r25
    5ed6:	80 93 b6 07 	sts	0x07B6, r24
}
    5eda:	0f 90       	pop	r0
    5edc:	cf 91       	pop	r28
    5ede:	df 91       	pop	r29
    5ee0:	08 95       	ret

00005ee2 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5ee2:	df 93       	push	r29
    5ee4:	cf 93       	push	r28
    5ee6:	00 d0       	rcall	.+0      	; 0x5ee8 <prvCheckTasksWaitingTermination+0x6>
    5ee8:	0f 92       	push	r0
    5eea:	cd b7       	in	r28, 0x3d	; 61
    5eec:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    5eee:	80 91 4e 07 	lds	r24, 0x074E
    5ef2:	88 23       	and	r24, r24
    5ef4:	71 f1       	breq	.+92     	; 0x5f52 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    5ef6:	0e 94 ab 2b 	call	0x5756	; 0x5756 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    5efa:	80 91 c1 07 	lds	r24, 0x07C1
    5efe:	1b 82       	std	Y+3, r1	; 0x03
    5f00:	88 23       	and	r24, r24
    5f02:	11 f4       	brne	.+4      	; 0x5f08 <prvCheckTasksWaitingTermination+0x26>
    5f04:	81 e0       	ldi	r24, 0x01	; 1
    5f06:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    5f08:	0e 94 b7 2b 	call	0x576e	; 0x576e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    5f0c:	8b 81       	ldd	r24, Y+3	; 0x03
    5f0e:	88 23       	and	r24, r24
    5f10:	01 f5       	brne	.+64     	; 0x5f52 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    5f12:	0f b6       	in	r0, 0x3f	; 63
    5f14:	f8 94       	cli
    5f16:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    5f18:	e0 91 c6 07 	lds	r30, 0x07C6
    5f1c:	f0 91 c7 07 	lds	r31, 0x07C7
    5f20:	86 81       	ldd	r24, Z+6	; 0x06
    5f22:	97 81       	ldd	r25, Z+7	; 0x07
    5f24:	9a 83       	std	Y+2, r25	; 0x02
    5f26:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    5f28:	89 81       	ldd	r24, Y+1	; 0x01
    5f2a:	9a 81       	ldd	r25, Y+2	; 0x02
    5f2c:	02 96       	adiw	r24, 0x02	; 2
    5f2e:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>
					--uxCurrentNumberOfTasks;
    5f32:	80 91 4f 07 	lds	r24, 0x074F
    5f36:	81 50       	subi	r24, 0x01	; 1
    5f38:	80 93 4f 07 	sts	0x074F, r24
					--uxTasksDeleted;
    5f3c:	80 91 4e 07 	lds	r24, 0x074E
    5f40:	81 50       	subi	r24, 0x01	; 1
    5f42:	80 93 4e 07 	sts	0x074E, r24
				}
				taskEXIT_CRITICAL();
    5f46:	0f 90       	pop	r0
    5f48:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    5f4a:	89 81       	ldd	r24, Y+1	; 0x01
    5f4c:	9a 81       	ldd	r25, Y+2	; 0x02
    5f4e:	0e 94 48 30 	call	0x6090	; 0x6090 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    5f52:	0f 90       	pop	r0
    5f54:	0f 90       	pop	r0
    5f56:	0f 90       	pop	r0
    5f58:	cf 91       	pop	r28
    5f5a:	df 91       	pop	r29
    5f5c:	08 95       	ret

00005f5e <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    5f5e:	df 93       	push	r29
    5f60:	cf 93       	push	r28
    5f62:	00 d0       	rcall	.+0      	; 0x5f64 <prvAddCurrentTaskToDelayedList+0x6>
    5f64:	cd b7       	in	r28, 0x3d	; 61
    5f66:	de b7       	in	r29, 0x3e	; 62
    5f68:	9a 83       	std	Y+2, r25	; 0x02
    5f6a:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    5f6c:	e0 91 4c 07 	lds	r30, 0x074C
    5f70:	f0 91 4d 07 	lds	r31, 0x074D
    5f74:	89 81       	ldd	r24, Y+1	; 0x01
    5f76:	9a 81       	ldd	r25, Y+2	; 0x02
    5f78:	93 83       	std	Z+3, r25	; 0x03
    5f7a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    5f7c:	20 91 50 07 	lds	r18, 0x0750
    5f80:	30 91 51 07 	lds	r19, 0x0751
    5f84:	89 81       	ldd	r24, Y+1	; 0x01
    5f86:	9a 81       	ldd	r25, Y+2	; 0x02
    5f88:	82 17       	cp	r24, r18
    5f8a:	93 07       	cpc	r25, r19
    5f8c:	70 f4       	brcc	.+28     	; 0x5faa <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5f8e:	80 91 b6 07 	lds	r24, 0x07B6
    5f92:	90 91 b7 07 	lds	r25, 0x07B7
    5f96:	20 91 4c 07 	lds	r18, 0x074C
    5f9a:	30 91 4d 07 	lds	r19, 0x074D
    5f9e:	2e 5f       	subi	r18, 0xFE	; 254
    5fa0:	3f 4f       	sbci	r19, 0xFF	; 255
    5fa2:	b9 01       	movw	r22, r18
    5fa4:	0e 94 cf 20 	call	0x419e	; 0x419e <vListInsert>
    5fa8:	1e c0       	rjmp	.+60     	; 0x5fe6 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5faa:	40 91 b4 07 	lds	r20, 0x07B4
    5fae:	50 91 b5 07 	lds	r21, 0x07B5
    5fb2:	80 91 4c 07 	lds	r24, 0x074C
    5fb6:	90 91 4d 07 	lds	r25, 0x074D
    5fba:	9c 01       	movw	r18, r24
    5fbc:	2e 5f       	subi	r18, 0xFE	; 254
    5fbe:	3f 4f       	sbci	r19, 0xFF	; 255
    5fc0:	ca 01       	movw	r24, r20
    5fc2:	b9 01       	movw	r22, r18
    5fc4:	0e 94 cf 20 	call	0x419e	; 0x419e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    5fc8:	20 91 bb 01 	lds	r18, 0x01BB
    5fcc:	30 91 bc 01 	lds	r19, 0x01BC
    5fd0:	89 81       	ldd	r24, Y+1	; 0x01
    5fd2:	9a 81       	ldd	r25, Y+2	; 0x02
    5fd4:	82 17       	cp	r24, r18
    5fd6:	93 07       	cpc	r25, r19
    5fd8:	30 f4       	brcc	.+12     	; 0x5fe6 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    5fda:	89 81       	ldd	r24, Y+1	; 0x01
    5fdc:	9a 81       	ldd	r25, Y+2	; 0x02
    5fde:	90 93 bc 01 	sts	0x01BC, r25
    5fe2:	80 93 bb 01 	sts	0x01BB, r24
		}
	}
}
    5fe6:	0f 90       	pop	r0
    5fe8:	0f 90       	pop	r0
    5fea:	cf 91       	pop	r28
    5fec:	df 91       	pop	r29
    5fee:	08 95       	ret

00005ff0 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    5ff0:	df 93       	push	r29
    5ff2:	cf 93       	push	r28
    5ff4:	cd b7       	in	r28, 0x3d	; 61
    5ff6:	de b7       	in	r29, 0x3e	; 62
    5ff8:	28 97       	sbiw	r28, 0x08	; 8
    5ffa:	0f b6       	in	r0, 0x3f	; 63
    5ffc:	f8 94       	cli
    5ffe:	de bf       	out	0x3e, r29	; 62
    6000:	0f be       	out	0x3f, r0	; 63
    6002:	cd bf       	out	0x3d, r28	; 61
    6004:	9c 83       	std	Y+4, r25	; 0x04
    6006:	8b 83       	std	Y+3, r24	; 0x03
    6008:	7e 83       	std	Y+6, r23	; 0x06
    600a:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    600c:	82 e2       	ldi	r24, 0x22	; 34
    600e:	90 e0       	ldi	r25, 0x00	; 0
    6010:	0e 94 dd 1f 	call	0x3fba	; 0x3fba <pvPortMalloc>
    6014:	9a 83       	std	Y+2, r25	; 0x02
    6016:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    6018:	89 81       	ldd	r24, Y+1	; 0x01
    601a:	9a 81       	ldd	r25, Y+2	; 0x02
    601c:	00 97       	sbiw	r24, 0x00	; 0
    601e:	69 f1       	breq	.+90     	; 0x607a <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    6020:	8d 81       	ldd	r24, Y+5	; 0x05
    6022:	9e 81       	ldd	r25, Y+6	; 0x06
    6024:	00 97       	sbiw	r24, 0x00	; 0
    6026:	39 f4       	brne	.+14     	; 0x6036 <prvAllocateTCBAndStack+0x46>
    6028:	8b 81       	ldd	r24, Y+3	; 0x03
    602a:	9c 81       	ldd	r25, Y+4	; 0x04
    602c:	0e 94 dd 1f 	call	0x3fba	; 0x3fba <pvPortMalloc>
    6030:	98 87       	std	Y+8, r25	; 0x08
    6032:	8f 83       	std	Y+7, r24	; 0x07
    6034:	04 c0       	rjmp	.+8      	; 0x603e <prvAllocateTCBAndStack+0x4e>
    6036:	8d 81       	ldd	r24, Y+5	; 0x05
    6038:	9e 81       	ldd	r25, Y+6	; 0x06
    603a:	98 87       	std	Y+8, r25	; 0x08
    603c:	8f 83       	std	Y+7, r24	; 0x07
    603e:	e9 81       	ldd	r30, Y+1	; 0x01
    6040:	fa 81       	ldd	r31, Y+2	; 0x02
    6042:	8f 81       	ldd	r24, Y+7	; 0x07
    6044:	98 85       	ldd	r25, Y+8	; 0x08
    6046:	90 8f       	std	Z+24, r25	; 0x18
    6048:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    604a:	e9 81       	ldd	r30, Y+1	; 0x01
    604c:	fa 81       	ldd	r31, Y+2	; 0x02
    604e:	87 89       	ldd	r24, Z+23	; 0x17
    6050:	90 8d       	ldd	r25, Z+24	; 0x18
    6052:	00 97       	sbiw	r24, 0x00	; 0
    6054:	39 f4       	brne	.+14     	; 0x6064 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    6056:	89 81       	ldd	r24, Y+1	; 0x01
    6058:	9a 81       	ldd	r25, Y+2	; 0x02
    605a:	0e 94 23 20 	call	0x4046	; 0x4046 <vPortFree>
			pxNewTCB = NULL;
    605e:	1a 82       	std	Y+2, r1	; 0x02
    6060:	19 82       	std	Y+1, r1	; 0x01
    6062:	0b c0       	rjmp	.+22     	; 0x607a <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    6064:	e9 81       	ldd	r30, Y+1	; 0x01
    6066:	fa 81       	ldd	r31, Y+2	; 0x02
    6068:	87 89       	ldd	r24, Z+23	; 0x17
    606a:	90 8d       	ldd	r25, Z+24	; 0x18
    606c:	2b 81       	ldd	r18, Y+3	; 0x03
    606e:	3c 81       	ldd	r19, Y+4	; 0x04
    6070:	65 ea       	ldi	r22, 0xA5	; 165
    6072:	70 e0       	ldi	r23, 0x00	; 0
    6074:	a9 01       	movw	r20, r18
    6076:	0e 94 69 37 	call	0x6ed2	; 0x6ed2 <memset>
		}
	}

	return pxNewTCB;
    607a:	89 81       	ldd	r24, Y+1	; 0x01
    607c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    607e:	28 96       	adiw	r28, 0x08	; 8
    6080:	0f b6       	in	r0, 0x3f	; 63
    6082:	f8 94       	cli
    6084:	de bf       	out	0x3e, r29	; 62
    6086:	0f be       	out	0x3f, r0	; 63
    6088:	cd bf       	out	0x3d, r28	; 61
    608a:	cf 91       	pop	r28
    608c:	df 91       	pop	r29
    608e:	08 95       	ret

00006090 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    6090:	df 93       	push	r29
    6092:	cf 93       	push	r28
    6094:	00 d0       	rcall	.+0      	; 0x6096 <prvDeleteTCB+0x6>
    6096:	cd b7       	in	r28, 0x3d	; 61
    6098:	de b7       	in	r29, 0x3e	; 62
    609a:	9a 83       	std	Y+2, r25	; 0x02
    609c:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    609e:	e9 81       	ldd	r30, Y+1	; 0x01
    60a0:	fa 81       	ldd	r31, Y+2	; 0x02
    60a2:	87 89       	ldd	r24, Z+23	; 0x17
    60a4:	90 8d       	ldd	r25, Z+24	; 0x18
    60a6:	0e 94 23 20 	call	0x4046	; 0x4046 <vPortFree>
		vPortFree( pxTCB );
    60aa:	89 81       	ldd	r24, Y+1	; 0x01
    60ac:	9a 81       	ldd	r25, Y+2	; 0x02
    60ae:	0e 94 23 20 	call	0x4046	; 0x4046 <vPortFree>
	}
    60b2:	0f 90       	pop	r0
    60b4:	0f 90       	pop	r0
    60b6:	cf 91       	pop	r28
    60b8:	df 91       	pop	r29
    60ba:	08 95       	ret

000060bc <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    60bc:	df 93       	push	r29
    60be:	cf 93       	push	r28
    60c0:	00 d0       	rcall	.+0      	; 0x60c2 <xTaskGetCurrentTaskHandle+0x6>
    60c2:	cd b7       	in	r28, 0x3d	; 61
    60c4:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    60c6:	80 91 4c 07 	lds	r24, 0x074C
    60ca:	90 91 4d 07 	lds	r25, 0x074D
    60ce:	9a 83       	std	Y+2, r25	; 0x02
    60d0:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    60d2:	89 81       	ldd	r24, Y+1	; 0x01
    60d4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    60d6:	0f 90       	pop	r0
    60d8:	0f 90       	pop	r0
    60da:	cf 91       	pop	r28
    60dc:	df 91       	pop	r29
    60de:	08 95       	ret

000060e0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    60e0:	df 93       	push	r29
    60e2:	cf 93       	push	r28
    60e4:	00 d0       	rcall	.+0      	; 0x60e6 <vTaskPriorityInherit+0x6>
    60e6:	00 d0       	rcall	.+0      	; 0x60e8 <vTaskPriorityInherit+0x8>
    60e8:	cd b7       	in	r28, 0x3d	; 61
    60ea:	de b7       	in	r29, 0x3e	; 62
    60ec:	9c 83       	std	Y+4, r25	; 0x04
    60ee:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    60f0:	8b 81       	ldd	r24, Y+3	; 0x03
    60f2:	9c 81       	ldd	r25, Y+4	; 0x04
    60f4:	9a 83       	std	Y+2, r25	; 0x02
    60f6:	89 83       	std	Y+1, r24	; 0x01

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    60f8:	e9 81       	ldd	r30, Y+1	; 0x01
    60fa:	fa 81       	ldd	r31, Y+2	; 0x02
    60fc:	96 89       	ldd	r25, Z+22	; 0x16
    60fe:	e0 91 4c 07 	lds	r30, 0x074C
    6102:	f0 91 4d 07 	lds	r31, 0x074D
    6106:	86 89       	ldd	r24, Z+22	; 0x16
    6108:	98 17       	cp	r25, r24
    610a:	08 f0       	brcs	.+2      	; 0x610e <vTaskPriorityInherit+0x2e>
    610c:	62 c0       	rjmp	.+196    	; 0x61d2 <vTaskPriorityInherit+0xf2>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    610e:	e0 91 4c 07 	lds	r30, 0x074C
    6112:	f0 91 4d 07 	lds	r31, 0x074D
    6116:	86 89       	ldd	r24, Z+22	; 0x16
    6118:	28 2f       	mov	r18, r24
    611a:	30 e0       	ldi	r19, 0x00	; 0
    611c:	88 e0       	ldi	r24, 0x08	; 8
    611e:	90 e0       	ldi	r25, 0x00	; 0
    6120:	82 1b       	sub	r24, r18
    6122:	93 0b       	sbc	r25, r19
    6124:	e9 81       	ldd	r30, Y+1	; 0x01
    6126:	fa 81       	ldd	r31, Y+2	; 0x02
    6128:	95 87       	std	Z+13, r25	; 0x0d
    612a:	84 87       	std	Z+12, r24	; 0x0c

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    612c:	e9 81       	ldd	r30, Y+1	; 0x01
    612e:	fa 81       	ldd	r31, Y+2	; 0x02
    6130:	42 85       	ldd	r20, Z+10	; 0x0a
    6132:	53 85       	ldd	r21, Z+11	; 0x0b
    6134:	e9 81       	ldd	r30, Y+1	; 0x01
    6136:	fa 81       	ldd	r31, Y+2	; 0x02
    6138:	86 89       	ldd	r24, Z+22	; 0x16
    613a:	28 2f       	mov	r18, r24
    613c:	30 e0       	ldi	r19, 0x00	; 0
    613e:	c9 01       	movw	r24, r18
    6140:	88 0f       	add	r24, r24
    6142:	99 1f       	adc	r25, r25
    6144:	88 0f       	add	r24, r24
    6146:	99 1f       	adc	r25, r25
    6148:	88 0f       	add	r24, r24
    614a:	99 1f       	adc	r25, r25
    614c:	82 0f       	add	r24, r18
    614e:	93 1f       	adc	r25, r19
    6150:	86 5a       	subi	r24, 0xA6	; 166
    6152:	98 4f       	sbci	r25, 0xF8	; 248
    6154:	48 17       	cp	r20, r24
    6156:	59 07       	cpc	r21, r25
    6158:	a1 f5       	brne	.+104    	; 0x61c2 <vTaskPriorityInherit+0xe2>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    615a:	89 81       	ldd	r24, Y+1	; 0x01
    615c:	9a 81       	ldd	r25, Y+2	; 0x02
    615e:	02 96       	adiw	r24, 0x02	; 2
    6160:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    6164:	e0 91 4c 07 	lds	r30, 0x074C
    6168:	f0 91 4d 07 	lds	r31, 0x074D
    616c:	86 89       	ldd	r24, Z+22	; 0x16
    616e:	e9 81       	ldd	r30, Y+1	; 0x01
    6170:	fa 81       	ldd	r31, Y+2	; 0x02
    6172:	86 8b       	std	Z+22, r24	; 0x16
				prvAddTaskToReadyQueue( pxTCB );
    6174:	e9 81       	ldd	r30, Y+1	; 0x01
    6176:	fa 81       	ldd	r31, Y+2	; 0x02
    6178:	96 89       	ldd	r25, Z+22	; 0x16
    617a:	80 91 53 07 	lds	r24, 0x0753
    617e:	89 17       	cp	r24, r25
    6180:	28 f4       	brcc	.+10     	; 0x618c <vTaskPriorityInherit+0xac>
    6182:	e9 81       	ldd	r30, Y+1	; 0x01
    6184:	fa 81       	ldd	r31, Y+2	; 0x02
    6186:	86 89       	ldd	r24, Z+22	; 0x16
    6188:	80 93 53 07 	sts	0x0753, r24
    618c:	e9 81       	ldd	r30, Y+1	; 0x01
    618e:	fa 81       	ldd	r31, Y+2	; 0x02
    6190:	86 89       	ldd	r24, Z+22	; 0x16
    6192:	28 2f       	mov	r18, r24
    6194:	30 e0       	ldi	r19, 0x00	; 0
    6196:	c9 01       	movw	r24, r18
    6198:	88 0f       	add	r24, r24
    619a:	99 1f       	adc	r25, r25
    619c:	88 0f       	add	r24, r24
    619e:	99 1f       	adc	r25, r25
    61a0:	88 0f       	add	r24, r24
    61a2:	99 1f       	adc	r25, r25
    61a4:	82 0f       	add	r24, r18
    61a6:	93 1f       	adc	r25, r19
    61a8:	ac 01       	movw	r20, r24
    61aa:	46 5a       	subi	r20, 0xA6	; 166
    61ac:	58 4f       	sbci	r21, 0xF8	; 248
    61ae:	89 81       	ldd	r24, Y+1	; 0x01
    61b0:	9a 81       	ldd	r25, Y+2	; 0x02
    61b2:	9c 01       	movw	r18, r24
    61b4:	2e 5f       	subi	r18, 0xFE	; 254
    61b6:	3f 4f       	sbci	r19, 0xFF	; 255
    61b8:	ca 01       	movw	r24, r20
    61ba:	b9 01       	movw	r22, r18
    61bc:	0e 94 83 20 	call	0x4106	; 0x4106 <vListInsertEnd>
    61c0:	08 c0       	rjmp	.+16     	; 0x61d2 <vTaskPriorityInherit+0xf2>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    61c2:	e0 91 4c 07 	lds	r30, 0x074C
    61c6:	f0 91 4d 07 	lds	r31, 0x074D
    61ca:	86 89       	ldd	r24, Z+22	; 0x16
    61cc:	e9 81       	ldd	r30, Y+1	; 0x01
    61ce:	fa 81       	ldd	r31, Y+2	; 0x02
    61d0:	86 8b       	std	Z+22, r24	; 0x16
			}
		}
	}
    61d2:	0f 90       	pop	r0
    61d4:	0f 90       	pop	r0
    61d6:	0f 90       	pop	r0
    61d8:	0f 90       	pop	r0
    61da:	cf 91       	pop	r28
    61dc:	df 91       	pop	r29
    61de:	08 95       	ret

000061e0 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    61e0:	df 93       	push	r29
    61e2:	cf 93       	push	r28
    61e4:	00 d0       	rcall	.+0      	; 0x61e6 <vTaskPriorityDisinherit+0x6>
    61e6:	00 d0       	rcall	.+0      	; 0x61e8 <vTaskPriorityDisinherit+0x8>
    61e8:	cd b7       	in	r28, 0x3d	; 61
    61ea:	de b7       	in	r29, 0x3e	; 62
    61ec:	9c 83       	std	Y+4, r25	; 0x04
    61ee:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    61f0:	8b 81       	ldd	r24, Y+3	; 0x03
    61f2:	9c 81       	ldd	r25, Y+4	; 0x04
    61f4:	9a 83       	std	Y+2, r25	; 0x02
    61f6:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    61f8:	8b 81       	ldd	r24, Y+3	; 0x03
    61fa:	9c 81       	ldd	r25, Y+4	; 0x04
    61fc:	00 97       	sbiw	r24, 0x00	; 0
    61fe:	09 f4       	brne	.+2      	; 0x6202 <vTaskPriorityDisinherit+0x22>
    6200:	47 c0       	rjmp	.+142    	; 0x6290 <vTaskPriorityDisinherit+0xb0>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    6202:	e9 81       	ldd	r30, Y+1	; 0x01
    6204:	fa 81       	ldd	r31, Y+2	; 0x02
    6206:	96 89       	ldd	r25, Z+22	; 0x16
    6208:	e9 81       	ldd	r30, Y+1	; 0x01
    620a:	fa 81       	ldd	r31, Y+2	; 0x02
    620c:	81 a1       	ldd	r24, Z+33	; 0x21
    620e:	98 17       	cp	r25, r24
    6210:	09 f4       	brne	.+2      	; 0x6214 <vTaskPriorityDisinherit+0x34>
    6212:	3e c0       	rjmp	.+124    	; 0x6290 <vTaskPriorityDisinherit+0xb0>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    6214:	89 81       	ldd	r24, Y+1	; 0x01
    6216:	9a 81       	ldd	r25, Y+2	; 0x02
    6218:	02 96       	adiw	r24, 0x02	; 2
    621a:	0e 94 3b 21 	call	0x4276	; 0x4276 <vListRemove>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    621e:	e9 81       	ldd	r30, Y+1	; 0x01
    6220:	fa 81       	ldd	r31, Y+2	; 0x02
    6222:	81 a1       	ldd	r24, Z+33	; 0x21
    6224:	e9 81       	ldd	r30, Y+1	; 0x01
    6226:	fa 81       	ldd	r31, Y+2	; 0x02
    6228:	86 8b       	std	Z+22, r24	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    622a:	e9 81       	ldd	r30, Y+1	; 0x01
    622c:	fa 81       	ldd	r31, Y+2	; 0x02
    622e:	86 89       	ldd	r24, Z+22	; 0x16
    6230:	28 2f       	mov	r18, r24
    6232:	30 e0       	ldi	r19, 0x00	; 0
    6234:	88 e0       	ldi	r24, 0x08	; 8
    6236:	90 e0       	ldi	r25, 0x00	; 0
    6238:	82 1b       	sub	r24, r18
    623a:	93 0b       	sbc	r25, r19
    623c:	e9 81       	ldd	r30, Y+1	; 0x01
    623e:	fa 81       	ldd	r31, Y+2	; 0x02
    6240:	95 87       	std	Z+13, r25	; 0x0d
    6242:	84 87       	std	Z+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    6244:	e9 81       	ldd	r30, Y+1	; 0x01
    6246:	fa 81       	ldd	r31, Y+2	; 0x02
    6248:	96 89       	ldd	r25, Z+22	; 0x16
    624a:	80 91 53 07 	lds	r24, 0x0753
    624e:	89 17       	cp	r24, r25
    6250:	28 f4       	brcc	.+10     	; 0x625c <vTaskPriorityDisinherit+0x7c>
    6252:	e9 81       	ldd	r30, Y+1	; 0x01
    6254:	fa 81       	ldd	r31, Y+2	; 0x02
    6256:	86 89       	ldd	r24, Z+22	; 0x16
    6258:	80 93 53 07 	sts	0x0753, r24
    625c:	e9 81       	ldd	r30, Y+1	; 0x01
    625e:	fa 81       	ldd	r31, Y+2	; 0x02
    6260:	86 89       	ldd	r24, Z+22	; 0x16
    6262:	28 2f       	mov	r18, r24
    6264:	30 e0       	ldi	r19, 0x00	; 0
    6266:	c9 01       	movw	r24, r18
    6268:	88 0f       	add	r24, r24
    626a:	99 1f       	adc	r25, r25
    626c:	88 0f       	add	r24, r24
    626e:	99 1f       	adc	r25, r25
    6270:	88 0f       	add	r24, r24
    6272:	99 1f       	adc	r25, r25
    6274:	82 0f       	add	r24, r18
    6276:	93 1f       	adc	r25, r19
    6278:	ac 01       	movw	r20, r24
    627a:	46 5a       	subi	r20, 0xA6	; 166
    627c:	58 4f       	sbci	r21, 0xF8	; 248
    627e:	89 81       	ldd	r24, Y+1	; 0x01
    6280:	9a 81       	ldd	r25, Y+2	; 0x02
    6282:	9c 01       	movw	r18, r24
    6284:	2e 5f       	subi	r18, 0xFE	; 254
    6286:	3f 4f       	sbci	r19, 0xFF	; 255
    6288:	ca 01       	movw	r24, r20
    628a:	b9 01       	movw	r22, r18
    628c:	0e 94 83 20 	call	0x4106	; 0x4106 <vListInsertEnd>
			}
		}
	}
    6290:	0f 90       	pop	r0
    6292:	0f 90       	pop	r0
    6294:	0f 90       	pop	r0
    6296:	0f 90       	pop	r0
    6298:	cf 91       	pop	r28
    629a:	df 91       	pop	r29
    629c:	08 95       	ret

0000629e <main>:
u16 _50_papers =  0;

STEPPER_t Stepper={PIN1,MDIO_PORTC,PIN2,MDIO_PORTC,PIN3,MDIO_PORTC,PIN4,MDIO_PORTC} ;

int main(void)
{
    629e:	af 92       	push	r10
    62a0:	bf 92       	push	r11
    62a2:	cf 92       	push	r12
    62a4:	df 92       	push	r13
    62a6:	ef 92       	push	r14
    62a8:	ff 92       	push	r15
    62aa:	0f 93       	push	r16
    62ac:	df 93       	push	r29
    62ae:	cf 93       	push	r28
    62b0:	cd b7       	in	r28, 0x3d	; 61
    62b2:	de b7       	in	r29, 0x3e	; 62
	/* DIO_Initialization */
	MDIO_Error_State_SetPinDirection(PIN0,MDIO_PORTC,PIN_INPUT);
    62b4:	80 e0       	ldi	r24, 0x00	; 0
    62b6:	62 e0       	ldi	r22, 0x02	; 2
    62b8:	40 e0       	ldi	r20, 0x00	; 0
    62ba:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	/* In case of simulation */
	MDIO_Error_State_SetPinValue(PIN0,MDIO_PORTC,PIN_HIGH);
    62be:	80 e0       	ldi	r24, 0x00	; 0
    62c0:	62 e0       	ldi	r22, 0x02	; 2
    62c2:	41 e0       	ldi	r20, 0x01	; 1
    62c4:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinDirection(PIN5,MDIO_PORTC,PIN_OUTPUT);
    62c8:	85 e0       	ldi	r24, 0x05	; 5
    62ca:	62 e0       	ldi	r22, 0x02	; 2
    62cc:	41 e0       	ldi	r20, 0x01	; 1
    62ce:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(PIN6,MDIO_PORTC,PIN_OUTPUT);
    62d2:	86 e0       	ldi	r24, 0x06	; 6
    62d4:	62 e0       	ldi	r22, 0x02	; 2
    62d6:	41 e0       	ldi	r20, 0x01	; 1
    62d8:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(PIN7,MDIO_PORTC,PIN_OUTPUT);
    62dc:	87 e0       	ldi	r24, 0x07	; 7
    62de:	62 e0       	ldi	r22, 0x02	; 2
    62e0:	41 e0       	ldi	r20, 0x01	; 1
    62e2:	0e 94 37 08 	call	0x106e	; 0x106e <MDIO_Error_State_SetPinDirection>

	/* Initialize Stepper*/
	HSTEPPER_VidInit(&Stepper);
    62e6:	8e ed       	ldi	r24, 0xDE	; 222
    62e8:	91 e0       	ldi	r25, 0x01	; 1
    62ea:	0e 94 fd 0c 	call	0x19fa	; 0x19fa <HSTEPPER_VidInit>

	/* Initialize LCD */
	HCLCD_Vid4Bits_Init();
    62ee:	0e 94 66 19 	call	0x32cc	; 0x32cc <HCLCD_Vid4Bits_Init>

	/* Initialize Keypad */
	HKPD_VidInit();
    62f2:	0e 94 3d 13 	call	0x267a	; 0x267a <HKPD_VidInit>

	/* Create Semaphore */
	Entry_sem =xSemaphoreCreateCounting(1,0);
    62f6:	81 e0       	ldi	r24, 0x01	; 1
    62f8:	60 e0       	ldi	r22, 0x00	; 0
    62fa:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <xQueueCreateCountingSemaphore>
    62fe:	90 93 e6 07 	sts	0x07E6, r25
    6302:	80 93 e5 07 	sts	0x07E5, r24

	/* Create Queues */
	Keypad_To_LCD_Queue 		 		= xQueueCreate(1,sizeof(u8));
    6306:	81 e0       	ldi	r24, 0x01	; 1
    6308:	61 e0       	ldi	r22, 0x01	; 1
    630a:	0e 94 56 24 	call	0x48ac	; 0x48ac <xQueueCreate>
    630e:	90 93 ed 07 	sts	0x07ED, r25
    6312:	80 93 ec 07 	sts	0x07EC, r24
	Keypad_To_CheckData_Queue1   		= xQueueCreate(1,sizeof(u8));
    6316:	81 e0       	ldi	r24, 0x01	; 1
    6318:	61 e0       	ldi	r22, 0x01	; 1
    631a:	0e 94 56 24 	call	0x48ac	; 0x48ac <xQueueCreate>
    631e:	90 93 eb 07 	sts	0x07EB, r25
    6322:	80 93 ea 07 	sts	0x07EA, r24
	Keypad_To_CheckData_Queue2  		= xQueueCreate(1,sizeof(u16));
    6326:	81 e0       	ldi	r24, 0x01	; 1
    6328:	62 e0       	ldi	r22, 0x02	; 2
    632a:	0e 94 56 24 	call	0x48ac	; 0x48ac <xQueueCreate>
    632e:	90 93 ef 07 	sts	0x07EF, r25
    6332:	80 93 ee 07 	sts	0x07EE, r24
	Keypad_To_CheckBalance_Queue 		= xQueueCreate(1,sizeof(u32));
    6336:	81 e0       	ldi	r24, 0x01	; 1
    6338:	64 e0       	ldi	r22, 0x04	; 4
    633a:	0e 94 56 24 	call	0x48ac	; 0x48ac <xQueueCreate>
    633e:	90 93 f3 07 	sts	0x07F3, r25
    6342:	80 93 f2 07 	sts	0x07F2, r24
	CheckData_To_Balance_Queue 			= xQueueCreate(1,sizeof(u8));
    6346:	81 e0       	ldi	r24, 0x01	; 1
    6348:	61 e0       	ldi	r22, 0x01	; 1
    634a:	0e 94 56 24 	call	0x48ac	; 0x48ac <xQueueCreate>
    634e:	90 93 e9 07 	sts	0x07E9, r25
    6352:	80 93 e8 07 	sts	0x07E8, r24
	CheckBalance_To_Calculation_Queue 	= xQueueCreate(1,sizeof(u32));
    6356:	81 e0       	ldi	r24, 0x01	; 1
    6358:	64 e0       	ldi	r22, 0x04	; 4
    635a:	0e 94 56 24 	call	0x48ac	; 0x48ac <xQueueCreate>
    635e:	90 93 f1 07 	sts	0x07F1, r25
    6362:	80 93 f0 07 	sts	0x07F0, r24

	/* Create_Tasks */
	xTaskCreate(LCD_Display			  ,NULL,150,NULL,2,NULL);
    6366:	8e ea       	ldi	r24, 0xAE	; 174
    6368:	95 e3       	ldi	r25, 0x35	; 53
    636a:	60 e0       	ldi	r22, 0x00	; 0
    636c:	70 e0       	ldi	r23, 0x00	; 0
    636e:	46 e9       	ldi	r20, 0x96	; 150
    6370:	50 e0       	ldi	r21, 0x00	; 0
    6372:	20 e0       	ldi	r18, 0x00	; 0
    6374:	30 e0       	ldi	r19, 0x00	; 0
    6376:	02 e0       	ldi	r16, 0x02	; 2
    6378:	ee 24       	eor	r14, r14
    637a:	ff 24       	eor	r15, r15
    637c:	cc 24       	eor	r12, r12
    637e:	dd 24       	eor	r13, r13
    6380:	aa 24       	eor	r10, r10
    6382:	bb 24       	eor	r11, r11
    6384:	0e 94 6f 29 	call	0x52de	; 0x52de <xTaskGenericCreate>
	xTaskCreate(Credit_Entry_Button   ,NULL,50 ,NULL,0,NULL);
    6388:	8a ef       	ldi	r24, 0xFA	; 250
    638a:	91 e3       	ldi	r25, 0x31	; 49
    638c:	60 e0       	ldi	r22, 0x00	; 0
    638e:	70 e0       	ldi	r23, 0x00	; 0
    6390:	42 e3       	ldi	r20, 0x32	; 50
    6392:	50 e0       	ldi	r21, 0x00	; 0
    6394:	20 e0       	ldi	r18, 0x00	; 0
    6396:	30 e0       	ldi	r19, 0x00	; 0
    6398:	00 e0       	ldi	r16, 0x00	; 0
    639a:	ee 24       	eor	r14, r14
    639c:	ff 24       	eor	r15, r15
    639e:	cc 24       	eor	r12, r12
    63a0:	dd 24       	eor	r13, r13
    63a2:	aa 24       	eor	r10, r10
    63a4:	bb 24       	eor	r11, r11
    63a6:	0e 94 6f 29 	call	0x52de	; 0x52de <xTaskGenericCreate>
	xTaskCreate(Get_Pressed_Key  	  ,NULL,100,NULL,1,NULL);
    63aa:	81 e2       	ldi	r24, 0x21	; 33
    63ac:	92 e3       	ldi	r25, 0x32	; 50
    63ae:	60 e0       	ldi	r22, 0x00	; 0
    63b0:	70 e0       	ldi	r23, 0x00	; 0
    63b2:	44 e6       	ldi	r20, 0x64	; 100
    63b4:	50 e0       	ldi	r21, 0x00	; 0
    63b6:	20 e0       	ldi	r18, 0x00	; 0
    63b8:	30 e0       	ldi	r19, 0x00	; 0
    63ba:	01 e0       	ldi	r16, 0x01	; 1
    63bc:	ee 24       	eor	r14, r14
    63be:	ff 24       	eor	r15, r15
    63c0:	cc 24       	eor	r12, r12
    63c2:	dd 24       	eor	r13, r13
    63c4:	aa 24       	eor	r10, r10
    63c6:	bb 24       	eor	r11, r11
    63c8:	0e 94 6f 29 	call	0x52de	; 0x52de <xTaskGenericCreate>
	xTaskCreate(Check_User_Data  	  ,NULL,100,NULL,3,NULL);
    63cc:	8b e3       	ldi	r24, 0x3B	; 59
    63ce:	93 e3       	ldi	r25, 0x33	; 51
    63d0:	60 e0       	ldi	r22, 0x00	; 0
    63d2:	70 e0       	ldi	r23, 0x00	; 0
    63d4:	44 e6       	ldi	r20, 0x64	; 100
    63d6:	50 e0       	ldi	r21, 0x00	; 0
    63d8:	20 e0       	ldi	r18, 0x00	; 0
    63da:	30 e0       	ldi	r19, 0x00	; 0
    63dc:	03 e0       	ldi	r16, 0x03	; 3
    63de:	ee 24       	eor	r14, r14
    63e0:	ff 24       	eor	r15, r15
    63e2:	cc 24       	eor	r12, r12
    63e4:	dd 24       	eor	r13, r13
    63e6:	aa 24       	eor	r10, r10
    63e8:	bb 24       	eor	r11, r11
    63ea:	0e 94 6f 29 	call	0x52de	; 0x52de <xTaskGenericCreate>
	//xTaskCreate(Check_Balance	 	  ,NULL,100,NULL,4,NULL);
	//xTaskCreate(Calc	  			  ,NULL,120,NULL,5,NULL);
	//xTaskCreate(APP_Output_Money	  ,NULL,200,NULL,6,NULL);

	/* Start Scheduler */
	vTaskStartScheduler();
    63ee:	0e 94 68 2b 	call	0x56d0	; 0x56d0 <vTaskStartScheduler>
    63f2:	ff cf       	rjmp	.-2      	; 0x63f2 <main+0x154>

000063f4 <Credit_Entry_Button>:
	}
	return 0;
}

void Credit_Entry_Button(void*pv)
{
    63f4:	df 93       	push	r29
    63f6:	cf 93       	push	r28
    63f8:	00 d0       	rcall	.+0      	; 0x63fa <Credit_Entry_Button+0x6>
    63fa:	cd b7       	in	r28, 0x3d	; 61
    63fc:	de b7       	in	r29, 0x3e	; 62
    63fe:	9a 83       	std	Y+2, r25	; 0x02
    6400:	89 83       	std	Y+1, r24	; 0x01
	static u8 Loc_u8Btn_State = BTN_NOT_PRESSED;
	while(1)
	{
		MDIO_Error_State_GetPinValue(PIN0,MDIO_PORTC,&Loc_u8Btn_State);
    6402:	26 ee       	ldi	r18, 0xE6	; 230
    6404:	31 e0       	ldi	r19, 0x01	; 1
    6406:	80 e0       	ldi	r24, 0x00	; 0
    6408:	62 e0       	ldi	r22, 0x02	; 2
    640a:	a9 01       	movw	r20, r18
    640c:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <MDIO_Error_State_GetPinValue>
		if(Loc_u8Btn_State == BTN_PRESSED)
    6410:	80 91 e6 01 	lds	r24, 0x01E6
    6414:	88 23       	and	r24, r24
    6416:	81 f4       	brne	.+32     	; 0x6438 <Credit_Entry_Button+0x44>
		{
			xSemaphoreGive(Entry_sem);
    6418:	80 91 e5 07 	lds	r24, 0x07E5
    641c:	90 91 e6 07 	lds	r25, 0x07E6
    6420:	60 e0       	ldi	r22, 0x00	; 0
    6422:	70 e0       	ldi	r23, 0x00	; 0
    6424:	40 e0       	ldi	r20, 0x00	; 0
    6426:	50 e0       	ldi	r21, 0x00	; 0
    6428:	20 e0       	ldi	r18, 0x00	; 0
    642a:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xQueueGenericSend>
			LCD_FLAG = LCD_USER_DATA_ID;
    642e:	81 e0       	ldi	r24, 0x01	; 1
    6430:	80 93 ca 07 	sts	0x07CA, r24
			KEYPAD_FLAG = KEYPAD_ID;
    6434:	10 92 e7 07 	sts	0x07E7, r1
		else
		{
			/* Do Nothing */
		}

		vTaskDelay(100);
    6438:	84 e6       	ldi	r24, 0x64	; 100
    643a:	90 e0       	ldi	r25, 0x00	; 0
    643c:	0e 94 33 2b 	call	0x5666	; 0x5666 <vTaskDelay>
    6440:	e0 cf       	rjmp	.-64     	; 0x6402 <Credit_Entry_Button+0xe>

00006442 <Get_Pressed_Key>:
	}
}

void Get_Pressed_Key(void *pv){
    6442:	df 93       	push	r29
    6444:	cf 93       	push	r28
    6446:	cd b7       	in	r28, 0x3d	; 61
    6448:	de b7       	in	r29, 0x3e	; 62
    644a:	27 97       	sbiw	r28, 0x07	; 7
    644c:	0f b6       	in	r0, 0x3f	; 63
    644e:	f8 94       	cli
    6450:	de bf       	out	0x3e, r29	; 62
    6452:	0f be       	out	0x3f, r0	; 63
    6454:	cd bf       	out	0x3d, r28	; 61
    6456:	9d 83       	std	Y+5, r25	; 0x05
    6458:	8c 83       	std	Y+4, r24	; 0x04

	u8 Loc_u8PressedKey;
	u8 Loc_u8Entry_semState = 2;
    645a:	82 e0       	ldi	r24, 0x02	; 2
    645c:	8a 83       	std	Y+2, r24	; 0x02
	u8 x;

	while(1)
	{

		Loc_u8Entry_semState = xSemaphoreTake(Entry_sem,5);
    645e:	80 91 e5 07 	lds	r24, 0x07E5
    6462:	90 91 e6 07 	lds	r25, 0x07E6
    6466:	60 e0       	ldi	r22, 0x00	; 0
    6468:	70 e0       	ldi	r23, 0x00	; 0
    646a:	45 e0       	ldi	r20, 0x05	; 5
    646c:	50 e0       	ldi	r21, 0x00	; 0
    646e:	20 e0       	ldi	r18, 0x00	; 0
    6470:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <xQueueGenericReceive>
    6474:	8a 83       	std	Y+2, r24	; 0x02
		if(Loc_u8Entry_semState == pdPASS)
    6476:	8a 81       	ldd	r24, Y+2	; 0x02
    6478:	81 30       	cpi	r24, 0x01	; 1
    647a:	09 f0       	breq	.+2      	; 0x647e <Get_Pressed_Key+0x3c>
    647c:	f7 c0       	rjmp	.+494    	; 0x666c <Get_Pressed_Key+0x22a>
		{
			Loc_u8PressedKey = HKPD_u8GetKeyPressed();
    647e:	0e 94 94 13 	call	0x2728	; 0x2728 <HKPD_u8GetKeyPressed>
    6482:	8b 83       	std	Y+3, r24	; 0x03

			if(Loc_u8PressedKey != NOT_PRESSED)
    6484:	8b 81       	ldd	r24, Y+3	; 0x03
    6486:	8f 3f       	cpi	r24, 0xFF	; 255
    6488:	09 f4       	brne	.+2      	; 0x648c <Get_Pressed_Key+0x4a>
    648a:	e5 c0       	rjmp	.+458    	; 0x6656 <Get_Pressed_Key+0x214>
			{
				if(Loc_u8PressedKey != '='){
    648c:	8b 81       	ldd	r24, Y+3	; 0x03
    648e:	8d 33       	cpi	r24, 0x3D	; 61
    6490:	69 f0       	breq	.+26     	; 0x64ac <Get_Pressed_Key+0x6a>
					xQueueSend(Keypad_To_LCD_Queue,&Loc_u8PressedKey,0);
    6492:	80 91 ec 07 	lds	r24, 0x07EC
    6496:	90 91 ed 07 	lds	r25, 0x07ED
    649a:	9e 01       	movw	r18, r28
    649c:	2d 5f       	subi	r18, 0xFD	; 253
    649e:	3f 4f       	sbci	r19, 0xFF	; 255
    64a0:	b9 01       	movw	r22, r18
    64a2:	40 e0       	ldi	r20, 0x00	; 0
    64a4:	50 e0       	ldi	r21, 0x00	; 0
    64a6:	20 e0       	ldi	r18, 0x00	; 0
    64a8:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xQueueGenericSend>
				}
				switch(KEYPAD_FLAG){
    64ac:	80 91 e7 07 	lds	r24, 0x07E7
    64b0:	28 2f       	mov	r18, r24
    64b2:	30 e0       	ldi	r19, 0x00	; 0
    64b4:	3f 83       	std	Y+7, r19	; 0x07
    64b6:	2e 83       	std	Y+6, r18	; 0x06
    64b8:	8e 81       	ldd	r24, Y+6	; 0x06
    64ba:	9f 81       	ldd	r25, Y+7	; 0x07
    64bc:	81 30       	cpi	r24, 0x01	; 1
    64be:	91 05       	cpc	r25, r1
    64c0:	e9 f1       	breq	.+122    	; 0x653c <Get_Pressed_Key+0xfa>
    64c2:	2e 81       	ldd	r18, Y+6	; 0x06
    64c4:	3f 81       	ldd	r19, Y+7	; 0x07
    64c6:	25 30       	cpi	r18, 0x05	; 5
    64c8:	31 05       	cpc	r19, r1
    64ca:	09 f4       	brne	.+2      	; 0x64ce <Get_Pressed_Key+0x8c>
    64cc:	81 c0       	rjmp	.+258    	; 0x65d0 <Get_Pressed_Key+0x18e>
    64ce:	8e 81       	ldd	r24, Y+6	; 0x06
    64d0:	9f 81       	ldd	r25, Y+7	; 0x07
    64d2:	00 97       	sbiw	r24, 0x00	; 0
    64d4:	09 f0       	breq	.+2      	; 0x64d8 <Get_Pressed_Key+0x96>
    64d6:	bf c0       	rjmp	.+382    	; 0x6656 <Get_Pressed_Key+0x214>
				case KEYPAD_ID:
					Loc_u8PressedKey -= 48;
    64d8:	8b 81       	ldd	r24, Y+3	; 0x03
    64da:	80 53       	subi	r24, 0x30	; 48
    64dc:	8b 83       	std	Y+3, r24	; 0x03
					Loc_u8ID = (Loc_u8ID * 10) + Loc_u8PressedKey;
    64de:	80 91 d5 07 	lds	r24, 0x07D5
    64e2:	88 2f       	mov	r24, r24
    64e4:	90 e0       	ldi	r25, 0x00	; 0
    64e6:	9c 01       	movw	r18, r24
    64e8:	22 0f       	add	r18, r18
    64ea:	33 1f       	adc	r19, r19
    64ec:	c9 01       	movw	r24, r18
    64ee:	88 0f       	add	r24, r24
    64f0:	99 1f       	adc	r25, r25
    64f2:	88 0f       	add	r24, r24
    64f4:	99 1f       	adc	r25, r25
    64f6:	82 0f       	add	r24, r18
    64f8:	93 1f       	adc	r25, r19
    64fa:	98 2f       	mov	r25, r24
    64fc:	8b 81       	ldd	r24, Y+3	; 0x03
    64fe:	89 0f       	add	r24, r25
    6500:	80 93 d5 07 	sts	0x07D5, r24

					Loc_u8Entry_count ++;
    6504:	80 91 e7 01 	lds	r24, 0x01E7
    6508:	8f 5f       	subi	r24, 0xFF	; 255
    650a:	80 93 e7 01 	sts	0x01E7, r24

					if (Loc_u8Entry_count == 3)
    650e:	80 91 e7 01 	lds	r24, 0x01E7
    6512:	83 30       	cpi	r24, 0x03	; 3
    6514:	09 f0       	breq	.+2      	; 0x6518 <Get_Pressed_Key+0xd6>
    6516:	9f c0       	rjmp	.+318    	; 0x6656 <Get_Pressed_Key+0x214>
					{

						xQueueSend(Keypad_To_CheckData_Queue1,&Loc_u8ID,0);
    6518:	80 91 ea 07 	lds	r24, 0x07EA
    651c:	90 91 eb 07 	lds	r25, 0x07EB
    6520:	25 ed       	ldi	r18, 0xD5	; 213
    6522:	37 e0       	ldi	r19, 0x07	; 7
    6524:	b9 01       	movw	r22, r18
    6526:	40 e0       	ldi	r20, 0x00	; 0
    6528:	50 e0       	ldi	r21, 0x00	; 0
    652a:	20 e0       	ldi	r18, 0x00	; 0
    652c:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xQueueGenericSend>
						Loc_u8ID = 0;
    6530:	10 92 d5 07 	sts	0x07D5, r1
						Loc_u8Entry_count = 1;
    6534:	81 e0       	ldi	r24, 0x01	; 1
    6536:	80 93 e7 01 	sts	0x01E7, r24
    653a:	8d c0       	rjmp	.+282    	; 0x6656 <Get_Pressed_Key+0x214>
					}
					break;

				case KEYPAD_PASS:
					//HCLCD_VidWriteNumber_4Bits(Loc_u8Entry_count);
					LCD_FLAG  = LCD_USER_DATA_PASS;
    653c:	82 e0       	ldi	r24, 0x02	; 2
    653e:	80 93 ca 07 	sts	0x07CA, r24

					Loc_u8PressedKey -= 48;
    6542:	8b 81       	ldd	r24, Y+3	; 0x03
    6544:	80 53       	subi	r24, 0x30	; 48
    6546:	8b 83       	std	Y+3, r24	; 0x03
					Loc_u16Pass = (Loc_u16Pass * 10) + Loc_u8PressedKey;
    6548:	80 91 d3 07 	lds	r24, 0x07D3
    654c:	90 91 d4 07 	lds	r25, 0x07D4
    6550:	9c 01       	movw	r18, r24
    6552:	22 0f       	add	r18, r18
    6554:	33 1f       	adc	r19, r19
    6556:	c9 01       	movw	r24, r18
    6558:	88 0f       	add	r24, r24
    655a:	99 1f       	adc	r25, r25
    655c:	88 0f       	add	r24, r24
    655e:	99 1f       	adc	r25, r25
    6560:	28 0f       	add	r18, r24
    6562:	39 1f       	adc	r19, r25
    6564:	8b 81       	ldd	r24, Y+3	; 0x03
    6566:	88 2f       	mov	r24, r24
    6568:	90 e0       	ldi	r25, 0x00	; 0
    656a:	82 0f       	add	r24, r18
    656c:	93 1f       	adc	r25, r19
    656e:	90 93 d4 07 	sts	0x07D4, r25
    6572:	80 93 d3 07 	sts	0x07D3, r24
					Loc_u8Entry_count ++;
    6576:	80 91 e7 01 	lds	r24, 0x01E7
    657a:	8f 5f       	subi	r24, 0xFF	; 255
    657c:	80 93 e7 01 	sts	0x01E7, r24
					if (Loc_u8Entry_count == 5)
    6580:	80 91 e7 01 	lds	r24, 0x01E7
    6584:	85 30       	cpi	r24, 0x05	; 5
    6586:	09 f0       	breq	.+2      	; 0x658a <Get_Pressed_Key+0x148>
    6588:	66 c0       	rjmp	.+204    	; 0x6656 <Get_Pressed_Key+0x214>
					{

						x = xQueueSend(Keypad_To_CheckData_Queue2,&Loc_u16Pass,0);
    658a:	80 91 ee 07 	lds	r24, 0x07EE
    658e:	90 91 ef 07 	lds	r25, 0x07EF
    6592:	23 ed       	ldi	r18, 0xD3	; 211
    6594:	37 e0       	ldi	r19, 0x07	; 7
    6596:	b9 01       	movw	r22, r18
    6598:	40 e0       	ldi	r20, 0x00	; 0
    659a:	50 e0       	ldi	r21, 0x00	; 0
    659c:	20 e0       	ldi	r18, 0x00	; 0
    659e:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xQueueGenericSend>
    65a2:	89 83       	std	Y+1, r24	; 0x01
						if(x==pdPASS){
    65a4:	89 81       	ldd	r24, Y+1	; 0x01
    65a6:	81 30       	cpi	r24, 0x01	; 1
    65a8:	59 f4       	brne	.+22     	; 0x65c0 <Get_Pressed_Key+0x17e>
							HCLCD_VidWriteNumber_4Bits(Loc_u16Pass);
    65aa:	80 91 d3 07 	lds	r24, 0x07D3
    65ae:	90 91 d4 07 	lds	r25, 0x07D4
    65b2:	cc 01       	movw	r24, r24
    65b4:	a0 e0       	ldi	r26, 0x00	; 0
    65b6:	b0 e0       	ldi	r27, 0x00	; 0
    65b8:	bc 01       	movw	r22, r24
    65ba:	cd 01       	movw	r24, r26
    65bc:	0e 94 4f 1c 	call	0x389e	; 0x389e <HCLCD_VidWriteNumber_4Bits>
						}
						Loc_u8Entry_count = 1;
    65c0:	81 e0       	ldi	r24, 0x01	; 1
    65c2:	80 93 e7 01 	sts	0x01E7, r24
						Loc_u16Pass = 0;
    65c6:	10 92 d4 07 	sts	0x07D4, r1
    65ca:	10 92 d3 07 	sts	0x07D3, r1
    65ce:	43 c0       	rjmp	.+134    	; 0x6656 <Get_Pressed_Key+0x214>
					}
					break;

				case KEYPAD_DRAW_VALUE:
					LCD_FLAG = LCD_DRAW_OPTION;
    65d0:	86 e0       	ldi	r24, 0x06	; 6
    65d2:	80 93 ca 07 	sts	0x07CA, r24
					if(Loc_u8PressedKey != '=')
    65d6:	8b 81       	ldd	r24, Y+3	; 0x03
    65d8:	8d 33       	cpi	r24, 0x3D	; 61
    65da:	39 f1       	breq	.+78     	; 0x662a <Get_Pressed_Key+0x1e8>
					{
						Loc_u8PressedKey -= 48;
    65dc:	8b 81       	ldd	r24, Y+3	; 0x03
    65de:	80 53       	subi	r24, 0x30	; 48
    65e0:	8b 83       	std	Y+3, r24	; 0x03
						Loc_u32DrawValue = (Loc_u32DrawValue * 10) + Loc_u8PressedKey;
    65e2:	80 91 cf 07 	lds	r24, 0x07CF
    65e6:	90 91 d0 07 	lds	r25, 0x07D0
    65ea:	a0 91 d1 07 	lds	r26, 0x07D1
    65ee:	b0 91 d2 07 	lds	r27, 0x07D2
    65f2:	2a e0       	ldi	r18, 0x0A	; 10
    65f4:	30 e0       	ldi	r19, 0x00	; 0
    65f6:	40 e0       	ldi	r20, 0x00	; 0
    65f8:	50 e0       	ldi	r21, 0x00	; 0
    65fa:	bc 01       	movw	r22, r24
    65fc:	cd 01       	movw	r24, r26
    65fe:	0e 94 e8 36 	call	0x6dd0	; 0x6dd0 <__mulsi3>
    6602:	9b 01       	movw	r18, r22
    6604:	ac 01       	movw	r20, r24
    6606:	8b 81       	ldd	r24, Y+3	; 0x03
    6608:	88 2f       	mov	r24, r24
    660a:	90 e0       	ldi	r25, 0x00	; 0
    660c:	a0 e0       	ldi	r26, 0x00	; 0
    660e:	b0 e0       	ldi	r27, 0x00	; 0
    6610:	82 0f       	add	r24, r18
    6612:	93 1f       	adc	r25, r19
    6614:	a4 1f       	adc	r26, r20
    6616:	b5 1f       	adc	r27, r21
    6618:	80 93 cf 07 	sts	0x07CF, r24
    661c:	90 93 d0 07 	sts	0x07D0, r25
    6620:	a0 93 d1 07 	sts	0x07D1, r26
    6624:	b0 93 d2 07 	sts	0x07D2, r27
    6628:	16 c0       	rjmp	.+44     	; 0x6656 <Get_Pressed_Key+0x214>
					}
					else
					{
						xQueueSend(Keypad_To_CheckBalance_Queue,&Loc_u32DrawValue,0);
    662a:	80 91 f2 07 	lds	r24, 0x07F2
    662e:	90 91 f3 07 	lds	r25, 0x07F3
    6632:	2f ec       	ldi	r18, 0xCF	; 207
    6634:	37 e0       	ldi	r19, 0x07	; 7
    6636:	b9 01       	movw	r22, r18
    6638:	40 e0       	ldi	r20, 0x00	; 0
    663a:	50 e0       	ldi	r21, 0x00	; 0
    663c:	20 e0       	ldi	r18, 0x00	; 0
    663e:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xQueueGenericSend>
						Loc_u32DrawValue = 0;
    6642:	10 92 cf 07 	sts	0x07CF, r1
    6646:	10 92 d0 07 	sts	0x07D0, r1
    664a:	10 92 d1 07 	sts	0x07D1, r1
    664e:	10 92 d2 07 	sts	0x07D2, r1
						KEYPAD_FLAG = KEYPAD_ID;
    6652:	10 92 e7 07 	sts	0x07E7, r1
					}
					break;
				}

			}
			xSemaphoreGive(Entry_sem);
    6656:	80 91 e5 07 	lds	r24, 0x07E5
    665a:	90 91 e6 07 	lds	r25, 0x07E6
    665e:	60 e0       	ldi	r22, 0x00	; 0
    6660:	70 e0       	ldi	r23, 0x00	; 0
    6662:	40 e0       	ldi	r20, 0x00	; 0
    6664:	50 e0       	ldi	r21, 0x00	; 0
    6666:	20 e0       	ldi	r18, 0x00	; 0
    6668:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xQueueGenericSend>
		}
		vTaskDelay(100);
    666c:	84 e6       	ldi	r24, 0x64	; 100
    666e:	90 e0       	ldi	r25, 0x00	; 0
    6670:	0e 94 33 2b 	call	0x5666	; 0x5666 <vTaskDelay>
    6674:	f4 ce       	rjmp	.-536    	; 0x645e <Get_Pressed_Key+0x1c>

00006676 <Check_User_Data>:
	}
}

void Check_User_Data(void *pv){
    6676:	df 93       	push	r29
    6678:	cf 93       	push	r28
    667a:	cd b7       	in	r28, 0x3d	; 61
    667c:	de b7       	in	r29, 0x3e	; 62
    667e:	28 97       	sbiw	r28, 0x08	; 8
    6680:	0f b6       	in	r0, 0x3f	; 63
    6682:	f8 94       	cli
    6684:	de bf       	out	0x3e, r29	; 62
    6686:	0f be       	out	0x3f, r0	; 63
    6688:	cd bf       	out	0x3d, r28	; 61
    668a:	98 87       	std	Y+8, r25	; 0x08
    668c:	8f 83       	std	Y+7, r24	; 0x07

	u8 Loc_u8QueueState;
	u8 Loc_u8ID = 0;
    668e:	1b 82       	std	Y+3, r1	; 0x03
	u16 Loc_u16Password = 0;
    6690:	1d 82       	std	Y+5, r1	; 0x05
    6692:	1c 82       	std	Y+4, r1	; 0x04
	static u8 Loc_u8UserAvailableFlag = 2;

	while(1)
	{
		//Receive ID From the Keypad
		Loc_u8QueueState = xQueueReceive(Keypad_To_CheckData_Queue1,&Loc_u8ID,5);
    6694:	80 91 ea 07 	lds	r24, 0x07EA
    6698:	90 91 eb 07 	lds	r25, 0x07EB
    669c:	9e 01       	movw	r18, r28
    669e:	2d 5f       	subi	r18, 0xFD	; 253
    66a0:	3f 4f       	sbci	r19, 0xFF	; 255
    66a2:	b9 01       	movw	r22, r18
    66a4:	45 e0       	ldi	r20, 0x05	; 5
    66a6:	50 e0       	ldi	r21, 0x00	; 0
    66a8:	20 e0       	ldi	r18, 0x00	; 0
    66aa:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <xQueueGenericReceive>
    66ae:	8a 83       	std	Y+2, r24	; 0x02
		if(Loc_u8QueueState == pdPASS)
    66b0:	8a 81       	ldd	r24, Y+2	; 0x02
    66b2:	81 30       	cpi	r24, 0x01	; 1
    66b4:	51 f5       	brne	.+84     	; 0x670a <Check_User_Data+0x94>
		{
			//ID Received Successfully
			/*1-Checking ID is Existing*/
			for(Loc_u8UserOrder =0 ; Loc_u8UserOrder < (sizeof(USER_ARR) / sizeof(USER_ARR[0])) ; Loc_u8UserOrder ++)
    66b6:	19 82       	std	Y+1, r1	; 0x01
    66b8:	1a c0       	rjmp	.+52     	; 0x66ee <Check_User_Data+0x78>
			{
				if(Loc_u8ID == USER_ARR[Loc_u8UserOrder].id)
    66ba:	89 81       	ldd	r24, Y+1	; 0x01
    66bc:	28 2f       	mov	r18, r24
    66be:	30 e0       	ldi	r19, 0x00	; 0
    66c0:	c9 01       	movw	r24, r18
    66c2:	88 0f       	add	r24, r24
    66c4:	99 1f       	adc	r25, r25
    66c6:	88 0f       	add	r24, r24
    66c8:	99 1f       	adc	r25, r25
    66ca:	82 0f       	add	r24, r18
    66cc:	93 1f       	adc	r25, r19
    66ce:	fc 01       	movw	r30, r24
    66d0:	eb 53       	subi	r30, 0x3B	; 59
    66d2:	fe 4f       	sbci	r31, 0xFE	; 254
    66d4:	90 81       	ld	r25, Z
    66d6:	8b 81       	ldd	r24, Y+3	; 0x03
    66d8:	98 17       	cp	r25, r24
    66da:	31 f4       	brne	.+12     	; 0x66e8 <Check_User_Data+0x72>
				{
					//User is  Found
					Loc_u8UserAvailableFlag = 1;
    66dc:	81 e0       	ldi	r24, 0x01	; 1
    66de:	80 93 e8 01 	sts	0x01E8, r24
					//Save The user order form database
					Loc_u8Location_of_User = Loc_u8UserOrder;
    66e2:	89 81       	ldd	r24, Y+1	; 0x01
    66e4:	8e 83       	std	Y+6, r24	; 0x06
    66e6:	06 c0       	rjmp	.+12     	; 0x66f4 <Check_User_Data+0x7e>
		Loc_u8QueueState = xQueueReceive(Keypad_To_CheckData_Queue1,&Loc_u8ID,5);
		if(Loc_u8QueueState == pdPASS)
		{
			//ID Received Successfully
			/*1-Checking ID is Existing*/
			for(Loc_u8UserOrder =0 ; Loc_u8UserOrder < (sizeof(USER_ARR) / sizeof(USER_ARR[0])) ; Loc_u8UserOrder ++)
    66e8:	89 81       	ldd	r24, Y+1	; 0x01
    66ea:	8f 5f       	subi	r24, 0xFF	; 255
    66ec:	89 83       	std	Y+1, r24	; 0x01
    66ee:	89 81       	ldd	r24, Y+1	; 0x01
    66f0:	85 30       	cpi	r24, 0x05	; 5
    66f2:	18 f3       	brcs	.-58     	; 0x66ba <Check_User_Data+0x44>
					Loc_u8Location_of_User = Loc_u8UserOrder;
					break;
				}
			}

			if(Loc_u8UserAvailableFlag == 2){
    66f4:	80 91 e8 01 	lds	r24, 0x01E8
    66f8:	82 30       	cpi	r24, 0x02	; 2
    66fa:	21 f4       	brne	.+8      	; 0x6704 <Check_User_Data+0x8e>
				LCD_FLAG = LCD_WRONG_ID;
    66fc:	83 e0       	ldi	r24, 0x03	; 3
    66fe:	80 93 ca 07 	sts	0x07CA, r24
    6702:	03 c0       	rjmp	.+6      	; 0x670a <Check_User_Data+0x94>
			}
			else {
				KEYPAD_FLAG = KEYPAD_PASS;
    6704:	81 e0       	ldi	r24, 0x01	; 1
    6706:	80 93 e7 07 	sts	0x07E7, r24
			}
		}

		//Receive Password From the Keypad
		Loc_u8QueueState = xQueueReceive(Keypad_To_CheckData_Queue2,&Loc_u16Password,0);
    670a:	80 91 ee 07 	lds	r24, 0x07EE
    670e:	90 91 ef 07 	lds	r25, 0x07EF
    6712:	9e 01       	movw	r18, r28
    6714:	2c 5f       	subi	r18, 0xFC	; 252
    6716:	3f 4f       	sbci	r19, 0xFF	; 255
    6718:	b9 01       	movw	r22, r18
    671a:	40 e0       	ldi	r20, 0x00	; 0
    671c:	50 e0       	ldi	r21, 0x00	; 0
    671e:	20 e0       	ldi	r18, 0x00	; 0
    6720:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <xQueueGenericReceive>
    6724:	8a 83       	std	Y+2, r24	; 0x02
		if(Loc_u8QueueState == pdPASS)
    6726:	8a 81       	ldd	r24, Y+2	; 0x02
    6728:	81 30       	cpi	r24, 0x01	; 1
    672a:	61 f5       	brne	.+88     	; 0x6784 <Check_User_Data+0x10e>
		{
			//HCLCD_VidWriteNumber_4Bits(Loc_u16Password);
			//ID Received Successfully
			if(Loc_u8UserAvailableFlag == 1)
    672c:	80 91 e8 01 	lds	r24, 0x01E8
    6730:	81 30       	cpi	r24, 0x01	; 1
    6732:	41 f5       	brne	.+80     	; 0x6784 <Check_User_Data+0x10e>
			{
				//User is Found in Database
				//Check For Password
				if(Loc_u16Password == USER_ARR[Loc_u8Location_of_User].pass)
    6734:	8e 81       	ldd	r24, Y+6	; 0x06
    6736:	28 2f       	mov	r18, r24
    6738:	30 e0       	ldi	r19, 0x00	; 0
    673a:	c9 01       	movw	r24, r18
    673c:	88 0f       	add	r24, r24
    673e:	99 1f       	adc	r25, r25
    6740:	88 0f       	add	r24, r24
    6742:	99 1f       	adc	r25, r25
    6744:	82 0f       	add	r24, r18
    6746:	93 1f       	adc	r25, r19
    6748:	fc 01       	movw	r30, r24
    674a:	ea 53       	subi	r30, 0x3A	; 58
    674c:	fe 4f       	sbci	r31, 0xFE	; 254
    674e:	20 81       	ld	r18, Z
    6750:	31 81       	ldd	r19, Z+1	; 0x01
    6752:	8c 81       	ldd	r24, Y+4	; 0x04
    6754:	9d 81       	ldd	r25, Y+5	; 0x05
    6756:	28 17       	cp	r18, r24
    6758:	39 07       	cpc	r19, r25
    675a:	89 f4       	brne	.+34     	; 0x677e <Check_User_Data+0x108>
				{
					//Password matches
					//Send The Successful user ID to Next Stages
					xQueueSend(CheckData_To_Balance_Queue,&Loc_u8Location_of_User,0);
    675c:	80 91 e8 07 	lds	r24, 0x07E8
    6760:	90 91 e9 07 	lds	r25, 0x07E9
    6764:	9e 01       	movw	r18, r28
    6766:	2a 5f       	subi	r18, 0xFA	; 250
    6768:	3f 4f       	sbci	r19, 0xFF	; 255
    676a:	b9 01       	movw	r22, r18
    676c:	40 e0       	ldi	r20, 0x00	; 0
    676e:	50 e0       	ldi	r21, 0x00	; 0
    6770:	20 e0       	ldi	r18, 0x00	; 0
    6772:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xQueueGenericSend>
					KEYPAD_FLAG = KEYPAD_DRAW_VALUE;
    6776:	85 e0       	ldi	r24, 0x05	; 5
    6778:	80 93 e7 07 	sts	0x07E7, r24
    677c:	03 c0       	rjmp	.+6      	; 0x6784 <Check_User_Data+0x10e>
					//GO On To Next Stage
				}
				else
				{
					//Password is wrong
					LCD_FLAG = LCD_WRONG_PASS;
    677e:	84 e0       	ldi	r24, 0x04	; 4
    6780:	80 93 ca 07 	sts	0x07CA, r24
				}
			}

		}
		vTaskDelay(200);
    6784:	88 ec       	ldi	r24, 0xC8	; 200
    6786:	90 e0       	ldi	r25, 0x00	; 0
    6788:	0e 94 33 2b 	call	0x5666	; 0x5666 <vTaskDelay>
    678c:	83 cf       	rjmp	.-250    	; 0x6694 <Check_User_Data+0x1e>

0000678e <Check_Balance>:
	}
}

void Check_Balance(void *pv)
{
    678e:	df 93       	push	r29
    6790:	cf 93       	push	r28
    6792:	00 d0       	rcall	.+0      	; 0x6794 <Check_Balance+0x6>
    6794:	0f 92       	push	r0
    6796:	cd b7       	in	r28, 0x3d	; 61
    6798:	de b7       	in	r29, 0x3e	; 62
    679a:	9b 83       	std	Y+3, r25	; 0x03
    679c:	8a 83       	std	Y+2, r24	; 0x02
	static u32 Loc_u32Draw = 0;
	static u32 Loc_u32Balance;
	static u8 Loc_u8Location_Of_User;

	while(1){
		Loc_u8QueuState = xQueueReceive(Keypad_To_CheckBalance_Queue,&Loc_u32Draw,5);
    679e:	80 91 f2 07 	lds	r24, 0x07F2
    67a2:	90 91 f3 07 	lds	r25, 0x07F3
    67a6:	2b ed       	ldi	r18, 0xDB	; 219
    67a8:	37 e0       	ldi	r19, 0x07	; 7
    67aa:	b9 01       	movw	r22, r18
    67ac:	45 e0       	ldi	r20, 0x05	; 5
    67ae:	50 e0       	ldi	r21, 0x00	; 0
    67b0:	20 e0       	ldi	r18, 0x00	; 0
    67b2:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <xQueueGenericReceive>
    67b6:	89 83       	std	Y+1, r24	; 0x01
		if(Loc_u8QueuState == pdPASS){
    67b8:	89 81       	ldd	r24, Y+1	; 0x01
    67ba:	81 30       	cpi	r24, 0x01	; 1
    67bc:	09 f0       	breq	.+2      	; 0x67c0 <Check_Balance+0x32>
    67be:	76 c0       	rjmp	.+236    	; 0x68ac <Check_Balance+0x11e>

			Loc_u8QueuState = xQueueReceive(CheckData_To_Balance_Queue,&Loc_u8Location_Of_User,5);
    67c0:	80 91 e8 07 	lds	r24, 0x07E8
    67c4:	90 91 e9 07 	lds	r25, 0x07E9
    67c8:	26 ed       	ldi	r18, 0xD6	; 214
    67ca:	37 e0       	ldi	r19, 0x07	; 7
    67cc:	b9 01       	movw	r22, r18
    67ce:	45 e0       	ldi	r20, 0x05	; 5
    67d0:	50 e0       	ldi	r21, 0x00	; 0
    67d2:	20 e0       	ldi	r18, 0x00	; 0
    67d4:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <xQueueGenericReceive>
    67d8:	89 83       	std	Y+1, r24	; 0x01
			if(Loc_u8QueuState == pdPASS){
    67da:	89 81       	ldd	r24, Y+1	; 0x01
    67dc:	81 30       	cpi	r24, 0x01	; 1
    67de:	09 f0       	breq	.+2      	; 0x67e2 <Check_Balance+0x54>
    67e0:	65 c0       	rjmp	.+202    	; 0x68ac <Check_Balance+0x11e>
				/* Get User Balance */
				Loc_u32Balance = USER_ARR[Loc_u8Location_Of_User].Balance;
    67e2:	80 91 d6 07 	lds	r24, 0x07D6
    67e6:	28 2f       	mov	r18, r24
    67e8:	30 e0       	ldi	r19, 0x00	; 0
    67ea:	c9 01       	movw	r24, r18
    67ec:	88 0f       	add	r24, r24
    67ee:	99 1f       	adc	r25, r25
    67f0:	88 0f       	add	r24, r24
    67f2:	99 1f       	adc	r25, r25
    67f4:	82 0f       	add	r24, r18
    67f6:	93 1f       	adc	r25, r19
    67f8:	fc 01       	movw	r30, r24
    67fa:	e8 53       	subi	r30, 0x38	; 56
    67fc:	fe 4f       	sbci	r31, 0xFE	; 254
    67fe:	80 81       	ld	r24, Z
    6800:	91 81       	ldd	r25, Z+1	; 0x01
    6802:	cc 01       	movw	r24, r24
    6804:	a0 e0       	ldi	r26, 0x00	; 0
    6806:	b0 e0       	ldi	r27, 0x00	; 0
    6808:	80 93 d7 07 	sts	0x07D7, r24
    680c:	90 93 d8 07 	sts	0x07D8, r25
    6810:	a0 93 d9 07 	sts	0x07D9, r26
    6814:	b0 93 da 07 	sts	0x07DA, r27
				/* Checking Draw Value */
				if(Loc_u32Draw > BANK_DATA.Total_Balance){
    6818:	20 91 bd 01 	lds	r18, 0x01BD
    681c:	30 91 be 01 	lds	r19, 0x01BE
    6820:	40 91 bf 01 	lds	r20, 0x01BF
    6824:	50 91 c0 01 	lds	r21, 0x01C0
    6828:	80 91 db 07 	lds	r24, 0x07DB
    682c:	90 91 dc 07 	lds	r25, 0x07DC
    6830:	a0 91 dd 07 	lds	r26, 0x07DD
    6834:	b0 91 de 07 	lds	r27, 0x07DE
    6838:	28 17       	cp	r18, r24
    683a:	39 07       	cpc	r19, r25
    683c:	4a 07       	cpc	r20, r26
    683e:	5b 07       	cpc	r21, r27
    6840:	20 f4       	brcc	.+8      	; 0x684a <Check_Balance+0xbc>
					LCD_FLAG = LCD_BANK_BALANCE_NOT_ENOUGH;
    6842:	88 e0       	ldi	r24, 0x08	; 8
    6844:	80 93 ca 07 	sts	0x07CA, r24
    6848:	31 c0       	rjmp	.+98     	; 0x68ac <Check_Balance+0x11e>
				}

				else if(Loc_u32Draw > Loc_u32Balance){
    684a:	20 91 db 07 	lds	r18, 0x07DB
    684e:	30 91 dc 07 	lds	r19, 0x07DC
    6852:	40 91 dd 07 	lds	r20, 0x07DD
    6856:	50 91 de 07 	lds	r21, 0x07DE
    685a:	80 91 d7 07 	lds	r24, 0x07D7
    685e:	90 91 d8 07 	lds	r25, 0x07D8
    6862:	a0 91 d9 07 	lds	r26, 0x07D9
    6866:	b0 91 da 07 	lds	r27, 0x07DA
    686a:	82 17       	cp	r24, r18
    686c:	93 07       	cpc	r25, r19
    686e:	a4 07       	cpc	r26, r20
    6870:	b5 07       	cpc	r27, r21
    6872:	20 f4       	brcc	.+8      	; 0x687c <Check_Balance+0xee>
					LCD_FLAG = LCD_USER_BALANCE_NOT_ENOUGH;
    6874:	89 e0       	ldi	r24, 0x09	; 9
    6876:	80 93 ca 07 	sts	0x07CA, r24
    687a:	18 c0       	rjmp	.+48     	; 0x68ac <Check_Balance+0x11e>
				}

				else
				{
					xQueueSend(CheckBalance_To_Calculation_Queue,&Loc_u32Draw,0);
    687c:	80 91 f0 07 	lds	r24, 0x07F0
    6880:	90 91 f1 07 	lds	r25, 0x07F1
    6884:	2b ed       	ldi	r18, 0xDB	; 219
    6886:	37 e0       	ldi	r19, 0x07	; 7
    6888:	b9 01       	movw	r22, r18
    688a:	40 e0       	ldi	r20, 0x00	; 0
    688c:	50 e0       	ldi	r21, 0x00	; 0
    688e:	20 e0       	ldi	r18, 0x00	; 0
    6890:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xQueueGenericSend>
					xQueueSend(CheckData_To_Balance_Queue,&Loc_u8Location_Of_User,5);
    6894:	80 91 e8 07 	lds	r24, 0x07E8
    6898:	90 91 e9 07 	lds	r25, 0x07E9
    689c:	26 ed       	ldi	r18, 0xD6	; 214
    689e:	37 e0       	ldi	r19, 0x07	; 7
    68a0:	b9 01       	movw	r22, r18
    68a2:	45 e0       	ldi	r20, 0x05	; 5
    68a4:	50 e0       	ldi	r21, 0x00	; 0
    68a6:	20 e0       	ldi	r18, 0x00	; 0
    68a8:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xQueueGenericSend>
				}

			}
		}
		vTaskDelay(300);
    68ac:	8c e2       	ldi	r24, 0x2C	; 44
    68ae:	91 e0       	ldi	r25, 0x01	; 1
    68b0:	0e 94 33 2b 	call	0x5666	; 0x5666 <vTaskDelay>
    68b4:	74 cf       	rjmp	.-280    	; 0x679e <Check_Balance+0x10>

000068b6 <Calc>:
	}
}

void Calc(void *pv)
{
    68b6:	ef 92       	push	r14
    68b8:	ff 92       	push	r15
    68ba:	0f 93       	push	r16
    68bc:	1f 93       	push	r17
    68be:	df 93       	push	r29
    68c0:	cf 93       	push	r28
    68c2:	cd b7       	in	r28, 0x3d	; 61
    68c4:	de b7       	in	r29, 0x3e	; 62
    68c6:	27 97       	sbiw	r28, 0x07	; 7
    68c8:	0f b6       	in	r0, 0x3f	; 63
    68ca:	f8 94       	cli
    68cc:	de bf       	out	0x3e, r29	; 62
    68ce:	0f be       	out	0x3f, r0	; 63
    68d0:	cd bf       	out	0x3d, r28	; 61
    68d2:	9f 83       	std	Y+7, r25	; 0x07
    68d4:	8e 83       	std	Y+6, r24	; 0x06
	u8 Loc_u8QueueState  = 0;
    68d6:	19 82       	std	Y+1, r1	; 0x01
	u32 Loc_u32DrawValue = 0;
    68d8:	1a 82       	std	Y+2, r1	; 0x02
    68da:	1b 82       	std	Y+3, r1	; 0x03
    68dc:	1c 82       	std	Y+4, r1	; 0x04
    68de:	1d 82       	std	Y+5, r1	; 0x05
	static u8 Loc_u8UserLocation = 0;

	while(1){

		Loc_u8QueueState= xQueueReceive(CheckBalance_To_Calculation_Queue,&Loc_u32DrawValue,5);
    68e0:	80 91 f0 07 	lds	r24, 0x07F0
    68e4:	90 91 f1 07 	lds	r25, 0x07F1
    68e8:	9e 01       	movw	r18, r28
    68ea:	2e 5f       	subi	r18, 0xFE	; 254
    68ec:	3f 4f       	sbci	r19, 0xFF	; 255
    68ee:	b9 01       	movw	r22, r18
    68f0:	45 e0       	ldi	r20, 0x05	; 5
    68f2:	50 e0       	ldi	r21, 0x00	; 0
    68f4:	20 e0       	ldi	r18, 0x00	; 0
    68f6:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <xQueueGenericReceive>
    68fa:	89 83       	std	Y+1, r24	; 0x01
		if(Loc_u8QueueState == pdPASS){
    68fc:	89 81       	ldd	r24, Y+1	; 0x01
    68fe:	81 30       	cpi	r24, 0x01	; 1
    6900:	09 f0       	breq	.+2      	; 0x6904 <Calc+0x4e>
    6902:	c8 c0       	rjmp	.+400    	; 0x6a94 <Calc+0x1de>
			Loc_u8QueueState = xQueueReceive(CheckData_To_Balance_Queue,&Loc_u8UserLocation,5);
    6904:	80 91 e8 07 	lds	r24, 0x07E8
    6908:	90 91 e9 07 	lds	r25, 0x07E9
    690c:	2f ed       	ldi	r18, 0xDF	; 223
    690e:	37 e0       	ldi	r19, 0x07	; 7
    6910:	b9 01       	movw	r22, r18
    6912:	45 e0       	ldi	r20, 0x05	; 5
    6914:	50 e0       	ldi	r21, 0x00	; 0
    6916:	20 e0       	ldi	r18, 0x00	; 0
    6918:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <xQueueGenericReceive>
    691c:	89 83       	std	Y+1, r24	; 0x01
			if(Loc_u8QueueState == pdPASS){
    691e:	89 81       	ldd	r24, Y+1	; 0x01
    6920:	81 30       	cpi	r24, 0x01	; 1
    6922:	09 f0       	breq	.+2      	; 0x6926 <Calc+0x70>
    6924:	b7 c0       	rjmp	.+366    	; 0x6a94 <Calc+0x1de>

				BANK_DATA.Total_Balance -= Loc_u32DrawValue;
    6926:	20 91 bd 01 	lds	r18, 0x01BD
    692a:	30 91 be 01 	lds	r19, 0x01BE
    692e:	40 91 bf 01 	lds	r20, 0x01BF
    6932:	50 91 c0 01 	lds	r21, 0x01C0
    6936:	8a 81       	ldd	r24, Y+2	; 0x02
    6938:	9b 81       	ldd	r25, Y+3	; 0x03
    693a:	ac 81       	ldd	r26, Y+4	; 0x04
    693c:	bd 81       	ldd	r27, Y+5	; 0x05
    693e:	79 01       	movw	r14, r18
    6940:	8a 01       	movw	r16, r20
    6942:	e8 1a       	sub	r14, r24
    6944:	f9 0a       	sbc	r15, r25
    6946:	0a 0b       	sbc	r16, r26
    6948:	1b 0b       	sbc	r17, r27
    694a:	d8 01       	movw	r26, r16
    694c:	c7 01       	movw	r24, r14
    694e:	80 93 bd 01 	sts	0x01BD, r24
    6952:	90 93 be 01 	sts	0x01BE, r25
    6956:	a0 93 bf 01 	sts	0x01BF, r26
    695a:	b0 93 c0 01 	sts	0x01C0, r27
				USER_ARR[Loc_u8UserLocation].Balance -= Loc_u32DrawValue;
    695e:	80 91 df 07 	lds	r24, 0x07DF
    6962:	48 2f       	mov	r20, r24
    6964:	50 e0       	ldi	r21, 0x00	; 0
    6966:	80 91 df 07 	lds	r24, 0x07DF
    696a:	28 2f       	mov	r18, r24
    696c:	30 e0       	ldi	r19, 0x00	; 0
    696e:	c9 01       	movw	r24, r18
    6970:	88 0f       	add	r24, r24
    6972:	99 1f       	adc	r25, r25
    6974:	88 0f       	add	r24, r24
    6976:	99 1f       	adc	r25, r25
    6978:	82 0f       	add	r24, r18
    697a:	93 1f       	adc	r25, r19
    697c:	fc 01       	movw	r30, r24
    697e:	e8 53       	subi	r30, 0x38	; 56
    6980:	fe 4f       	sbci	r31, 0xFE	; 254
    6982:	20 81       	ld	r18, Z
    6984:	31 81       	ldd	r19, Z+1	; 0x01
    6986:	8a 81       	ldd	r24, Y+2	; 0x02
    6988:	9b 81       	ldd	r25, Y+3	; 0x03
    698a:	ac 81       	ldd	r26, Y+4	; 0x04
    698c:	bd 81       	ldd	r27, Y+5	; 0x05
    698e:	28 1b       	sub	r18, r24
    6990:	39 0b       	sbc	r19, r25
    6992:	ca 01       	movw	r24, r20
    6994:	88 0f       	add	r24, r24
    6996:	99 1f       	adc	r25, r25
    6998:	88 0f       	add	r24, r24
    699a:	99 1f       	adc	r25, r25
    699c:	84 0f       	add	r24, r20
    699e:	95 1f       	adc	r25, r21
    69a0:	fc 01       	movw	r30, r24
    69a2:	e8 53       	subi	r30, 0x38	; 56
    69a4:	fe 4f       	sbci	r31, 0xFE	; 254
    69a6:	31 83       	std	Z+1, r19	; 0x01
    69a8:	20 83       	st	Z, r18
    69aa:	16 c0       	rjmp	.+44     	; 0x69d8 <Calc+0x122>
				while((BANK_DATA._200_Papers > 0) && (Loc_u32DrawValue >= 200)){
					_200_papers ++;
    69ac:	80 91 cb 07 	lds	r24, 0x07CB
    69b0:	8f 5f       	subi	r24, 0xFF	; 255
    69b2:	80 93 cb 07 	sts	0x07CB, r24
					Loc_u32DrawValue -= 200;
    69b6:	8a 81       	ldd	r24, Y+2	; 0x02
    69b8:	9b 81       	ldd	r25, Y+3	; 0x03
    69ba:	ac 81       	ldd	r26, Y+4	; 0x04
    69bc:	bd 81       	ldd	r27, Y+5	; 0x05
    69be:	88 5c       	subi	r24, 0xC8	; 200
    69c0:	90 40       	sbci	r25, 0x00	; 0
    69c2:	a0 40       	sbci	r26, 0x00	; 0
    69c4:	b0 40       	sbci	r27, 0x00	; 0
    69c6:	8a 83       	std	Y+2, r24	; 0x02
    69c8:	9b 83       	std	Y+3, r25	; 0x03
    69ca:	ac 83       	std	Y+4, r26	; 0x04
    69cc:	bd 83       	std	Y+5, r27	; 0x05
					BANK_DATA._200_Papers --;
    69ce:	80 91 c1 01 	lds	r24, 0x01C1
    69d2:	81 50       	subi	r24, 0x01	; 1
    69d4:	80 93 c1 01 	sts	0x01C1, r24
			Loc_u8QueueState = xQueueReceive(CheckData_To_Balance_Queue,&Loc_u8UserLocation,5);
			if(Loc_u8QueueState == pdPASS){

				BANK_DATA.Total_Balance -= Loc_u32DrawValue;
				USER_ARR[Loc_u8UserLocation].Balance -= Loc_u32DrawValue;
				while((BANK_DATA._200_Papers > 0) && (Loc_u32DrawValue >= 200)){
    69d8:	80 91 c1 01 	lds	r24, 0x01C1
    69dc:	88 23       	and	r24, r24
    69de:	01 f1       	breq	.+64     	; 0x6a20 <Calc+0x16a>
    69e0:	8a 81       	ldd	r24, Y+2	; 0x02
    69e2:	9b 81       	ldd	r25, Y+3	; 0x03
    69e4:	ac 81       	ldd	r26, Y+4	; 0x04
    69e6:	bd 81       	ldd	r27, Y+5	; 0x05
    69e8:	88 3c       	cpi	r24, 0xC8	; 200
    69ea:	91 05       	cpc	r25, r1
    69ec:	a1 05       	cpc	r26, r1
    69ee:	b1 05       	cpc	r27, r1
    69f0:	e8 f6       	brcc	.-70     	; 0x69ac <Calc+0xf6>
    69f2:	16 c0       	rjmp	.+44     	; 0x6a20 <Calc+0x16a>
					_200_papers ++;
					Loc_u32DrawValue -= 200;
					BANK_DATA._200_Papers --;
				}
				while((BANK_DATA._100_Papers > 0) && (Loc_u32DrawValue >= 100)){
					_100_papers ++;
    69f4:	80 91 cc 07 	lds	r24, 0x07CC
    69f8:	8f 5f       	subi	r24, 0xFF	; 255
    69fa:	80 93 cc 07 	sts	0x07CC, r24
					Loc_u32DrawValue -= 100;
    69fe:	8a 81       	ldd	r24, Y+2	; 0x02
    6a00:	9b 81       	ldd	r25, Y+3	; 0x03
    6a02:	ac 81       	ldd	r26, Y+4	; 0x04
    6a04:	bd 81       	ldd	r27, Y+5	; 0x05
    6a06:	84 56       	subi	r24, 0x64	; 100
    6a08:	90 40       	sbci	r25, 0x00	; 0
    6a0a:	a0 40       	sbci	r26, 0x00	; 0
    6a0c:	b0 40       	sbci	r27, 0x00	; 0
    6a0e:	8a 83       	std	Y+2, r24	; 0x02
    6a10:	9b 83       	std	Y+3, r25	; 0x03
    6a12:	ac 83       	std	Y+4, r26	; 0x04
    6a14:	bd 83       	std	Y+5, r27	; 0x05
					BANK_DATA._100_Papers --;
    6a16:	80 91 c2 01 	lds	r24, 0x01C2
    6a1a:	81 50       	subi	r24, 0x01	; 1
    6a1c:	80 93 c2 01 	sts	0x01C2, r24
				while((BANK_DATA._200_Papers > 0) && (Loc_u32DrawValue >= 200)){
					_200_papers ++;
					Loc_u32DrawValue -= 200;
					BANK_DATA._200_Papers --;
				}
				while((BANK_DATA._100_Papers > 0) && (Loc_u32DrawValue >= 100)){
    6a20:	80 91 c2 01 	lds	r24, 0x01C2
    6a24:	88 23       	and	r24, r24
    6a26:	39 f1       	breq	.+78     	; 0x6a76 <Calc+0x1c0>
    6a28:	8a 81       	ldd	r24, Y+2	; 0x02
    6a2a:	9b 81       	ldd	r25, Y+3	; 0x03
    6a2c:	ac 81       	ldd	r26, Y+4	; 0x04
    6a2e:	bd 81       	ldd	r27, Y+5	; 0x05
    6a30:	84 36       	cpi	r24, 0x64	; 100
    6a32:	91 05       	cpc	r25, r1
    6a34:	a1 05       	cpc	r26, r1
    6a36:	b1 05       	cpc	r27, r1
    6a38:	e8 f6       	brcc	.-70     	; 0x69f4 <Calc+0x13e>
    6a3a:	1d c0       	rjmp	.+58     	; 0x6a76 <Calc+0x1c0>
					_100_papers ++;
					Loc_u32DrawValue -= 100;
					BANK_DATA._100_Papers --;
				}
				while((BANK_DATA._50_Papers > 0) && (Loc_u32DrawValue >= 50)){
					_50_papers ++;
    6a3c:	80 91 cd 07 	lds	r24, 0x07CD
    6a40:	90 91 ce 07 	lds	r25, 0x07CE
    6a44:	01 96       	adiw	r24, 0x01	; 1
    6a46:	90 93 ce 07 	sts	0x07CE, r25
    6a4a:	80 93 cd 07 	sts	0x07CD, r24
					Loc_u32DrawValue -= 50;
    6a4e:	8a 81       	ldd	r24, Y+2	; 0x02
    6a50:	9b 81       	ldd	r25, Y+3	; 0x03
    6a52:	ac 81       	ldd	r26, Y+4	; 0x04
    6a54:	bd 81       	ldd	r27, Y+5	; 0x05
    6a56:	c2 97       	sbiw	r24, 0x32	; 50
    6a58:	a1 09       	sbc	r26, r1
    6a5a:	b1 09       	sbc	r27, r1
    6a5c:	8a 83       	std	Y+2, r24	; 0x02
    6a5e:	9b 83       	std	Y+3, r25	; 0x03
    6a60:	ac 83       	std	Y+4, r26	; 0x04
    6a62:	bd 83       	std	Y+5, r27	; 0x05
					BANK_DATA._50_Papers --;
    6a64:	80 91 c3 01 	lds	r24, 0x01C3
    6a68:	90 91 c4 01 	lds	r25, 0x01C4
    6a6c:	01 97       	sbiw	r24, 0x01	; 1
    6a6e:	90 93 c4 01 	sts	0x01C4, r25
    6a72:	80 93 c3 01 	sts	0x01C3, r24
				while((BANK_DATA._100_Papers > 0) && (Loc_u32DrawValue >= 100)){
					_100_papers ++;
					Loc_u32DrawValue -= 100;
					BANK_DATA._100_Papers --;
				}
				while((BANK_DATA._50_Papers > 0) && (Loc_u32DrawValue >= 50)){
    6a76:	80 91 c3 01 	lds	r24, 0x01C3
    6a7a:	90 91 c4 01 	lds	r25, 0x01C4
    6a7e:	00 97       	sbiw	r24, 0x00	; 0
    6a80:	49 f0       	breq	.+18     	; 0x6a94 <Calc+0x1de>
    6a82:	8a 81       	ldd	r24, Y+2	; 0x02
    6a84:	9b 81       	ldd	r25, Y+3	; 0x03
    6a86:	ac 81       	ldd	r26, Y+4	; 0x04
    6a88:	bd 81       	ldd	r27, Y+5	; 0x05
    6a8a:	82 33       	cpi	r24, 0x32	; 50
    6a8c:	91 05       	cpc	r25, r1
    6a8e:	a1 05       	cpc	r26, r1
    6a90:	b1 05       	cpc	r27, r1
    6a92:	a0 f6       	brcc	.-88     	; 0x6a3c <Calc+0x186>
					Loc_u32DrawValue -= 50;
					BANK_DATA._50_Papers --;
				}
			}
		}
		vTaskDelay(400);
    6a94:	80 e9       	ldi	r24, 0x90	; 144
    6a96:	91 e0       	ldi	r25, 0x01	; 1
    6a98:	0e 94 33 2b 	call	0x5666	; 0x5666 <vTaskDelay>
    6a9c:	21 cf       	rjmp	.-446    	; 0x68e0 <Calc+0x2a>

00006a9e <APP_Output_Money>:
	}
}

void APP_Output_Money(void *pv)
{
    6a9e:	df 93       	push	r29
    6aa0:	cf 93       	push	r28
    6aa2:	00 d0       	rcall	.+0      	; 0x6aa4 <APP_Output_Money+0x6>
    6aa4:	cd b7       	in	r28, 0x3d	; 61
    6aa6:	de b7       	in	r29, 0x3e	; 62
    6aa8:	9a 83       	std	Y+2, r25	; 0x02
    6aaa:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		//200 Papers Passed
		MDIO_Error_State_SetPinValue(PIN5,MDIO_PORTC,PIN_HIGH);
    6aac:	85 e0       	ldi	r24, 0x05	; 5
    6aae:	62 e0       	ldi	r22, 0x02	; 2
    6ab0:	41 e0       	ldi	r20, 0x01	; 1
    6ab2:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(PIN6,MDIO_PORTC,PIN_LOW);
    6ab6:	86 e0       	ldi	r24, 0x06	; 6
    6ab8:	62 e0       	ldi	r22, 0x02	; 2
    6aba:	40 e0       	ldi	r20, 0x00	; 0
    6abc:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(PIN7,MDIO_PORTC,PIN_LOW);
    6ac0:	87 e0       	ldi	r24, 0x07	; 7
    6ac2:	62 e0       	ldi	r22, 0x02	; 2
    6ac4:	40 e0       	ldi	r20, 0x00	; 0
    6ac6:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>

		HSTEPPER_VidRotateCycles(&Stepper,_200_papers,HSTEPPER_CLOCKWISE,1);
    6aca:	20 91 cb 07 	lds	r18, 0x07CB
    6ace:	8e ed       	ldi	r24, 0xDE	; 222
    6ad0:	91 e0       	ldi	r25, 0x01	; 1
    6ad2:	62 2f       	mov	r22, r18
    6ad4:	42 e0       	ldi	r20, 0x02	; 2
    6ad6:	21 e0       	ldi	r18, 0x01	; 1
    6ad8:	0e 94 17 13 	call	0x262e	; 0x262e <HSTEPPER_VidRotateCycles>

		//100 Papers Passed
		MDIO_Error_State_SetPinValue(PIN5,MDIO_PORTC,PIN_LOW);
    6adc:	85 e0       	ldi	r24, 0x05	; 5
    6ade:	62 e0       	ldi	r22, 0x02	; 2
    6ae0:	40 e0       	ldi	r20, 0x00	; 0
    6ae2:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(PIN6,MDIO_PORTC,PIN_HIGH);
    6ae6:	86 e0       	ldi	r24, 0x06	; 6
    6ae8:	62 e0       	ldi	r22, 0x02	; 2
    6aea:	41 e0       	ldi	r20, 0x01	; 1
    6aec:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(PIN7,MDIO_PORTC,PIN_LOW);
    6af0:	87 e0       	ldi	r24, 0x07	; 7
    6af2:	62 e0       	ldi	r22, 0x02	; 2
    6af4:	40 e0       	ldi	r20, 0x00	; 0
    6af6:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>

		HSTEPPER_VidRotateCycles(&Stepper,_100_papers,HSTEPPER_CLOCKWISE,1);
    6afa:	20 91 cc 07 	lds	r18, 0x07CC
    6afe:	8e ed       	ldi	r24, 0xDE	; 222
    6b00:	91 e0       	ldi	r25, 0x01	; 1
    6b02:	62 2f       	mov	r22, r18
    6b04:	42 e0       	ldi	r20, 0x02	; 2
    6b06:	21 e0       	ldi	r18, 0x01	; 1
    6b08:	0e 94 17 13 	call	0x262e	; 0x262e <HSTEPPER_VidRotateCycles>

		MDIO_Error_State_SetPinValue(PIN5,MDIO_PORTC,PIN_LOW);
    6b0c:	85 e0       	ldi	r24, 0x05	; 5
    6b0e:	62 e0       	ldi	r22, 0x02	; 2
    6b10:	40 e0       	ldi	r20, 0x00	; 0
    6b12:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(PIN6,MDIO_PORTC,PIN_LOW);
    6b16:	86 e0       	ldi	r24, 0x06	; 6
    6b18:	62 e0       	ldi	r22, 0x02	; 2
    6b1a:	40 e0       	ldi	r20, 0x00	; 0
    6b1c:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>
		MDIO_Error_State_SetPinValue(PIN7,MDIO_PORTC,PIN_HIGH);
    6b20:	87 e0       	ldi	r24, 0x07	; 7
    6b22:	62 e0       	ldi	r22, 0x02	; 2
    6b24:	41 e0       	ldi	r20, 0x01	; 1
    6b26:	0e 94 8a 09 	call	0x1314	; 0x1314 <MDIO_Error_State_SetPinValue>

		HSTEPPER_VidRotateCycles(&Stepper,_50_papers,HSTEPPER_CLOCKWISE,1);
    6b2a:	80 91 cd 07 	lds	r24, 0x07CD
    6b2e:	90 91 ce 07 	lds	r25, 0x07CE
    6b32:	28 2f       	mov	r18, r24
    6b34:	8e ed       	ldi	r24, 0xDE	; 222
    6b36:	91 e0       	ldi	r25, 0x01	; 1
    6b38:	62 2f       	mov	r22, r18
    6b3a:	42 e0       	ldi	r20, 0x02	; 2
    6b3c:	21 e0       	ldi	r18, 0x01	; 1
    6b3e:	0e 94 17 13 	call	0x262e	; 0x262e <HSTEPPER_VidRotateCycles>

		_100_papers  = 0;
    6b42:	10 92 cc 07 	sts	0x07CC, r1
		_200_papers = 0;
    6b46:	10 92 cb 07 	sts	0x07CB, r1
		_50_papers = 0;
    6b4a:	10 92 ce 07 	sts	0x07CE, r1
    6b4e:	10 92 cd 07 	sts	0x07CD, r1

		vTaskDelay(1000);
    6b52:	88 ee       	ldi	r24, 0xE8	; 232
    6b54:	93 e0       	ldi	r25, 0x03	; 3
    6b56:	0e 94 33 2b 	call	0x5666	; 0x5666 <vTaskDelay>
    6b5a:	a8 cf       	rjmp	.-176    	; 0x6aac <APP_Output_Money+0xe>

00006b5c <LCD_Display>:
	}
}

void LCD_Display(void*pv)
{
    6b5c:	df 93       	push	r29
    6b5e:	cf 93       	push	r28
    6b60:	00 d0       	rcall	.+0      	; 0x6b62 <LCD_Display+0x6>
    6b62:	00 d0       	rcall	.+0      	; 0x6b64 <LCD_Display+0x8>
    6b64:	00 d0       	rcall	.+0      	; 0x6b66 <LCD_Display+0xa>
    6b66:	cd b7       	in	r28, 0x3d	; 61
    6b68:	de b7       	in	r29, 0x3e	; 62
    6b6a:	9c 83       	std	Y+4, r25	; 0x04
    6b6c:	8b 83       	std	Y+3, r24	; 0x03
	static u8 pos2=6;
	static u8 pos3=10;
	static u8 prev_state = LCD_INIT;
	while(1)
	{
		if (LCD_FLAG !=prev_state)
    6b6e:	90 91 ca 07 	lds	r25, 0x07CA
    6b72:	80 91 e0 07 	lds	r24, 0x07E0
    6b76:	98 17       	cp	r25, r24
    6b78:	31 f0       	breq	.+12     	; 0x6b86 <LCD_Display+0x2a>
		{
			HCLCD_VidWriteCommand_4Bits(0x01>>4);
    6b7a:	80 e0       	ldi	r24, 0x00	; 0
    6b7c:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
			HCLCD_VidWriteCommand_4Bits(0x01);
    6b80:	81 e0       	ldi	r24, 0x01	; 1
    6b82:	0e 94 c6 18 	call	0x318c	; 0x318c <HCLCD_VidWriteCommand_4Bits>
		}
		switch(LCD_FLAG)
    6b86:	80 91 ca 07 	lds	r24, 0x07CA
    6b8a:	28 2f       	mov	r18, r24
    6b8c:	30 e0       	ldi	r19, 0x00	; 0
    6b8e:	3e 83       	std	Y+6, r19	; 0x06
    6b90:	2d 83       	std	Y+5, r18	; 0x05
    6b92:	8d 81       	ldd	r24, Y+5	; 0x05
    6b94:	9e 81       	ldd	r25, Y+6	; 0x06
    6b96:	83 30       	cpi	r24, 0x03	; 3
    6b98:	91 05       	cpc	r25, r1
    6b9a:	09 f4       	brne	.+2      	; 0x6b9e <LCD_Display+0x42>
    6b9c:	e1 c0       	rjmp	.+450    	; 0x6d60 <LCD_Display+0x204>
    6b9e:	2d 81       	ldd	r18, Y+5	; 0x05
    6ba0:	3e 81       	ldd	r19, Y+6	; 0x06
    6ba2:	24 30       	cpi	r18, 0x04	; 4
    6ba4:	31 05       	cpc	r19, r1
    6ba6:	84 f4       	brge	.+32     	; 0x6bc8 <LCD_Display+0x6c>
    6ba8:	8d 81       	ldd	r24, Y+5	; 0x05
    6baa:	9e 81       	ldd	r25, Y+6	; 0x06
    6bac:	81 30       	cpi	r24, 0x01	; 1
    6bae:	91 05       	cpc	r25, r1
    6bb0:	99 f1       	breq	.+102    	; 0x6c18 <LCD_Display+0xbc>
    6bb2:	2d 81       	ldd	r18, Y+5	; 0x05
    6bb4:	3e 81       	ldd	r19, Y+6	; 0x06
    6bb6:	22 30       	cpi	r18, 0x02	; 2
    6bb8:	31 05       	cpc	r19, r1
    6bba:	0c f0       	brlt	.+2      	; 0x6bbe <LCD_Display+0x62>
    6bbc:	62 c0       	rjmp	.+196    	; 0x6c82 <LCD_Display+0x126>
    6bbe:	8d 81       	ldd	r24, Y+5	; 0x05
    6bc0:	9e 81       	ldd	r25, Y+6	; 0x06
    6bc2:	00 97       	sbiw	r24, 0x00	; 0
    6bc4:	a1 f0       	breq	.+40     	; 0x6bee <LCD_Display+0x92>
    6bc6:	ff c0       	rjmp	.+510    	; 0x6dc6 <LCD_Display+0x26a>
    6bc8:	2d 81       	ldd	r18, Y+5	; 0x05
    6bca:	3e 81       	ldd	r19, Y+6	; 0x06
    6bcc:	26 30       	cpi	r18, 0x06	; 6
    6bce:	31 05       	cpc	r19, r1
    6bd0:	09 f4       	brne	.+2      	; 0x6bd4 <LCD_Display+0x78>
    6bd2:	8c c0       	rjmp	.+280    	; 0x6cec <LCD_Display+0x190>
    6bd4:	8d 81       	ldd	r24, Y+5	; 0x05
    6bd6:	9e 81       	ldd	r25, Y+6	; 0x06
    6bd8:	8b 30       	cpi	r24, 0x0B	; 11
    6bda:	91 05       	cpc	r25, r1
    6bdc:	09 f4       	brne	.+2      	; 0x6be0 <LCD_Display+0x84>
    6bde:	b3 c0       	rjmp	.+358    	; 0x6d46 <LCD_Display+0x1ea>
    6be0:	2d 81       	ldd	r18, Y+5	; 0x05
    6be2:	3e 81       	ldd	r19, Y+6	; 0x06
    6be4:	24 30       	cpi	r18, 0x04	; 4
    6be6:	31 05       	cpc	r19, r1
    6be8:	09 f4       	brne	.+2      	; 0x6bec <LCD_Display+0x90>
    6bea:	d4 c0       	rjmp	.+424    	; 0x6d94 <LCD_Display+0x238>
    6bec:	ec c0       	rjmp	.+472    	; 0x6dc6 <LCD_Display+0x26a>
		{
		case LCD_INIT :
			HCLCD_VidSetPosition_4BitsMode(1,2);
    6bee:	81 e0       	ldi	r24, 0x01	; 1
    6bf0:	62 e0       	ldi	r22, 0x02	; 2
    6bf2:	0e 94 c6 1c 	call	0x398c	; 0x398c <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits("Welcome to");
    6bf6:	85 e6       	ldi	r24, 0x65	; 101
    6bf8:	90 e0       	ldi	r25, 0x00	; 0
    6bfa:	0e 94 26 1c 	call	0x384c	; 0x384c <HCLCD_VidWriteString_4Bits>
			HCLCD_VidSetPosition_4BitsMode(2,3);
    6bfe:	82 e0       	ldi	r24, 0x02	; 2
    6c00:	63 e0       	ldi	r22, 0x03	; 3
    6c02:	0e 94 c6 1c 	call	0x398c	; 0x398c <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits("NTI Bank");
    6c06:	80 e7       	ldi	r24, 0x70	; 112
    6c08:	90 e0       	ldi	r25, 0x00	; 0
    6c0a:	0e 94 26 1c 	call	0x384c	; 0x384c <HCLCD_VidWriteString_4Bits>

			prev_state=LCD_FLAG;
    6c0e:	80 91 ca 07 	lds	r24, 0x07CA
    6c12:	80 93 e0 07 	sts	0x07E0, r24
    6c16:	d7 c0       	rjmp	.+430    	; 0x6dc6 <LCD_Display+0x26a>
			break;
		case LCD_USER_DATA_ID:

			HCLCD_VidSetPosition_4BitsMode(1,0);
    6c18:	81 e0       	ldi	r24, 0x01	; 1
    6c1a:	60 e0       	ldi	r22, 0x00	; 0
    6c1c:	0e 94 c6 1c 	call	0x398c	; 0x398c <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits("ID:");
    6c20:	89 e7       	ldi	r24, 0x79	; 121
    6c22:	90 e0       	ldi	r25, 0x00	; 0
    6c24:	0e 94 26 1c 	call	0x384c	; 0x384c <HCLCD_VidWriteString_4Bits>
			Loc_u8QueueState=xQueueReceive(Keypad_To_LCD_Queue,&Loc_u8Pressed_key,5);
    6c28:	80 91 ec 07 	lds	r24, 0x07EC
    6c2c:	90 91 ed 07 	lds	r25, 0x07ED
    6c30:	9e 01       	movw	r18, r28
    6c32:	2e 5f       	subi	r18, 0xFE	; 254
    6c34:	3f 4f       	sbci	r19, 0xFF	; 255
    6c36:	b9 01       	movw	r22, r18
    6c38:	45 e0       	ldi	r20, 0x05	; 5
    6c3a:	50 e0       	ldi	r21, 0x00	; 0
    6c3c:	20 e0       	ldi	r18, 0x00	; 0
    6c3e:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <xQueueGenericReceive>
    6c42:	89 83       	std	Y+1, r24	; 0x01
			prev_state=LCD_FLAG;
    6c44:	80 91 ca 07 	lds	r24, 0x07CA
    6c48:	80 93 e0 07 	sts	0x07E0, r24

			if(Loc_u8QueueState ==pdPASS)
    6c4c:	89 81       	ldd	r24, Y+1	; 0x01
    6c4e:	81 30       	cpi	r24, 0x01	; 1
    6c50:	09 f0       	breq	.+2      	; 0x6c54 <LCD_Display+0xf8>
    6c52:	b9 c0       	rjmp	.+370    	; 0x6dc6 <LCD_Display+0x26a>
			{

				HCLCD_VidSetPosition_4BitsMode(1,pos);
    6c54:	90 91 eb 01 	lds	r25, 0x01EB
    6c58:	81 e0       	ldi	r24, 0x01	; 1
    6c5a:	69 2f       	mov	r22, r25
    6c5c:	0e 94 c6 1c 	call	0x398c	; 0x398c <HCLCD_VidSetPosition_4BitsMode>
				pos++ ;
    6c60:	80 91 eb 01 	lds	r24, 0x01EB
    6c64:	8f 5f       	subi	r24, 0xFF	; 255
    6c66:	80 93 eb 01 	sts	0x01EB, r24
				HCLCD_VidSendChar_4Bits(Loc_u8Pressed_key);
    6c6a:	8a 81       	ldd	r24, Y+2	; 0x02
    6c6c:	0e 94 14 1c 	call	0x3828	; 0x3828 <HCLCD_VidSendChar_4Bits>
				if(pos == 6)
    6c70:	80 91 eb 01 	lds	r24, 0x01EB
    6c74:	86 30       	cpi	r24, 0x06	; 6
    6c76:	09 f0       	breq	.+2      	; 0x6c7a <LCD_Display+0x11e>
    6c78:	a6 c0       	rjmp	.+332    	; 0x6dc6 <LCD_Display+0x26a>
					pos=4;
    6c7a:	84 e0       	ldi	r24, 0x04	; 4
    6c7c:	80 93 eb 01 	sts	0x01EB, r24
    6c80:	a2 c0       	rjmp	.+324    	; 0x6dc6 <LCD_Display+0x26a>
			}
			break;

		case LCD_USER_DATA_PASS:
			HCLCD_VidSetPosition_4BitsMode(1,0);
    6c82:	81 e0       	ldi	r24, 0x01	; 1
    6c84:	60 e0       	ldi	r22, 0x00	; 0
    6c86:	0e 94 c6 1c 	call	0x398c	; 0x398c <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits("pass:");
    6c8a:	8d e7       	ldi	r24, 0x7D	; 125
    6c8c:	90 e0       	ldi	r25, 0x00	; 0
    6c8e:	0e 94 26 1c 	call	0x384c	; 0x384c <HCLCD_VidWriteString_4Bits>
			Loc_u8QueueState=xQueueReceive(Keypad_To_LCD_Queue,&Loc_u8Pressed_key,5);
    6c92:	80 91 ec 07 	lds	r24, 0x07EC
    6c96:	90 91 ed 07 	lds	r25, 0x07ED
    6c9a:	9e 01       	movw	r18, r28
    6c9c:	2e 5f       	subi	r18, 0xFE	; 254
    6c9e:	3f 4f       	sbci	r19, 0xFF	; 255
    6ca0:	b9 01       	movw	r22, r18
    6ca2:	45 e0       	ldi	r20, 0x05	; 5
    6ca4:	50 e0       	ldi	r21, 0x00	; 0
    6ca6:	20 e0       	ldi	r18, 0x00	; 0
    6ca8:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <xQueueGenericReceive>
    6cac:	89 83       	std	Y+1, r24	; 0x01
			prev_state=LCD_FLAG;
    6cae:	80 91 ca 07 	lds	r24, 0x07CA
    6cb2:	80 93 e0 07 	sts	0x07E0, r24

			if(Loc_u8QueueState ==pdPASS)
    6cb6:	89 81       	ldd	r24, Y+1	; 0x01
    6cb8:	81 30       	cpi	r24, 0x01	; 1
    6cba:	09 f0       	breq	.+2      	; 0x6cbe <LCD_Display+0x162>
    6cbc:	84 c0       	rjmp	.+264    	; 0x6dc6 <LCD_Display+0x26a>
			{

				HCLCD_VidSetPosition_4BitsMode(1,pos2);
    6cbe:	90 91 ea 01 	lds	r25, 0x01EA
    6cc2:	81 e0       	ldi	r24, 0x01	; 1
    6cc4:	69 2f       	mov	r22, r25
    6cc6:	0e 94 c6 1c 	call	0x398c	; 0x398c <HCLCD_VidSetPosition_4BitsMode>
				pos2 ++ ;
    6cca:	80 91 ea 01 	lds	r24, 0x01EA
    6cce:	8f 5f       	subi	r24, 0xFF	; 255
    6cd0:	80 93 ea 01 	sts	0x01EA, r24
				HCLCD_VidSendChar_4Bits(Loc_u8Pressed_key);
    6cd4:	8a 81       	ldd	r24, Y+2	; 0x02
    6cd6:	0e 94 14 1c 	call	0x3828	; 0x3828 <HCLCD_VidSendChar_4Bits>
				if (pos2 == 10)
    6cda:	80 91 ea 01 	lds	r24, 0x01EA
    6cde:	8a 30       	cpi	r24, 0x0A	; 10
    6ce0:	09 f0       	breq	.+2      	; 0x6ce4 <LCD_Display+0x188>
    6ce2:	71 c0       	rjmp	.+226    	; 0x6dc6 <LCD_Display+0x26a>
					pos2 = 6;
    6ce4:	86 e0       	ldi	r24, 0x06	; 6
    6ce6:	80 93 ea 01 	sts	0x01EA, r24
    6cea:	6d c0       	rjmp	.+218    	; 0x6dc6 <LCD_Display+0x26a>
			}
			break;

		case LCD_DRAW_OPTION:
			HCLCD_VidSetPosition_4BitsMode(1,0);
    6cec:	81 e0       	ldi	r24, 0x01	; 1
    6cee:	60 e0       	ldi	r22, 0x00	; 0
    6cf0:	0e 94 c6 1c 	call	0x398c	; 0x398c <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits("withdraw:");
    6cf4:	83 e8       	ldi	r24, 0x83	; 131
    6cf6:	90 e0       	ldi	r25, 0x00	; 0
    6cf8:	0e 94 26 1c 	call	0x384c	; 0x384c <HCLCD_VidWriteString_4Bits>
			Loc_u8QueueState=xQueueReceive(Keypad_To_LCD_Queue,&Loc_u8Pressed_key,5);
    6cfc:	80 91 ec 07 	lds	r24, 0x07EC
    6d00:	90 91 ed 07 	lds	r25, 0x07ED
    6d04:	9e 01       	movw	r18, r28
    6d06:	2e 5f       	subi	r18, 0xFE	; 254
    6d08:	3f 4f       	sbci	r19, 0xFF	; 255
    6d0a:	b9 01       	movw	r22, r18
    6d0c:	45 e0       	ldi	r20, 0x05	; 5
    6d0e:	50 e0       	ldi	r21, 0x00	; 0
    6d10:	20 e0       	ldi	r18, 0x00	; 0
    6d12:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <xQueueGenericReceive>
    6d16:	89 83       	std	Y+1, r24	; 0x01
			prev_state=LCD_FLAG;
    6d18:	80 91 ca 07 	lds	r24, 0x07CA
    6d1c:	80 93 e0 07 	sts	0x07E0, r24

			if(Loc_u8QueueState ==pdPASS)
    6d20:	89 81       	ldd	r24, Y+1	; 0x01
    6d22:	81 30       	cpi	r24, 0x01	; 1
    6d24:	09 f0       	breq	.+2      	; 0x6d28 <LCD_Display+0x1cc>
    6d26:	4f c0       	rjmp	.+158    	; 0x6dc6 <LCD_Display+0x26a>
			{

				HCLCD_VidSetPosition_4BitsMode(1,pos3);
    6d28:	90 91 e9 01 	lds	r25, 0x01E9
    6d2c:	81 e0       	ldi	r24, 0x01	; 1
    6d2e:	69 2f       	mov	r22, r25
    6d30:	0e 94 c6 1c 	call	0x398c	; 0x398c <HCLCD_VidSetPosition_4BitsMode>
				pos3++ ;
    6d34:	80 91 e9 01 	lds	r24, 0x01E9
    6d38:	8f 5f       	subi	r24, 0xFF	; 255
    6d3a:	80 93 e9 01 	sts	0x01E9, r24
				HCLCD_VidSendChar_4Bits(Loc_u8Pressed_key);
    6d3e:	8a 81       	ldd	r24, Y+2	; 0x02
    6d40:	0e 94 14 1c 	call	0x3828	; 0x3828 <HCLCD_VidSendChar_4Bits>
    6d44:	40 c0       	rjmp	.+128    	; 0x6dc6 <LCD_Display+0x26a>
			}

			break;
		case LCD_PROCESS_DONE :
			HCLCD_VidSetPosition_4BitsMode(1,0);
    6d46:	81 e0       	ldi	r24, 0x01	; 1
    6d48:	60 e0       	ldi	r22, 0x00	; 0
    6d4a:	0e 94 c6 1c 	call	0x398c	; 0x398c <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits("Process Done.");
    6d4e:	8d e8       	ldi	r24, 0x8D	; 141
    6d50:	90 e0       	ldi	r25, 0x00	; 0
    6d52:	0e 94 26 1c 	call	0x384c	; 0x384c <HCLCD_VidWriteString_4Bits>
			prev_state=LCD_FLAG;
    6d56:	80 91 ca 07 	lds	r24, 0x07CA
    6d5a:	80 93 e0 07 	sts	0x07E0, r24
    6d5e:	33 c0       	rjmp	.+102    	; 0x6dc6 <LCD_Display+0x26a>
			break;

		case LCD_WRONG_ID:
			HCLCD_VidSetPosition_4BitsMode(1,3);
    6d60:	81 e0       	ldi	r24, 0x01	; 1
    6d62:	63 e0       	ldi	r22, 0x03	; 3
    6d64:	0e 94 c6 1c 	call	0x398c	; 0x398c <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits("Wrong ID");
    6d68:	8b e9       	ldi	r24, 0x9B	; 155
    6d6a:	90 e0       	ldi	r25, 0x00	; 0
    6d6c:	0e 94 26 1c 	call	0x384c	; 0x384c <HCLCD_VidWriteString_4Bits>
			prev_state=LCD_FLAG;
    6d70:	80 91 ca 07 	lds	r24, 0x07CA
    6d74:	80 93 e0 07 	sts	0x07E0, r24
			LCD_FLAG = LCD_INIT;
    6d78:	10 92 ca 07 	sts	0x07CA, r1
			xSemaphoreTake(Entry_sem,5);
    6d7c:	80 91 e5 07 	lds	r24, 0x07E5
    6d80:	90 91 e6 07 	lds	r25, 0x07E6
    6d84:	60 e0       	ldi	r22, 0x00	; 0
    6d86:	70 e0       	ldi	r23, 0x00	; 0
    6d88:	45 e0       	ldi	r20, 0x05	; 5
    6d8a:	50 e0       	ldi	r21, 0x00	; 0
    6d8c:	20 e0       	ldi	r18, 0x00	; 0
    6d8e:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <xQueueGenericReceive>
    6d92:	19 c0       	rjmp	.+50     	; 0x6dc6 <LCD_Display+0x26a>
			break;

		case LCD_WRONG_PASS:
			HCLCD_VidSetPosition_4BitsMode(1,3);
    6d94:	81 e0       	ldi	r24, 0x01	; 1
    6d96:	63 e0       	ldi	r22, 0x03	; 3
    6d98:	0e 94 c6 1c 	call	0x398c	; 0x398c <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits("Wrong Password");
    6d9c:	84 ea       	ldi	r24, 0xA4	; 164
    6d9e:	90 e0       	ldi	r25, 0x00	; 0
    6da0:	0e 94 26 1c 	call	0x384c	; 0x384c <HCLCD_VidWriteString_4Bits>
			prev_state=LCD_FLAG;
    6da4:	80 91 ca 07 	lds	r24, 0x07CA
    6da8:	80 93 e0 07 	sts	0x07E0, r24
			LCD_FLAG = LCD_INIT;
    6dac:	10 92 ca 07 	sts	0x07CA, r1
			xSemaphoreTake(Entry_sem,5);
    6db0:	80 91 e5 07 	lds	r24, 0x07E5
    6db4:	90 91 e6 07 	lds	r25, 0x07E6
    6db8:	60 e0       	ldi	r22, 0x00	; 0
    6dba:	70 e0       	ldi	r23, 0x00	; 0
    6dbc:	45 e0       	ldi	r20, 0x05	; 5
    6dbe:	50 e0       	ldi	r21, 0x00	; 0
    6dc0:	20 e0       	ldi	r18, 0x00	; 0
    6dc2:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <xQueueGenericReceive>
			LCD_FLAG = LCD_INIT;
			xSemaphoreTake(Entry_sem,5);
			break;*/
		}

		vTaskDelay(150);
    6dc6:	86 e9       	ldi	r24, 0x96	; 150
    6dc8:	90 e0       	ldi	r25, 0x00	; 0
    6dca:	0e 94 33 2b 	call	0x5666	; 0x5666 <vTaskDelay>
    6dce:	cf ce       	rjmp	.-610    	; 0x6b6e <LCD_Display+0x12>

00006dd0 <__mulsi3>:
    6dd0:	62 9f       	mul	r22, r18
    6dd2:	d0 01       	movw	r26, r0
    6dd4:	73 9f       	mul	r23, r19
    6dd6:	f0 01       	movw	r30, r0
    6dd8:	82 9f       	mul	r24, r18
    6dda:	e0 0d       	add	r30, r0
    6ddc:	f1 1d       	adc	r31, r1
    6dde:	64 9f       	mul	r22, r20
    6de0:	e0 0d       	add	r30, r0
    6de2:	f1 1d       	adc	r31, r1
    6de4:	92 9f       	mul	r25, r18
    6de6:	f0 0d       	add	r31, r0
    6de8:	83 9f       	mul	r24, r19
    6dea:	f0 0d       	add	r31, r0
    6dec:	74 9f       	mul	r23, r20
    6dee:	f0 0d       	add	r31, r0
    6df0:	65 9f       	mul	r22, r21
    6df2:	f0 0d       	add	r31, r0
    6df4:	99 27       	eor	r25, r25
    6df6:	72 9f       	mul	r23, r18
    6df8:	b0 0d       	add	r27, r0
    6dfa:	e1 1d       	adc	r30, r1
    6dfc:	f9 1f       	adc	r31, r25
    6dfe:	63 9f       	mul	r22, r19
    6e00:	b0 0d       	add	r27, r0
    6e02:	e1 1d       	adc	r30, r1
    6e04:	f9 1f       	adc	r31, r25
    6e06:	bd 01       	movw	r22, r26
    6e08:	cf 01       	movw	r24, r30
    6e0a:	11 24       	eor	r1, r1
    6e0c:	08 95       	ret

00006e0e <__udivmodsi4>:
    6e0e:	a1 e2       	ldi	r26, 0x21	; 33
    6e10:	1a 2e       	mov	r1, r26
    6e12:	aa 1b       	sub	r26, r26
    6e14:	bb 1b       	sub	r27, r27
    6e16:	fd 01       	movw	r30, r26
    6e18:	0d c0       	rjmp	.+26     	; 0x6e34 <__udivmodsi4_ep>

00006e1a <__udivmodsi4_loop>:
    6e1a:	aa 1f       	adc	r26, r26
    6e1c:	bb 1f       	adc	r27, r27
    6e1e:	ee 1f       	adc	r30, r30
    6e20:	ff 1f       	adc	r31, r31
    6e22:	a2 17       	cp	r26, r18
    6e24:	b3 07       	cpc	r27, r19
    6e26:	e4 07       	cpc	r30, r20
    6e28:	f5 07       	cpc	r31, r21
    6e2a:	20 f0       	brcs	.+8      	; 0x6e34 <__udivmodsi4_ep>
    6e2c:	a2 1b       	sub	r26, r18
    6e2e:	b3 0b       	sbc	r27, r19
    6e30:	e4 0b       	sbc	r30, r20
    6e32:	f5 0b       	sbc	r31, r21

00006e34 <__udivmodsi4_ep>:
    6e34:	66 1f       	adc	r22, r22
    6e36:	77 1f       	adc	r23, r23
    6e38:	88 1f       	adc	r24, r24
    6e3a:	99 1f       	adc	r25, r25
    6e3c:	1a 94       	dec	r1
    6e3e:	69 f7       	brne	.-38     	; 0x6e1a <__udivmodsi4_loop>
    6e40:	60 95       	com	r22
    6e42:	70 95       	com	r23
    6e44:	80 95       	com	r24
    6e46:	90 95       	com	r25
    6e48:	9b 01       	movw	r18, r22
    6e4a:	ac 01       	movw	r20, r24
    6e4c:	bd 01       	movw	r22, r26
    6e4e:	cf 01       	movw	r24, r30
    6e50:	08 95       	ret

00006e52 <__prologue_saves__>:
    6e52:	2f 92       	push	r2
    6e54:	3f 92       	push	r3
    6e56:	4f 92       	push	r4
    6e58:	5f 92       	push	r5
    6e5a:	6f 92       	push	r6
    6e5c:	7f 92       	push	r7
    6e5e:	8f 92       	push	r8
    6e60:	9f 92       	push	r9
    6e62:	af 92       	push	r10
    6e64:	bf 92       	push	r11
    6e66:	cf 92       	push	r12
    6e68:	df 92       	push	r13
    6e6a:	ef 92       	push	r14
    6e6c:	ff 92       	push	r15
    6e6e:	0f 93       	push	r16
    6e70:	1f 93       	push	r17
    6e72:	cf 93       	push	r28
    6e74:	df 93       	push	r29
    6e76:	cd b7       	in	r28, 0x3d	; 61
    6e78:	de b7       	in	r29, 0x3e	; 62
    6e7a:	ca 1b       	sub	r28, r26
    6e7c:	db 0b       	sbc	r29, r27
    6e7e:	0f b6       	in	r0, 0x3f	; 63
    6e80:	f8 94       	cli
    6e82:	de bf       	out	0x3e, r29	; 62
    6e84:	0f be       	out	0x3f, r0	; 63
    6e86:	cd bf       	out	0x3d, r28	; 61
    6e88:	09 94       	ijmp

00006e8a <__epilogue_restores__>:
    6e8a:	2a 88       	ldd	r2, Y+18	; 0x12
    6e8c:	39 88       	ldd	r3, Y+17	; 0x11
    6e8e:	48 88       	ldd	r4, Y+16	; 0x10
    6e90:	5f 84       	ldd	r5, Y+15	; 0x0f
    6e92:	6e 84       	ldd	r6, Y+14	; 0x0e
    6e94:	7d 84       	ldd	r7, Y+13	; 0x0d
    6e96:	8c 84       	ldd	r8, Y+12	; 0x0c
    6e98:	9b 84       	ldd	r9, Y+11	; 0x0b
    6e9a:	aa 84       	ldd	r10, Y+10	; 0x0a
    6e9c:	b9 84       	ldd	r11, Y+9	; 0x09
    6e9e:	c8 84       	ldd	r12, Y+8	; 0x08
    6ea0:	df 80       	ldd	r13, Y+7	; 0x07
    6ea2:	ee 80       	ldd	r14, Y+6	; 0x06
    6ea4:	fd 80       	ldd	r15, Y+5	; 0x05
    6ea6:	0c 81       	ldd	r16, Y+4	; 0x04
    6ea8:	1b 81       	ldd	r17, Y+3	; 0x03
    6eaa:	aa 81       	ldd	r26, Y+2	; 0x02
    6eac:	b9 81       	ldd	r27, Y+1	; 0x01
    6eae:	ce 0f       	add	r28, r30
    6eb0:	d1 1d       	adc	r29, r1
    6eb2:	0f b6       	in	r0, 0x3f	; 63
    6eb4:	f8 94       	cli
    6eb6:	de bf       	out	0x3e, r29	; 62
    6eb8:	0f be       	out	0x3f, r0	; 63
    6eba:	cd bf       	out	0x3d, r28	; 61
    6ebc:	ed 01       	movw	r28, r26
    6ebe:	08 95       	ret

00006ec0 <memcpy>:
    6ec0:	fb 01       	movw	r30, r22
    6ec2:	dc 01       	movw	r26, r24
    6ec4:	02 c0       	rjmp	.+4      	; 0x6eca <memcpy+0xa>
    6ec6:	01 90       	ld	r0, Z+
    6ec8:	0d 92       	st	X+, r0
    6eca:	41 50       	subi	r20, 0x01	; 1
    6ecc:	50 40       	sbci	r21, 0x00	; 0
    6ece:	d8 f7       	brcc	.-10     	; 0x6ec6 <memcpy+0x6>
    6ed0:	08 95       	ret

00006ed2 <memset>:
    6ed2:	dc 01       	movw	r26, r24
    6ed4:	01 c0       	rjmp	.+2      	; 0x6ed8 <memset+0x6>
    6ed6:	6d 93       	st	X+, r22
    6ed8:	41 50       	subi	r20, 0x01	; 1
    6eda:	50 40       	sbci	r21, 0x00	; 0
    6edc:	e0 f7       	brcc	.-8      	; 0x6ed6 <memset+0x4>
    6ede:	08 95       	ret

00006ee0 <strncpy>:
    6ee0:	fb 01       	movw	r30, r22
    6ee2:	dc 01       	movw	r26, r24
    6ee4:	41 50       	subi	r20, 0x01	; 1
    6ee6:	50 40       	sbci	r21, 0x00	; 0
    6ee8:	48 f0       	brcs	.+18     	; 0x6efc <strncpy+0x1c>
    6eea:	01 90       	ld	r0, Z+
    6eec:	0d 92       	st	X+, r0
    6eee:	00 20       	and	r0, r0
    6ef0:	c9 f7       	brne	.-14     	; 0x6ee4 <strncpy+0x4>
    6ef2:	01 c0       	rjmp	.+2      	; 0x6ef6 <strncpy+0x16>
    6ef4:	1d 92       	st	X+, r1
    6ef6:	41 50       	subi	r20, 0x01	; 1
    6ef8:	50 40       	sbci	r21, 0x00	; 0
    6efa:	e0 f7       	brcc	.-8      	; 0x6ef4 <strncpy+0x14>
    6efc:	08 95       	ret

00006efe <_exit>:
    6efe:	f8 94       	cli

00006f00 <__stop_program>:
    6f00:	ff cf       	rjmp	.-2      	; 0x6f00 <__stop_program>
